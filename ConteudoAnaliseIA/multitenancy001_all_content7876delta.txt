### PROJECT FILE INDEX
pom.xml
src/main/java/brito/com/multitenancy001/Multitenancy001Application.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountController.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountProvisioningEventController.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountQueryController.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountAdminDetailsResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountProvisioningEventResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountStatusChangeRequest.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountStatusChangeResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/summary/AccountTenantUserSummaryResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountAdminDetailsApiMapper.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountApiMapper.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountUserApiMapper.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountEntitlementsProvisioningService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountFactory.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountLifecycleService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountStatusService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountTenantUserService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/audit/AccountProvisioningAuditService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/command/AccountStatusChangeCommand.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/command/CreateAccountCommand.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountAdminDetailsProjection.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountStatusChangeResult.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountTenantUserSummaryData.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/AccountProvisioningEventQueryService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/ControlPlaneAccountQueryService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/dto/AccountProvisioningEventData.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/Account.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountEntitlements.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountProvisioningEvent.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountStatus.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountType.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/LegalEntityType.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/ProvisioningFailureCode.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/ProvisioningStatus.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/SubscriptionPlan.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/TaxIdType.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountEntitlementsRepository.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountProvisioningEventRepository.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountRepository.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountResolverProjection.java
src/main/java/brito/com/multitenancy001/controlplane/auth/api/admin/ControlPlaneAuthController.java
src/main/java/brito/com/multitenancy001/controlplane/auth/api/dto/ControlPlaneAdminLoginRequest.java
src/main/java/brito/com/multitenancy001/controlplane/auth/app/ControlPlaneAuthService.java
src/main/java/brito/com/multitenancy001/controlplane/auth/app/command/ControlPlaneAdminLoginCommand.java
src/main/java/brito/com/multitenancy001/controlplane/billing/api/admin/ControlPlanePaymentController.java
src/main/java/brito/com/multitenancy001/controlplane/billing/api/admin/ControlPlanePaymentQueryController.java
src/main/java/brito/com/multitenancy001/controlplane/billing/app/ControlPlanePaymentService.java
src/main/java/brito/com/multitenancy001/controlplane/billing/app/query/ControlPlanePaymentQueryService.java
src/main/java/brito/com/multitenancy001/controlplane/billing/domain/Payment.java
src/main/java/brito/com/multitenancy001/controlplane/billing/persistence/ControlPlanePaymentRepository.java
src/main/java/brito/com/multitenancy001/controlplane/scheduling/app/AccountJobScheduleService.java
src/main/java/brito/com/multitenancy001/controlplane/scheduling/domain/AccountJobSchedule.java
src/main/java/brito/com/multitenancy001/controlplane/scheduling/infra/AccountJobScheduler.java
src/main/java/brito/com/multitenancy001/controlplane/scheduling/persistence/AccountJobScheduleRepository.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlanePermission.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRole.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRolePermissions.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneSystemRoleMapper.java
src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/SignupRequest.java
src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/SignupResponse.java
src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/TenantAdminResponse.java
src/main/java/brito/com/multitenancy001/controlplane/signup/api/publicweb/AccountSignupController.java
src/main/java/brito/com/multitenancy001/controlplane/signup/app/AccountOnboardingService.java
src/main/java/brito/com/multitenancy001/controlplane/signup/app/command/SignupCommand.java
src/main/java/brito/com/multitenancy001/controlplane/signup/app/dto/SignupResult.java
src/main/java/brito/com/multitenancy001/controlplane/signup/app/dto/TenantAdminResult.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/admin/ControlPlaneMeController.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/admin/ControlPlaneUserController.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneAdminUserSummaryResponse.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneChangeMyPasswordRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneMeResponse.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserCreateRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserDetailsResponse.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserPasswordResetRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserPermissionsUpdateRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserUpdateRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/mapper/ControlPlaneUserApiMapper.java
src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserExplicitPermissionsService.java
src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserService.java
src/main/java/brito/com/multitenancy001/controlplane/users/domain/ControlPlaneBuiltInUsers.java
src/main/java/brito/com/multitenancy001/controlplane/users/domain/ControlPlaneUser.java
src/main/java/brito/com/multitenancy001/controlplane/users/persistence/ControlPlaneUserRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/config/time/TimeConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayRunner.java
src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicSchemaVerifier.java
src/main/java/brito/com/multitenancy001/infrastructure/flyway/tenantschema/TenantSchemaFlywayMigrationService.java
src/main/java/brito/com/multitenancy001/infrastructure/jpa/publicschema/PublicPersistenceConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/jpa/publicschema/PublicSchemaHibernateConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/jpa/tenantschema/TenantPersistenceConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/CurrentTenantSchemaResolver.java
src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TenantSchemaConnectionProvider.java
src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TenantSchemaHibernateConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TransactionManagementConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/observability/TenantContextMonitor.java
src/main/java/brito/com/multitenancy001/infrastructure/openapi/OpenApiConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/TransactionExecutor.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEvent.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEventRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditEvent.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditEventRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallenge.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallengeRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/security/AuthenticatedUserContext.java
src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityConstants.java
src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityUtils.java
src/main/java/brito/com/multitenancy001/infrastructure/security/authorities/AuthoritiesFactory.java
src/main/java/brito/com/multitenancy001/infrastructure/security/config/RestAccessDeniedHandler.java
src/main/java/brito/com/multitenancy001/infrastructure/security/config/RestAuthenticationEntryPoint.java
src/main/java/brito/com/multitenancy001/infrastructure/security/config/SecurityConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/JwtAuthenticationFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/MustChangePasswordFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/RequestLoggingFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/RequestMetaContextFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/TenantHeaderTenantContextFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/jwt/JwtTokenProvider.java
src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/MultiContextUserDetailsService.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantExecutor.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantReadyExecutor.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantRequiredTables.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningFacade.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningService.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantUnitOfWork.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantUserProvisioningFacade.java
src/main/java/brito/com/multitenancy001/shared/account/UserLimitPolicy.java
src/main/java/brito/com/multitenancy001/shared/api/dto/auth/JwtResponse.java
src/main/java/brito/com/multitenancy001/shared/api/dto/billing/AdminPaymentRequest.java
src/main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentRequest.java
src/main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentResponse.java
src/main/java/brito/com/multitenancy001/shared/api/error/ApiEnumErrorResponse.java
src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorResponse.java
src/main/java/brito/com/multitenancy001/shared/api/error/GlobalExceptionHandler.java
src/main/java/brito/com/multitenancy001/shared/audit/AuthEventAuditService.java
src/main/java/brito/com/multitenancy001/shared/audit/SecurityAuditService.java
src/main/java/brito/com/multitenancy001/shared/auth/app/dto/JwtResult.java
src/main/java/brito/com/multitenancy001/shared/billing/PaymentQueryFacade.java
src/main/java/brito/com/multitenancy001/shared/context/RequestMeta.java
src/main/java/brito/com/multitenancy001/shared/context/RequestMetaContext.java
src/main/java/brito/com/multitenancy001/shared/context/TenantContext.java
src/main/java/brito/com/multitenancy001/shared/contracts/AccountRef.java
src/main/java/brito/com/multitenancy001/shared/contracts/AccountSnapshot.java
src/main/java/brito/com/multitenancy001/shared/contracts/UserSummaryData.java
src/main/java/brito/com/multitenancy001/shared/db/Schemas.java
src/main/java/brito/com/multitenancy001/shared/domain/DomainException.java
src/main/java/brito/com/multitenancy001/shared/domain/EmailNormalizer.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditActor.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditInfo.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/Auditable.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/SoftDeletable.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditActorProvider.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditActorProviders.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditClockProvider.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditClockProviders.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditEntityListener.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditWiringVerifier.java
src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentGateway.java
src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentMethod.java
src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentStatus.java
src/main/java/brito/com/multitenancy001/shared/domain/common/EntityOrigin.java
src/main/java/brito/com/multitenancy001/shared/executor/PublicExecutor.java
src/main/java/brito/com/multitenancy001/shared/executor/PublicUnitOfWork.java
src/main/java/brito/com/multitenancy001/shared/kernel/error/ApiException.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsGuard.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsService.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsSnapshot.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountResolver.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountSnapshot.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityProvisioningService.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityResolver.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityRow.java
src/main/java/brito/com/multitenancy001/shared/security/AuthenticatedPrincipal.java
src/main/java/brito/com/multitenancy001/shared/security/PermissionAuthority.java
src/main/java/brito/com/multitenancy001/shared/security/PermissionCode.java
src/main/java/brito/com/multitenancy001/shared/security/PermissionScopeValidator.java
src/main/java/brito/com/multitenancy001/shared/security/RoleAuthority.java
src/main/java/brito/com/multitenancy001/shared/security/SystemRoleName.java
src/main/java/brito/com/multitenancy001/shared/security/TenantRoleName.java
src/main/java/brito/com/multitenancy001/shared/security/TenantSystemRoleMapper.java
src/main/java/brito/com/multitenancy001/shared/time/AppClock.java
src/main/java/brito/com/multitenancy001/shared/time/SystemAppClock.java
src/main/java/brito/com/multitenancy001/shared/validation/ValidationPatterns.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantAuthController.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantPasswordController.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/AccountSelectionOption.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/AccountSelectionRequiredResponse.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/ForgotPasswordRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/ResetPasswordRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantLoginConfirmRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantLoginInitRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantRefreshRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantSelectionOption.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantAuthService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginChallengeService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/command/TenantLoginConfirmCommand.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/command/TenantLoginInitCommand.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/AccountSelectionOptionData.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/TenantLoginResult.java
src/main/java/brito/com/multitenancy001/tenant/billing/api/TenantPaymentController.java
src/main/java/brito/com/multitenancy001/tenant/billing/app/TenantBillingService.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/TenantCategoryController.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/TenantSubcategoryController.java
src/main/java/brito/com/multitenancy001/tenant/categories/app/TenantCategoryService.java
src/main/java/brito/com/multitenancy001/tenant/categories/app/TenantSubcategoryService.java
src/main/java/brito/com/multitenancy001/tenant/categories/domain/Category.java
src/main/java/brito/com/multitenancy001/tenant/categories/domain/Subcategory.java
src/main/java/brito/com/multitenancy001/tenant/categories/persistence/TenantCategoryRepository.java
src/main/java/brito/com/multitenancy001/tenant/categories/persistence/TenantSubcategoryRepository.java
src/main/java/brito/com/multitenancy001/tenant/debug/api/TenantDebugController.java
src/main/java/brito/com/multitenancy001/tenant/me/api/TenantMeController.java
src/main/java/brito/com/multitenancy001/tenant/me/api/dto/TenantMeResponse.java
src/main/java/brito/com/multitenancy001/tenant/me/api/dto/UpdateMyProfileRequest.java
src/main/java/brito/com/multitenancy001/tenant/products/api/TenantProductController.java
src/main/java/brito/com/multitenancy001/tenant/products/api/dto/ProductResponse.java
src/main/java/brito/com/multitenancy001/tenant/products/api/dto/ProductUpsertRequest.java
src/main/java/brito/com/multitenancy001/tenant/products/api/dto/SupplierProductCountResponse.java
src/main/java/brito/com/multitenancy001/tenant/products/api/mapper/ProductApiMapper.java
src/main/java/brito/com/multitenancy001/tenant/products/app/TenantProductService.java
src/main/java/brito/com/multitenancy001/tenant/products/domain/Product.java
src/main/java/brito/com/multitenancy001/tenant/products/persistence/TenantProductRepository.java
src/main/java/brito/com/multitenancy001/tenant/provisioning/infra/TenantFlywayMigrator.java
src/main/java/brito/com/multitenancy001/tenant/sales/domain/Sale.java
src/main/java/brito/com/multitenancy001/tenant/sales/domain/SaleItem.java
src/main/java/brito/com/multitenancy001/tenant/sales/domain/SaleStatus.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantPermission.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantRole.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantRoleMapper.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantRolePermissions.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/api/TenantSupplierController.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/app/TenantSupplierService.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/domain/Supplier.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/persistence/TenantSupplierRepository.java
src/main/java/brito/com/multitenancy001/tenant/users/api/TenantUserController.java
src/main/java/brito/com/multitenancy001/tenant/users/api/admin/TenantUserAdminController.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantActorRef.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserCreateRequest.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserDetailsResponse.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserListItemResponse.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserSummaryResponse.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUsersListResponse.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/admin/TenantUserAdminSuspendRequest.java
src/main/java/brito/com/multitenancy001/tenant/users/api/mapper/TenantUserApiMapper.java
src/main/java/brito/com/multitenancy001/tenant/users/app/TenantUserFacade.java
src/main/java/brito/com/multitenancy001/tenant/users/app/TenantUserService.java
src/main/java/brito/com/multitenancy001/tenant/users/app/admin/TenantUserAdminService.java
src/main/java/brito/com/multitenancy001/tenant/users/domain/TenantUser.java
src/main/java/brito/com/multitenancy001/tenant/users/domain/permission/TenantUserPermission.java
src/main/java/brito/com/multitenancy001/tenant/users/persistence/TenantUserRepository.java
src/main/resources/application-dev.properties
src/main/resources/application.properties
src/main/resources/db/migration/accounts/V10__create_table_account_provisioning_events.sql
src/main/resources/db/migration/accounts/V11__create_table_tenant_login_challenges.sql
src/main/resources/db/migration/accounts/V13__seed_account_entitlements_for_existing_accounts.sql
src/main/resources/db/migration/accounts/V14__create_table_auth_events.sql
src/main/resources/db/migration/accounts/V15__create_table_security_audit_events.sql
src/main/resources/db/migration/accounts/V16__create_table_account_job_schedules.sql
src/main/resources/db/migration/accounts/V17__alter_controlplane_users_email_to_citext.sql
src/main/resources/db/migration/accounts/V1__create_extension.sql
src/main/resources/db/migration/accounts/V2__create_table_accounts.sql
src/main/resources/db/migration/accounts/V3__create_table_account_entitlements.sql
src/main/resources/db/migration/accounts/V4__create_table_controlplane_users.sql
src/main/resources/db/migration/accounts/V5__insert_controlplane_account.sql
src/main/resources/db/migration/accounts/V6__insert_controlplane_users.sql
src/main/resources/db/migration/accounts/V7__create_table_controlplane_user_permissions.sql
src/main/resources/db/migration/accounts/V8__create_table_payments.sql
src/main/resources/db/migration/accounts/V9__create_table_login_identities.sql
src/main/resources/db/migration/tenants/V1__create_table_tenant_users.sql
src/main/resources/db/migration/tenants/V2__create_table_tenant_user_permissions.sql
src/main/resources/db/migration/tenants/V3__create_table_categories.sql
src/main/resources/db/migration/tenants/V4__create_table_subcategories.sql
src/main/resources/db/migration/tenants/V5__create_table_suppliers.sql
src/main/resources/db/migration/tenants/V6__create_table_products.sql
src/main/resources/db/migration/tenants/V7__create_table_sales.sql
src/main/resources/db/migration/tenants/V8__create_table_sales_items.sql
src/test/java/brito/com/multitenancy001/Multitenancy001ApplicationTests.java

### FILE CONTENTS

============================================================
### FILE: pom.xml
============================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.9</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>brito.com.example</groupId>
	<artifactId>multitenancy001</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>multitenancy001</name>
	<description>Prototipo Multi Tenancy</description>
	
	<properties>
		<java.version>21</java.version>
		<!-- força a versão do Flyway usada pelo Spring Boot BOM -->
        <flyway.version>11.20.2</flyway.version>
		<maven-resources-plugin.version>3.3.1</maven-resources-plugin.version>
	</properties>
	
	<dependencies>
		<!-- Spring Boot Starters -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		
<!-- Swagger / OpenAPI (compatível com Spring Boot 3.5.9 / Spring 6.2.x) -->
<dependency>
  <groupId>org.springdoc</groupId>
  <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
  <version>2.8.15</version>
</dependency>

		<!-- Database -->
		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>
		
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
		</dependency>
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-database-postgresql</artifactId>
		</dependency>

		<!-- JWT (JJWT) para Spring Boot 3 -->
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.12.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.12.5</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.12.5</version>
			<scope>runtime</scope>
		</dependency>

		<!-- Lombok -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>

		<!-- DevTools -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<optional>true</optional>
		</dependency>

		<!-- Test dependencies -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
			<!-- Adicione esta configuração para o resources plugin -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-resources-plugin</artifactId>
				
				<configuration>
					<encoding>UTF-8</encoding>
					<nonFilteredFileExtensions>
						<nonFilteredFileExtension>properties</nonFilteredFileExtension>
						<nonFilteredFileExtension>yml</nonFilteredFileExtension>
						<nonFilteredFileExtension>yaml</nonFilteredFileExtension>
					</nonFilteredFileExtensions>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>

============================================================
### FILE: src/main/java/brito/com/multitenancy001/Multitenancy001Application.java
============================================================
package brito.com.multitenancy001;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
//@EnableCaching
@EnableScheduling
public class Multitenancy001Application {

	public static void main(String[] args) {
		SpringApplication.run(Multitenancy001Application.class, args);
	}

}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountController.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.admin;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountResponse;
import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.accounts.api.dto.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountAdminDetailsApiMapper;
import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.accounts.app.AccountLifecycleService;
import brito.com.multitenancy001.controlplane.accounts.app.command.AccountStatusChangeCommand;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountAdminDetailsProjection;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountStatusChangeResult;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountTenantUserSummaryData;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.signup.api.dto.SignupRequest;
import brito.com.multitenancy001.controlplane.signup.api.dto.SignupResponse;
import brito.com.multitenancy001.controlplane.signup.api.dto.TenantAdminResponse;
import brito.com.multitenancy001.controlplane.signup.app.command.SignupCommand;
import brito.com.multitenancy001.controlplane.signup.app.dto.SignupResult;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.Instant;
import java.util.List;

@RestController
@RequestMapping("/api/controlplane/accounts")
@RequiredArgsConstructor
public class ControlPlaneAccountController {

    private final AccountLifecycleService accountLifecycleService;

    private final AccountApiMapper accountApiMapper;
    private final AccountAdminDetailsApiMapper accountAdminDetailsApiMapper;

    // signup via admin (se existir)
    @PostMapping("/signup")
    public ResponseEntity<SignupResponse> createAccount(@Valid @RequestBody SignupRequest req) {

        SignupResult result = accountLifecycleService.createAccount(new SignupCommand(
                req.displayName(),
                req.loginEmail(),
                req.taxIdType(),
                req.taxIdNumber(),
                req.password(),
                req.confirmPassword()
        ));

        SignupResponse http = new SignupResponse(
                accountApiMapper.toResponse(result.account()),
                new TenantAdminResponse(
                        result.tenantAdmin().id(),
                        result.tenantAdmin().email(),
                        result.tenantAdmin().role()
                )
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(http);
    }

    @GetMapping
    public ResponseEntity<List<AccountResponse>> listAccounts() {
        List<AccountResponse> out = accountLifecycleService.listAccounts()
                .stream().map(accountApiMapper::toResponse).toList();
        return ResponseEntity.ok(out);
    }

    @GetMapping("/{accountId}")
    public ResponseEntity<AccountResponse> getAccount(@PathVariable Long accountId) {
        Account a = accountLifecycleService.getAccount(accountId);
        return ResponseEntity.ok(accountApiMapper.toResponse(a));
    }

    @GetMapping("/{accountId}/admin-details")
    public ResponseEntity<AccountAdminDetailsResponse> getAdminDetails(@PathVariable Long accountId) {
        AccountAdminDetailsProjection p = accountLifecycleService.getAccountAdminDetails(accountId);
        return ResponseEntity.ok(accountAdminDetailsApiMapper.toResponse(p.account(), p.admin(), p.totalUsers()));
    }

    @PostMapping("/{accountId}/status")
    public ResponseEntity<AccountStatusChangeResponse> changeStatus(
            @PathVariable Long accountId,
            @Valid @RequestBody AccountStatusChangeRequest req
    ) {
        AccountStatusChangeResult r = accountLifecycleService.changeAccountStatus(
                accountId,
                new AccountStatusChangeCommand(req.status())
        );

        AccountStatusChangeResponse http = new AccountStatusChangeResponse(
                r.accountId(),
                r.newStatus(),
                r.previousStatus(),
                r.changedAt(),
                r.tenantSchema(),
                new AccountStatusChangeResponse.SideEffects(
                        r.tenantUsersUpdated(),
                        r.action(),
                        r.affectedUsers()
                )
        );

        return ResponseEntity.ok(http);
    }

    @DeleteMapping("/{accountId}")
    public ResponseEntity<Void> softDelete(@PathVariable Long accountId) {
        accountLifecycleService.softDeleteAccount(accountId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{accountId}/restore")
    public ResponseEntity<Void> restore(@PathVariable Long accountId) {
        accountLifecycleService.restoreAccount(accountId);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/{accountId}/tenant-users")
    public ResponseEntity<List<AccountTenantUserSummaryResponse>> listTenantUsers(
            @PathVariable Long accountId,
            @RequestParam(name = "onlyOperational", defaultValue = "false") boolean onlyOperational
    ) {
        List<AccountTenantUserSummaryResponse> out = accountLifecycleService.listTenantUsers(accountId, onlyOperational)
                .stream().map(ControlPlaneAccountController::toHttpTenantUser).toList();
        return ResponseEntity.ok(out);
    }

    @PostMapping("/{accountId}/tenant-users/{userId}/suspended-by-admin")
    public ResponseEntity<Void> setSuspendedByAdmin(
            @PathVariable Long accountId,
            @PathVariable Long userId,
            @RequestParam("value") boolean value
    ) {
        accountLifecycleService.setUserSuspendedByAdmin(accountId, userId, value);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/by-status")
    public ResponseEntity<Page<AccountResponse>> listByStatus(
            @RequestParam AccountStatus status,
            Pageable pageable
    ) {
        return ResponseEntity.ok(accountLifecycleService.listAccountsByStatus(status, pageable).map(accountApiMapper::toResponse));
    }

    @GetMapping("/created-between")
    public ResponseEntity<Page<AccountResponse>> listCreatedBetween(
            @RequestParam("start") String startIso,
            @RequestParam("end") String endIso,
            Pageable pageable
    ) {
        Instant start = Instant.parse(startIso);
        Instant end = Instant.parse(endIso);
        return ResponseEntity.ok(accountLifecycleService.listAccountsCreatedBetween(start, end, pageable).map(accountApiMapper::toResponse));
    }

    @GetMapping("/search")
    public ResponseEntity<Page<AccountResponse>> search(
            @RequestParam("term") String term,
            Pageable pageable
    ) {
        return ResponseEntity.ok(accountLifecycleService.searchAccountsByDisplayName(term, pageable).map(accountApiMapper::toResponse));
    }

    private static AccountTenantUserSummaryResponse toHttpTenantUser(AccountTenantUserSummaryData d) {
        return new AccountTenantUserSummaryResponse(
                d.id(), d.accountId(), d.name(), d.email(), d.role(),
                d.suspendedByAccount(), d.suspendedByAdmin(), d.enabled()
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountProvisioningEventController.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.admin;

import java.util.Optional;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountProvisioningEventResponse;
import brito.com.multitenancy001.controlplane.accounts.app.query.AccountProvisioningEventQueryService;
import brito.com.multitenancy001.controlplane.accounts.app.query.dto.AccountProvisioningEventData;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/controlplane/accounts/{accountId}/provisioning-events")
@RequiredArgsConstructor
public class ControlPlaneAccountProvisioningEventController {

    private final AccountProvisioningEventQueryService queryService;

    private static AccountProvisioningEventResponse toHttp(AccountProvisioningEventData d) {
        return new AccountProvisioningEventResponse(
                d.id(),
                d.accountId(),
                d.status(),
                d.failureCode(),
                d.message(),
                d.detailsJson(),
                d.createdAt()
        );
    }

    @GetMapping
    public ResponseEntity<Page<AccountProvisioningEventResponse>> list(@PathVariable Long accountId, Pageable pageable) {
        return ResponseEntity.ok(queryService.listByAccount(accountId, pageable).map(ControlPlaneAccountProvisioningEventController::toHttp));
    }

    @GetMapping("/latest")
    public ResponseEntity<AccountProvisioningEventResponse> latest(
            @PathVariable Long accountId,
            @RequestParam(name = "status", required = false) ProvisioningStatus status
    ) {
        Optional<AccountProvisioningEventData> d = queryService.getLatestByAccount(accountId, status);
        return d.map(x -> ResponseEntity.ok(toHttp(x)))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountQueryController.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.admin;

import java.time.LocalDate;
import java.util.List;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountResponse;
import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.accounts.app.query.ControlPlaneAccountQueryService;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/controlplane/accounts/query")
@RequiredArgsConstructor
public class ControlPlaneAccountQueryController {

    private final ControlPlaneAccountQueryService queryService;
    private final AccountApiMapper accountApiMapper;

    @GetMapping("/{id}/enabled")
    public ResponseEntity<AccountResponse> getEnabledById(@PathVariable Long id) {
        Account a = queryService.getEnabledById(id);
        return ResponseEntity.ok(accountApiMapper.toResponse(a));
    }

    @GetMapping("/{id}")
    public ResponseEntity<AccountResponse> getAnyById(@PathVariable Long id) {
        Account a = queryService.getAnyById(id);
        return ResponseEntity.ok(accountApiMapper.toResponse(a));
    }

    @PostMapping("/count")
    public ResponseEntity<Long> countByStatuses(@RequestBody List<AccountStatus> statuses) {
        return ResponseEntity.ok(queryService.countByStatusesNotDeleted(statuses));
    }

    /**
     * Semântica: paymentDueDate é DATA CIVIL (LocalDate <-> DATE).
     * Endpoint aceita yyyy-MM-dd.
     *
     * Ex: /payment-due-before?date=2026-02-10
     */
    @GetMapping("/payment-due-before")
    public ResponseEntity<List<AccountResponse>> findPaymentDueBefore(
            @RequestParam("date") String isoDate
    ) {
        LocalDate date = LocalDate.parse(isoDate);
        return ResponseEntity.ok(
                queryService.findPaymentDueBeforeNotDeleted(date)
                        .stream()
                        .map(accountApiMapper::toResponse)
                        .toList()
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountAdminDetailsResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountType;
import brito.com.multitenancy001.controlplane.accounts.domain.SubscriptionPlan;
import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneAdminUserSummaryResponse;

import java.time.Instant;

import java.time.LocalDate;
public record AccountAdminDetailsResponse(

        // Identificação
        Long id,
        String displayName,
        String slug,
        String schemaName,
        AccountStatus status,
        AccountType accountType,
        SubscriptionPlan subscriptionPlan,

        // Dados legais (sempre em conjunto)
        TaxIdType taxIdType,
        String taxIdNumber,

        // Datas
        Instant createdAt,
        Instant trialEndDate,
        LocalDate paymentDueDate,
        Instant deletedAt,

        // Flags calculadas
        boolean inTrial,
        boolean trialExpired,
        long trialDaysRemaining,

        // Admin da conta
        ControlPlaneAdminUserSummaryResponse admin,

        // Indicadores
        long totalControlPlaneUsers,
        boolean operational
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountProvisioningEventResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import java.time.Instant;

import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;

public record AccountProvisioningEventResponse(
        Long id,
        Long accountId,
        ProvisioningStatus status,
        ProvisioningFailureCode failureCode,
        String message,
        String detailsJson,
        Instant createdAt
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import java.time.Instant;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountType;
import brito.com.multitenancy001.controlplane.accounts.domain.SubscriptionPlan;

public record AccountResponse(
        Long id,
        String displayName,
        String slug,
        String schemaName,
        AccountStatus status,
        AccountType accountType,
        SubscriptionPlan subscriptionPlan,
        Instant createdAt,
        Instant trialEndDate
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountStatusChangeRequest.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public record AccountStatusChangeRequest(
        @NotNull(message = "status é obrigatório")
        AccountStatus status,

        @Size(max = 255, message = "reason deve ter no máximo 255 caracteres")
        String reason
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountStatusChangeResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import java.time.Instant;

public record AccountStatusChangeResponse(
        Long id,
        String status,
        String previousStatus,
        Instant effectiveAt,
        String schemaName,
        SideEffects sideEffects
) {
    public record SideEffects(
            boolean tenantUsersUpdated,
            String action,     // "SUSPEND_BY_ACCOUNT" | "UNSUSPEND_BY_ACCOUNT" | "CANCELLED" | "NONE"
            int tenantUsersCount
    ) {}
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/summary/AccountTenantUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto.summary;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Resumo de usuário de uma conta (visão ControlPlane).
 *
 * Role é tipada usando TenantRoleName (contrato compartilhado),
 * sem dependência do enum interno do Tenant.
 */
public record AccountTenantUserSummaryResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRoleName role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountAdminDetailsApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.mapper;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.users.api.mapper.ControlPlaneUserApiMapper;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.time.AppClock;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;

@Component
public class AccountAdminDetailsApiMapper {

    private final AppClock appClock;
    private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;

    public AccountAdminDetailsApiMapper(AppClock appClock, ControlPlaneUserApiMapper controlPlaneUserApiMapper) {
        this.appClock = appClock;
        this.controlPlaneUserApiMapper = controlPlaneUserApiMapper;
    }

    public AccountAdminDetailsResponse toResponse(Account account, ControlPlaneUser admin, long totalUsers) {
        Instant now = appClock.instant();

        // Trial é instante real (Instant). Para "dias restantes", convertemos para data civil em UTC explicitamente.
        LocalDate todayUtc = LocalDate.ofInstant(now, ZoneOffset.UTC);

        Instant trialEndAt = account.getTrialEndAt();
        LocalDate trialEndDateUtc = trialEndAt != null ? LocalDate.ofInstant(trialEndAt, ZoneOffset.UTC) : null;

        boolean inTrial = trialEndAt != null && now.isBefore(trialEndAt);
        boolean trialExpired = trialEndAt != null && now.isAfter(trialEndAt);

        long trialDaysRemaining = 0;
        if (inTrial && trialEndDateUtc != null) {
            trialDaysRemaining = ChronoUnit.DAYS.between(todayUtc, trialEndDateUtc);
            if (trialDaysRemaining < 0) trialDaysRemaining = 0;
        }

        return new AccountAdminDetailsResponse(
                // Identificação
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getSchemaName(),
                account.getStatus(),
                account.getType(),
                account.getSubscriptionPlan(),

                // Dados legais
                account.getTaxIdType(),
                account.getTaxIdNumber(),

                // Datas (semântica correta)
                account.getAudit() != null ? account.getAudit().getCreatedAt() : null,
                account.getTrialEndAt(),
                account.getPaymentDueDate(),
                account.getAudit() != null ? account.getAudit().getDeletedAt() : null,

                // Flags calculadas
                inTrial,
                trialExpired,
                trialDaysRemaining,

                // Admin
                admin != null ? controlPlaneUserApiMapper.toAdminSummary(admin) : null,

                // Indicadores
                totalUsers,
                account.isOperational() // aqui não precisa de "now" porque seu domínio já tem isOperational()
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.mapper;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountResponse;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import org.springframework.stereotype.Component;

@Component
public class AccountApiMapper {

    public AccountResponse toResponse(Account account) {
        return new AccountResponse(
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getSchemaName(),
                account.getStatus(),            // enum direto
                account.getType(),              // enum direto
                account.getSubscriptionPlan(),  // enum direto

                // ✅ Auditoria única: AuditInfo (Instant)
                account.getAudit() != null ? account.getAudit().getCreatedAt() : null,

                // ✅ Trial como instante real (Instant)
                account.getTrialEndAt()
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountUserApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.accounts.api.dto.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;

@Component
public class AccountUserApiMapper {

    public AccountTenantUserSummaryResponse toAccountUserSummary(UserSummaryData user) {

        boolean enabled =
                !user.deleted()
                && !user.suspendedByAccount()
                && !user.suspendedByAdmin();

        return new AccountTenantUserSummaryResponse(
                user.id(),
                user.accountId(),
                user.name(),
                user.email(),
                user.role(),
                user.suspendedByAccount(),
                user.suspendedByAdmin(),
                enabled
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountEntitlementsProvisioningService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountEntitlements;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountEntitlementsRepository;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsProvisioningService {

    private final AccountEntitlementsRepository accountEntitlementsRepository;

    /**
     * Garante entitlements default para TENANT (idempotente / race-safe).
     * - BUILT_IN => não persiste entitlements (ilimitado)
     * - TENANT   => INSERT ... ON CONFLICT DO NOTHING + SELECT
     *
     * IMPORTANTE:
     * Este método deve rodar dentro de uma TX write-capable (via PublicUnitOfWork.tx()).
     */
    public AccountEntitlements ensureDefaultEntitlementsForTenant(Account account) {
        if (account == null || account.getId() == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "Conta é obrigatória", 400);
        }

        if (account.isBuiltInAccount()) {
            // BUILT_IN/PLATFORM => ilimitado / não precisa persistir
            return null;
        }

        int inserted = accountEntitlementsRepository.insertDefaultIfMissing(
                account.getId(),
                5,
                100,
                100
        );

        return accountEntitlementsRepository.findByAccount_Id(account.getId())
                .orElseThrow(() -> new ApiException(
                        "ENTITLEMENTS_NOT_FOUND",
                        "Entitlements não encontrados para a conta " + account.getId()
                                + " (inserted=" + inserted + ")",
                        500
                ));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountFactory.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import java.text.Normalizer;
import java.util.Locale;
import java.util.UUID;

import brito.com.multitenancy001.controlplane.accounts.app.command.CreateAccountCommand;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;

public final class AccountFactory {

    private AccountFactory() {}

    public static Account newTenantAccount(CreateAccountCommand cmd) {
        Account a = new Account();

        a.setDisplayName(cmd.displayName());
        a.setLoginEmail(cmd.loginEmail());
        a.setTaxCountryCode(cmd.taxCountryCode());
        a.setTaxIdType(cmd.taxIdType());
        a.setTaxIdNumber(cmd.taxIdNumber());

        String baseSlug = slugify(cmd.displayName());
        a.setSlug(baseSlug + "-" + shortId());

        String schemaBase = "t_" + slugify(cmd.displayName()).replace("-", "_");
        a.setSchemaName(schemaBase + "_" + shortId());

        a.setStatus(AccountStatus.PROVISIONING);

        return a;
    }

    private static String shortId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 6);
    }

    private static String slugify(String input) {
        if (input == null || input.isBlank()) return "tenant";
        String n = Normalizer.normalize(input, Normalizer.Form.NFD)
                .replaceAll("\\p{InCombiningDiacriticalMarks}+", "");
        String s = n.toLowerCase(Locale.ROOT)
                .replaceAll("[^a-z0-9\\s-]", "")
                .trim()
                .replaceAll("\\s+", "-")
                .replaceAll("-{2,}", "-");
        return s.isBlank() ? "tenant" : s;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountLifecycleService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.app.command.AccountStatusChangeCommand;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountAdminDetailsProjection;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountStatusChangeResult;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountTenantUserSummaryData;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.signup.app.AccountOnboardingService;
import brito.com.multitenancy001.controlplane.signup.app.command.SignupCommand;
import brito.com.multitenancy001.controlplane.signup.app.dto.SignupResult;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountLifecycleService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final AccountRepository accountRepository;
    private final AccountOnboardingService accountOnboardingService;
    private final AccountStatusService accountStatusService;
    private final AccountTenantUserService accountTenantUserService;
    private final PublicUnitOfWork publicUnitOfWork;
    private final AppClock appClock;

    // 1) ONBOARDING / SIGNUP
    public SignupResult createAccount(SignupCommand signupCommand) {
        return accountOnboardingService.createAccount(signupCommand);
    }

    // 2) CONSULTAS
    public List<Account> listAccounts() {
        return publicUnitOfWork.readOnly(accountRepository::findAllByDeletedFalse);
    }

    public Account getAccount(Long accountId) {
        return publicUnitOfWork.readOnly(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );
    }

    public AccountAdminDetailsProjection getAccountAdminDetails(Long accountId) {
        return publicUnitOfWork.readOnly(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            long totalUsers = controlPlaneUserRepository.countByAccount_IdAndDeletedFalse(accountId);

            ControlPlaneUser admin = controlPlaneUserRepository.findFirstAdminByAccountId(accountId).orElse(null);

            return new AccountAdminDetailsProjection(account, admin, totalUsers);
        });
    }

    // 3) STATUS / SOFT DELETE / RESTORE
    public AccountStatusChangeResult changeAccountStatus(Long accountId, AccountStatusChangeCommand cmd) {
        return accountStatusService.changeAccountStatus(accountId, cmd);
    }

    public void softDeleteAccount(Long accountId) { accountStatusService.softDeleteAccount(accountId); }

    public void restoreAccount(Long accountId) { accountStatusService.restoreAccount(accountId); }

    public List<AccountTenantUserSummaryData> listTenantUsers(Long accountId, boolean onlyOperational) {
        return accountTenantUserService.listTenantUsers(accountId, onlyOperational);
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        accountTenantUserService.setUserSuspendedByAdmin(accountId, userId, suspended);
    }

    // 4) CONSULTAS ADMIN (paginação)
    private static final int DEFAULT_PAGE_SIZE = 20;
    private static final int MAX_PAGE_SIZE = 100;
    private static final long MAX_CREATED_BETWEEN_DAYS = 90;

    private Pageable normalizePageable(Pageable pageable) {
        if (pageable == null) return PageRequest.of(0, DEFAULT_PAGE_SIZE);
        int size = pageable.getPageSize();
        if (size <= 0) size = DEFAULT_PAGE_SIZE;
        if (size > MAX_PAGE_SIZE) size = MAX_PAGE_SIZE;
        return PageRequest.of(pageable.getPageNumber(), size, pageable.getSort());
    }

    private void assertValidCreatedBetweenRange(Instant start, Instant end) {
        if (start == null || end == null) throw new ApiException("INVALID_RANGE", "start/end são obrigatórios", 400);
        if (end.isBefore(start)) throw new ApiException("INVALID_RANGE", "end deve ser >= start", 400);
        Duration d = Duration.between(start, end);
        if (d.toDays() > MAX_CREATED_BETWEEN_DAYS) {
            throw new ApiException("RANGE_TOO_LARGE", "Intervalo máximo é " + MAX_CREATED_BETWEEN_DAYS + " dias", 400);
        }
    }

    public Account findBySlug(String slug) {
        if (slug == null || slug.isBlank()) throw new ApiException("INVALID_SLUG", "slug é obrigatório", 400);
        return publicUnitOfWork.readOnly(() ->
                accountRepository.findBySlugAndDeletedFalseIgnoreCase(slug.trim())
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );
    }

    public Page<Account> listAccountsByStatus(AccountStatus status, Pageable pageable) {
        if (status == null) throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
        Pageable p = normalizePageable(pageable);
        return publicUnitOfWork.readOnly(() -> accountRepository.findByStatusAndDeletedFalse(status, p));
    }

    public Page<Account> listAccountsCreatedBetween(Instant start, Instant end, Pageable pageable) {
        assertValidCreatedBetweenRange(start, end);
        Pageable p = normalizePageable(pageable);
        return publicUnitOfWork.readOnly(() -> accountRepository.findAccountsCreatedBetween(start, end, p));
    }

    public Page<Account> searchAccountsByDisplayName(String term, Pageable pageable) {
        if (term == null || term.isBlank()) throw new ApiException("INVALID_SEARCH", "term é obrigatório", 400);
        Pageable p = normalizePageable(pageable);
        return publicUnitOfWork.readOnly(() -> accountRepository.searchByDisplayName(term, p));
    }

    /**
     * Overdue é DATA CIVIL (paymentDueDate é LocalDate/DATE).
     * Mantemos compatibilidade aceitando Instant e convertendo explicitamente para LocalDate em UTC
     * (sem timezone implícito do servidor).
     */
    public List<Account> listOverdueAccounts(Instant today, AccountStatus status) {
        Instant baseInstant = (today != null ? today : appClock.instant());
        LocalDate baseDateUtc = LocalDate.ofInstant(baseInstant, ZoneOffset.UTC);

        AccountStatus st = (status != null ? status : AccountStatus.ACTIVE);

        return publicUnitOfWork.readOnly(() ->
                accountRepository.findOverdueAccountsNotDeleted(st, baseDateUtc)
        );
    }

    public long countOperationalAccounts() {
        return publicUnitOfWork.readOnly(accountRepository::countOperationalAccounts);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountStatusService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.app.command.AccountStatusChangeCommand;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountStatusChangeResult;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserProvisioningFacade;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountStatusService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final AccountRepository accountRepository;
    private final TenantUserProvisioningFacade tenantUserProvisioningFacade;
    private final AppClock appClock;

    public AccountStatusChangeResult changeAccountStatus(Long accountId, AccountStatusChangeCommand cmd) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);
        if (cmd == null || cmd.status() == null) throw new ApiException("STATUS_REQUIRED", "status é obrigatório", 400);

        return publicUnitOfWork.tx(() -> {

            Account account = getAccountByIdRaw(accountId);
            AccountStatus previous = account.getStatus();

            AccountStatus newStatus = cmd.status();
            account.setStatus(newStatus);

            // Se reativou, garante que não está deletado
            if (newStatus == AccountStatus.ACTIVE && account.isDeleted()) {
                account.restore();
            }

            accountRepository.save(account);

            int affected = 0;
            boolean applied = false;
            AccountStatusSideEffect action = AccountStatusSideEffect.NONE;

            if (newStatus == AccountStatus.SUSPENDED) {
                affected = tenantUserProvisioningFacade.suspendAllUsersByAccount(account.getSchemaName(), account.getId());
                applied = true;
                action = AccountStatusSideEffect.SUSPEND_BY_ACCOUNT;
            } else if (newStatus == AccountStatus.ACTIVE) {
                affected = tenantUserProvisioningFacade.unsuspendAllUsersByAccount(account.getSchemaName(), account.getId());
                applied = true;
                action = AccountStatusSideEffect.UNSUSPEND_BY_ACCOUNT;
            } else if (newStatus == AccountStatus.CANCELLED) {
                affected = cancelAccount(account);
                applied = true;
                action = AccountStatusSideEffect.CANCELLED;
            }

            return new AccountStatusChangeResult(
                    account.getId(),
                    account.getStatus().name(),
                    previous == null ? null : previous.name(),
                    appClock.instant(),
                    account.getSchemaName(),
                    applied,
                    action.name(),
                    affected
            );
        });
    }

    public void softDeleteAccount(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);

        publicUnitOfWork.tx(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isBuiltInAccount()) {
                throw new ApiException("BUILTIN_ACCOUNT_PROTECTED", "Não é permitido excluir contas do sistema", 403);
            }

            account.softDelete(appClock.instant());
            accountRepository.save(account);

            tenantUserProvisioningFacade.softDeleteAllUsersByAccount(account.getSchemaName(), account.getId());
        });
    }

    public void restoreAccount(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);

        publicUnitOfWork.tx(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isBuiltInAccount() && account.isDeleted()) {
                throw new ApiException("BUILTIN_ACCOUNT_PROTECTED", "Contas do sistema não podem ser restauradas via este endpoint", 403);
            }

            account.restore();
            accountRepository.save(account);

            tenantUserProvisioningFacade.restoreAllUsersByAccount(account.getSchemaName(), account.getId());
        });
    }

    private int cancelAccount(Account account) {
        publicUnitOfWork.requiresNew(() -> {
            if (!account.isDeleted()) {
                account.softDelete(appClock.instant());
            }
            account.setStatus(AccountStatus.CANCELLED);
            accountRepository.save(account);
        });

        return tenantUserProvisioningFacade.softDeleteAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    private Account getAccountByIdRaw(Long accountId) {
        return accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
    }

    private enum AccountStatusSideEffect {
        NONE,
        SUSPEND_BY_ACCOUNT,
        UNSUSPEND_BY_ACCOUNT,
        CANCELLED
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountTenantUserService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountTenantUserSummaryData;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserProvisioningFacade;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountTenantUserService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final AccountRepository accountRepository;
    private final TenantUserProvisioningFacade tenantUserProvisioningFacade;

    public List<AccountTenantUserSummaryData> listTenantUsers(Long accountId, boolean onlyOperational) {

        Account account = publicUnitOfWork.readOnly(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );

        List<UserSummaryData> data = tenantUserProvisioningFacade
                .listUserSummaries(account.getSchemaName(), account.getId(), onlyOperational);

        return data.stream()
                .map(AccountTenantUserService::toSummary)
                .toList();
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {

        Account account = publicUnitOfWork.readOnly(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );

        tenantUserProvisioningFacade.setSuspendedByAdmin(account.getSchemaName(), account.getId(), userId, suspended);
    }

    private static AccountTenantUserSummaryData toSummary(UserSummaryData user) {
        boolean enabled =
                !user.deleted()
                && !user.suspendedByAccount()
                && !user.suspendedByAdmin();

        return new AccountTenantUserSummaryData(
                user.id(),
                user.accountId(),
                user.name(),
                user.email(),
                user.role(),
                user.suspendedByAccount(),
                user.suspendedByAdmin(),
                enabled
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/audit/AccountProvisioningAuditService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.audit;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountProvisioningEvent;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountProvisioningEventRepository;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AccountProvisioningAuditService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final AccountProvisioningEventRepository repository;
    private final AppClock appClock;

    public void started(Long accountId, String message, String detailsJson) {
        record(accountId, ProvisioningStatus.STARTED, null, message, detailsJson);
    }

    public void success(Long accountId, String message, String detailsJson) {
        record(accountId, ProvisioningStatus.SUCCESS, null, message, detailsJson);
    }

    public void failed(Long accountId, ProvisioningFailureCode failureCode, String message, String detailsJson) {
        record(accountId, ProvisioningStatus.FAILED, failureCode, message, detailsJson);
    }

    private void record(
            Long accountId,
            ProvisioningStatus status,
            ProvisioningFailureCode failureCode,
            String message,
            String detailsJson
    ) {
        // ✅ write-capable TX no public schema
        publicUnitOfWork.tx(() -> {
            AccountProvisioningEvent e = new AccountProvisioningEvent(
                    accountId,
                    status,
                    failureCode,
                    message,
                    detailsJson,
                    appClock.instant()
            );
            repository.save(e);
        });
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/command/AccountStatusChangeCommand.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.command;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;

public record AccountStatusChangeCommand(
        AccountStatus status
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/command/CreateAccountCommand.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.command;

import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;

public record CreateAccountCommand(
        String displayName,
        String loginEmail,
        String taxCountryCode,
        TaxIdType taxIdType,
        String taxIdNumber
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountAdminDetailsProjection.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;

public record AccountAdminDetailsProjection(
        Account account,
        ControlPlaneUser admin,
        long totalUsers
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountStatusChangeResult.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.dto;

import java.time.Instant;

public record AccountStatusChangeResult(
        Long accountId,
        String newStatus,
        String previousStatus,
        Instant changedAt,
        String tenantSchema,
        boolean tenantUsersUpdated,
        String action,
        int affectedUsers
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountTenantUserSummaryData.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.dto;

import brito.com.multitenancy001.shared.security.TenantRoleName;

public record AccountTenantUserSummaryData(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRoleName role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/AccountProvisioningEventQueryService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.query;

import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.accounts.app.query.dto.AccountProvisioningEventData;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountProvisioningEvent;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountProvisioningEventRepository;

@Service
public class AccountProvisioningEventQueryService {

    private final AccountProvisioningEventRepository repository;

    public AccountProvisioningEventQueryService(AccountProvisioningEventRepository repository) {
        this.repository = repository;
    }

    @Transactional(readOnly = true)
    public Page<AccountProvisioningEventData> listByAccount(Long accountId, Pageable pageable) {
        return repository.findByAccountId(accountId, pageable)
                .map(this::toData);
    }

    @Transactional(readOnly = true)
    public Optional<AccountProvisioningEventData> getLatestByAccount(
            Long accountId,
            ProvisioningStatus requireStatus
    ) {
        Optional<AccountProvisioningEvent> event;

        if (requireStatus == null) {
            event = repository.findTopByAccountIdOrderByCreatedAtDesc(accountId);
        } else {
            event = repository.findTopByAccountIdAndStatusOrderByCreatedAtDesc(accountId, requireStatus);
        }

        return event.map(this::toData);
    }

    private AccountProvisioningEventData toData(AccountProvisioningEvent e) {
        return new AccountProvisioningEventData(
                e.getId(),
                e.getAccountId(),
                e.getStatus(),
                parseFailureCodeOrNull(e.getFailureCode()),
                e.getMessage(),
                e.getDetailsJson(),
                e.getCreatedAt()
        );
    }

    private ProvisioningFailureCode parseFailureCodeOrNull(String raw) {
        if (raw == null || raw.isBlank()) return null;
        try {
            return ProvisioningFailureCode.valueOf(raw);
        } catch (IllegalArgumentException ex) {
            return null;
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/ControlPlaneAccountQueryService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.query;

import java.time.LocalDate;
import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlaneAccountQueryService {

    private final AccountRepository accountRepository;

    @Transactional(readOnly = true)
    public Account getEnabledById(Long id) {
        if (id == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "id é obrigatório", 400);

        return accountRepository.findEnabledById(id)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_ENABLED", "Conta não encontrada ou não operacional", 404));
    }

    @Transactional(readOnly = true)
    public Account getAnyById(Long id) {
        if (id == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "id é obrigatório", 400);

        return accountRepository.findAnyById(id)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
    }

    @Transactional(readOnly = true)
    public long countByStatusesNotDeleted(List<AccountStatus> statuses) {
        if (statuses == null || statuses.isEmpty()) {
            throw new ApiException("ACCOUNT_STATUSES_REQUIRED", "statuses é obrigatório", 400);
        }
        return accountRepository.countByStatusesAndDeletedFalse(statuses);
    }

    @Transactional(readOnly = true)
    public List<Account> findPaymentDueBeforeNotDeleted(LocalDate date) {
        if (date == null) throw new ApiException("DATE_REQUIRED", "date é obrigatório", 400);

        return accountRepository.findByPaymentDueDateBeforeAndDeletedFalse(date);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/dto/AccountProvisioningEventData.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.query.dto;

import java.time.Instant;

import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;

public record AccountProvisioningEventData(
        Long id,
        Long accountId,
        ProvisioningStatus status,
        ProvisioningFailureCode failureCode,
        String message,
        String detailsJson,
        Instant createdAt
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/Account.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.domain.DomainException;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "accounts")
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Account implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_type", nullable = false, length = 20)
    @Builder.Default
    private AccountType type = AccountType.TENANT;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_origin", nullable = false, length = 20)
    @Builder.Default
    private EntityOrigin origin = EntityOrigin.ADMIN;

    @Column(name = "display_name", nullable = false, length = 150)
    private String displayName;

    @Column(name = "legal_name", length = 200)
    private String legalName;

    @Enumerated(EnumType.STRING)
    @Column(name = "legal_entity_type", nullable = false, length = 20)
    @Builder.Default
    private LegalEntityType legalEntityType = LegalEntityType.COMPANY;

    @Column(name = "schema_name", nullable = false, unique = true, length = 100)
    private String schemaName;

    @Column(name = "slug", nullable = false, unique = true, length = 80)
    private String slug;

    // ✅ Alinhado com migration: VARCHAR(2) NOT NULL DEFAULT 'BR'
    @Column(name = "tax_country_code", nullable = false, length = 2)
    @Builder.Default
    private String taxCountryCode = "BR";

    @Enumerated(EnumType.STRING)
    @Column(name = "tax_id_type", length = 20)
    private TaxIdType taxIdType;

    // ✅ Alinhado com migration: VARCHAR(40)
    @Column(name = "tax_id_number", length = 40)
    private String taxIdNumber;

    // ✅ Alinhado com migration: CITEXT NOT NULL
    @Column(name = "login_email", nullable = false, columnDefinition = "citext")
    private String loginEmail;

    // ✅ Alinhado com migration: VARCHAR(50)
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    @Builder.Default
    private AccountStatus status = AccountStatus.PROVISIONING;

    // ✅ Alinhado com migration: VARCHAR(50)
    @Enumerated(EnumType.STRING)
    @Column(name = "subscription_plan", nullable = false, length = 50)
    @Builder.Default
    private SubscriptionPlan subscriptionPlan = SubscriptionPlan.FREE;

    /**
     * Instante real (ex.: fim do trial como momento absoluto).
     * Instant <-> TIMESTAMPTZ
     */
    @Column(name = "trial_end_date", columnDefinition = "timestamptz")
    private Instant trialEndAt;

    /**
     * Data civil (vencimento no dia X, sem horário).
     * LocalDate <-> DATE
     */
    @Column(name = "payment_due_date", columnDefinition = "date")
    private LocalDate paymentDueDate;

    /**
     * Data civil (próxima cobrança no dia X).
     * LocalDate <-> DATE
     */
    @Column(name = "next_billing_date", columnDefinition = "date")
    private LocalDate nextBillingDate;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @OneToMany(mappedBy = "account", fetch = FetchType.LAZY)
    @Builder.Default
    private List<ControlPlaneUser> controlPlaneUsers = new ArrayList<>();

    // =========================
    // Auditable / SoftDeletable
    // =========================

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // =========================
    // Semântica de sistema
    // =========================

    public boolean isBuiltInAccount() {
        return origin == EntityOrigin.BUILT_IN || type == AccountType.PLATFORM;
    }

    // =========================
    // Soft delete / Restore
    // =========================

    public void softDelete(Instant now) {
        if (now == null) throw new DomainException("now é obrigatório");
        if (this.deleted) return;

        this.deleted = true;
        if (this.audit != null) {
            this.audit.setDeletedAt(now);
        }
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        if (this.audit != null) {
            this.audit.setDeletedAt(null);
        }
    }

    public void setDeletedAt(Instant deletedAt) {
        if (this.audit != null) {
            this.audit.setDeletedAt(deletedAt);
        }
        this.deleted = deletedAt != null;
    }

    // =========================
    // Regras de domínio
    // =========================

    public boolean isOperational() {
        return !deleted && status != null && status.isOperational();
    }

    public void requireOperational() {
        if (!isOperational()) {
            throw new DomainException("Conta não está operacional");
        }
    }

    public void setDisplayNameSafe(String value) {
        if (value == null || value.isBlank()) throw new DomainException("displayName é obrigatório");
        this.displayName = value.trim();
    }

    public void setSlugSafe(String value) {
        if (value == null || value.isBlank()) throw new DomainException("slug é obrigatório");
        this.slug = normalizeSlug(value);
    }

    public void ensureSchemaName() {
        if (this.schemaName == null || this.schemaName.isBlank()) {
            this.schemaName = generateSchemaNameFromSlug(this.slug);
        }
    }

    public void startFreeTrial(Instant now, int days) {
        if (now == null) throw new DomainException("now é obrigatório");
        if (days <= 0) throw new DomainException("days inválido");

        this.status = AccountStatus.FREE_TRIAL;
        this.subscriptionPlan = SubscriptionPlan.FREE;
        this.trialEndAt = now.plus(days, ChronoUnit.DAYS);
    }

    public void activatePaidPlan(SubscriptionPlan plan, LocalDate paymentDueDate, LocalDate nextBillingDate) {
        if (plan == null) throw new DomainException("plan é obrigatório");
        if (plan == SubscriptionPlan.FREE) throw new DomainException("plan inválido");
        if (paymentDueDate == null) throw new DomainException("paymentDueDate é obrigatório");
        if (nextBillingDate == null) throw new DomainException("nextBillingDate é obrigatório");

        this.status = AccountStatus.ACTIVE;
        this.subscriptionPlan = plan;
        this.paymentDueDate = paymentDueDate;
        this.nextBillingDate = nextBillingDate;
    }

    private static String normalizeSlug(String raw) {
        String v = raw.trim().toLowerCase();
        v = v.replaceAll("[^a-z0-9\\-]", "-");
        v = v.replaceAll("-{2,}", "-");
        v = v.replaceAll("(^-|-$)", "");
        if (v.length() < 3) throw new DomainException("slug muito curto");
        return v;
    }

    private static String generateSchemaNameFromSlug(String slug) {
        String base = (slug == null ? "tenant" : slug.replace("-", "_"));
        base = base.replaceAll("[^a-z0-9_]", "");
        if (base.length() > 40) base = base.substring(0, 40);
        return "t_" + base + "_" + UUID.randomUUID().toString().replace("-", "").substring(0, 8);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountEntitlements.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "account_entitlements")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AccountEntitlements {

    @Id
    @Column(name = "account_id")
    private Long accountId;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id")
    private Account account;

    @Column(name = "max_users", nullable = false)
    private Integer maxUsers;

    @Column(name = "max_products", nullable = false)
    private Integer maxProducts;

    @Column(name = "max_storage_mb", nullable = false)
    private Integer maxStorageMb;
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountProvisioningEvent.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

import java.time.Instant;

import jakarta.persistence.*;

@Entity
@Table(name = "account_provisioning_events", schema = "public")
public class AccountProvisioningEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Enumerated(EnumType.STRING)
    @Column(name = "event_type", nullable = false, length = 50)
    private ProvisioningStatus status;

    @Column(name = "failure_code", length = 50)
    private String failureCode;

    @Column(name = "message", columnDefinition = "text")
    private String message;

    @Column(name = "details_json", columnDefinition = "text")
    private String detailsJson;

    @Column(name = "created_at", nullable = false, columnDefinition = "timestamptz")
    private Instant createdAt;

    protected AccountProvisioningEvent() { }

    public AccountProvisioningEvent(
            Long accountId,
            ProvisioningStatus status,
            ProvisioningFailureCode failureCode,
            String message,
            String detailsJson,
            Instant createdAt
    ) {
        this.accountId = accountId;
        this.status = status;
        this.failureCode = (failureCode == null ? null : failureCode.name());
        this.message = message;
        this.detailsJson = detailsJson;
        this.createdAt = createdAt;
    }

    public Long getId() { return id; }
    public Long getAccountId() { return accountId; }
    public ProvisioningStatus getStatus() { return status; }
    public String getFailureCode() { return failureCode; }
    public String getMessage() { return message; }
    public String getDetailsJson() { return detailsJson; }
    public Instant getCreatedAt() { return createdAt; }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountStatus.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum AccountStatus {
    FREE_TRIAL("Trial Gratuito"),
    ACTIVE("Ativa"),
    SUSPENDED("Suspensa"),
    CANCELLED("Cancelada"),
    EXPIRED("Expirada"),
	PROVISIONING("Provisionamento");

    private final String description;

    AccountStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    /** Regra de negócio: permite operar (independente de datas finas do trial). */
    public boolean isOperational() {
        return this == FREE_TRIAL || this == ACTIVE;
    }

    public boolean isTrial() {
        return this == FREE_TRIAL;
    }

    public boolean isSuspended() {
        return this == SUSPENDED;
    }

    public boolean isCancelled() {
        return this == CANCELLED || this == EXPIRED;
    }

 
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountType.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum AccountType {
    TENANT,
    PLATFORM
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/LegalEntityType.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum LegalEntityType {
    INDIVIDUAL,   // pessoa física
    COMPANY       // pessoa jurídica
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/ProvisioningFailureCode.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum ProvisioningFailureCode {
    VALIDATION_ERROR,
    PUBLIC_PERSISTENCE_ERROR,
    SCHEMA_CREATION_ERROR,
    TENANT_MIGRATION_ERROR,
    TENANT_ADMIN_CREATION_ERROR,
    UNKNOWN
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/ProvisioningStatus.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum ProvisioningStatus {
    STARTED,
    SUCCESS,
    FAILED
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/SubscriptionPlan.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum SubscriptionPlan {
    FREE,
    PRO,
    ENTERPRISE,

    /**
     * Plano interno do sistema (Control Plane).
     * BUILTIN != cliente, não tem trial, não tem billing, não tem entitlements.
     */
    BUILT_IN_PLAN
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/TaxIdType.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

import lombok.Getter;

@Getter
public enum TaxIdType {
    CPF,
    CNPJ;

   
    }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountEntitlementsRepository.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountEntitlements;

import java.util.Optional;

public interface AccountEntitlementsRepository extends JpaRepository<AccountEntitlements, Long> {

    Optional<AccountEntitlements> findByAccount_Id(Long accountId);

    /**
     * Upsert/Idempotente no estilo do V13:
     * - insere default
     * - se já existir, não faz nada
     *
     * Retorna 1 se inseriu, 0 se já existia.
     *
     * IMPORTANTE:
     * Deve ser executado dentro de uma TX write-capable (via PublicUnitOfWork.tx()).
     */
    @Modifying
    @Query(
        value = """
            INSERT INTO public.account_entitlements (
                account_id, max_users, max_products, max_storage_mb, created_at, updated_at
            )
            VALUES (
                :accountId, :maxUsers, :maxProducts, :maxStorageMb, now(), now()
            )
            ON CONFLICT (account_id) DO NOTHING
            """,
        nativeQuery = true
    )
    int insertDefaultIfMissing(
            @Param("accountId") Long accountId,
            @Param("maxUsers") Integer maxUsers,
            @Param("maxProducts") Integer maxProducts,
            @Param("maxStorageMb") Integer maxStorageMb
    );
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountProvisioningEventRepository.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.persistence;

import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountProvisioningEvent;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;

public interface AccountProvisioningEventRepository extends JpaRepository<AccountProvisioningEvent, Long> {

    Page<AccountProvisioningEvent> findByAccountId(Long accountId, Pageable pageable);

    Optional<AccountProvisioningEvent> findTopByAccountIdOrderByCreatedAtDesc(Long accountId);

    Optional<AccountProvisioningEvent> findTopByAccountIdAndStatusOrderByCreatedAtDesc(
            Long accountId,
            ProvisioningStatus status
    );
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountRepository.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.persistence;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {

    boolean existsByTaxCountryCodeAndTaxIdTypeAndTaxIdNumberAndDeletedFalse(
            String taxCountryCode, TaxIdType taxIdType, String taxIdNumber
    );

    boolean existsByLoginEmailAndDeletedFalse(String loginEmail);

    List<Account> findAllByDeletedFalse();

    Optional<Account> findBySlugAndDeletedFalse(String slug);

    Optional<Account> findBySlugAndDeletedFalseIgnoreCase(String slug);

    Optional<AccountResolverProjection> findProjectionByIdAndDeletedFalse(Long id);

    Optional<AccountResolverProjection> findProjectionBySlugAndDeletedFalseIgnoreCase(String slug);

    Optional<Account> findByIdAndDeletedFalse(Long id);

    @Query("""
            SELECT a
              FROM Account a
             WHERE a.id = :id
               AND a.deleted = false
               AND a.status IN ('ACTIVE', 'FREE_TRIAL')
           """)
    Optional<Account> findEnabledById(@Param("id") Long id);

    Optional<Account> findAnyById(Long id);

    @Query("SELECT COUNT(a) FROM Account a WHERE a.deleted = false AND a.status IN :statuses")
    long countByStatusesAndDeletedFalse(@Param("statuses") List<AccountStatus> statuses);

    default long countOperationalAccounts() {
        return countByStatusesAndDeletedFalse(List.of(AccountStatus.ACTIVE, AccountStatus.FREE_TRIAL));
    }

    Page<Account> findByStatusAndDeletedFalse(AccountStatus status, Pageable pageable);

    @Query("""
            SELECT a
              FROM Account a
             WHERE a.deleted = false
               AND a.audit.createdAt BETWEEN :start AND :end
           """)
    Page<Account> findAccountsCreatedBetween(
            @Param("start") Instant start,
            @Param("end") Instant end,
            Pageable pageable
    );

    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND (
            LOWER(a.displayName) LIKE LOWER(CONCAT('%', :term, '%'))
            OR (a.legalName IS NOT NULL AND LOWER(a.legalName) LIKE LOWER(CONCAT('%', :term, '%')))
          )
    """)
    Page<Account> searchByDisplayName(@Param("term") String term, Pageable pageable);

    List<Account> findByStatusAndDeletedFalse(AccountStatus status);

    List<Account> findByPaymentDueDateBeforeAndDeletedFalse(LocalDate date);

    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND a.trialEndAt <= :date
          AND a.status = :status
    """)
    List<Account> findExpiredTrialsNotDeleted(@Param("date") Instant date, @Param("status") AccountStatus status);

    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND a.status = :status
          AND a.paymentDueDate < :today
    """)
    List<Account> findOverdueAccountsNotDeleted(@Param("status") AccountStatus status, @Param("today") LocalDate today);

    /**
     * ✅ Conta do CONTROL PLANE (public schema).
     * Ajuste o literal do enum se seu AccountType tiver outro nome.
     */
    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND a.type = 'CONTROLPLANE'
    """)
    Optional<Account> findControlPlaneAccount();
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountResolverProjection.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.persistence;

import java.time.Instant;

public interface AccountResolverProjection {
    Long getId();
    String getSchemaName();

    // necessários para seleção no frontend
    String getSlug();
    String getDisplayName();

    String getStatus();

    // ✅ FIX: o campo no domínio é trialEndAt (não trialEndDate)
    Instant getTrialEndAt();

    String getOrigin();
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/api/admin/ControlPlaneAuthController.java
============================================================
package brito.com.multitenancy001.controlplane.auth.api.admin;

import brito.com.multitenancy001.controlplane.auth.api.dto.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.auth.app.ControlPlaneAuthService;
import brito.com.multitenancy001.controlplane.auth.app.command.ControlPlaneAdminLoginCommand;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/controlplane/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class ControlPlaneAuthController {

    private final ControlPlaneAuthService controlPlaneAuthService;

    private static JwtResponse toHttp(JwtResult r) {
        return JwtResponse.forEmailLogin(
                r.accessToken(),
                r.refreshToken(),
                r.userId(),
                r.email(),
                r.role(),
                r.accountId(),
                r.tenantSchema()
        );
    }

    @PostMapping("/login")
    public ResponseEntity<JwtResponse> login(@Valid @RequestBody ControlPlaneAdminLoginRequest req) {
        JwtResult jwt = controlPlaneAuthService.loginControlPlaneUser(
                new ControlPlaneAdminLoginCommand(req.email(), req.password())
        );
        return ResponseEntity.ok(toHttp(jwt));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/api/dto/ControlPlaneAdminLoginRequest.java
============================================================
package brito.com.multitenancy001.controlplane.auth.api.dto;

import jakarta.validation.constraints.NotBlank;

public record ControlPlaneAdminLoginRequest(
        @NotBlank String email,
        @NotBlank String password
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/app/ControlPlaneAuthService.java
============================================================
package brito.com.multitenancy001.controlplane.auth.app;

import brito.com.multitenancy001.controlplane.auth.app.command.ControlPlaneAdminLoginCommand;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.audit.AuthEventAuditService;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.SystemRoleName;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Service
@RequiredArgsConstructor
public class ControlPlaneAuthService {

    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final PublicExecutor publicExecutor;

    // ✅ NOVO (append-only auth_events)
    private final AuthEventAuditService authEventAuditService;

    public JwtResult loginControlPlaneUser(ControlPlaneAdminLoginCommand cmd) {

        if (cmd == null) throw new ApiException("INVALID_LOGIN", "Requisição inválida", 400);
        if (!StringUtils.hasText(cmd.email())) throw new ApiException("INVALID_LOGIN", "email é obrigatório", 400);
        if (!StringUtils.hasText(cmd.password())) throw new ApiException("INVALID_LOGIN", "password é obrigatório", 400);

        final String email = cmd.email().trim();
        final String password = cmd.password();

        authEventAuditService.record("controlplane", "LOGIN_INIT", "ATTEMPT", email, null, null, DEFAULT_SCHEMA,
                "{\"stage\":\"init\"}");

        try {
            return publicExecutor.runInPublicSchema(() -> {

                ControlPlaneUser user = controlPlaneUserRepository
                        .findByEmailAndDeletedFalse(email)
                        .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));

                if (user.isSuspendedByAccount()) {
                    authEventAuditService.record("controlplane", "LOGIN_DENIED", "DENIED", email, user.getId(), user.getAccount().getId(), DEFAULT_SCHEMA,
                            "{\"reason\":\"suspended\"}");
                    throw new ApiException("ACCESS_DENIED", "Usuário não autorizado", 403);
                }

                Authentication authentication = authenticationManager.authenticate(
                        new UsernamePasswordAuthenticationToken(email, password)
                );

                Long accountId = user.getAccount().getId();

                String accessToken = jwtTokenProvider.generateControlPlaneToken(
                        authentication,
                        accountId,
                        DEFAULT_SCHEMA
                );

                String refreshToken = jwtTokenProvider.generateRefreshToken(
                        user.getEmail(),
                        DEFAULT_SCHEMA,
                        accountId
                );

                SystemRoleName role = SystemRoleName.fromString(user.getRole().name());

                authEventAuditService.record("controlplane", "LOGIN_SUCCESS", "SUCCESS", user.getEmail(), user.getId(), accountId, DEFAULT_SCHEMA,
                        "{\"mode\":\"password\"}");

                return new JwtResult(
                        accessToken,
                        refreshToken,
                        user.getId(),
                        user.getEmail(),
                        role,
                        accountId,
                        DEFAULT_SCHEMA
                );
            });
        } catch (BadCredentialsException e) {
            authEventAuditService.record("controlplane", "LOGIN_FAILURE", "FAILURE", email, null, null, DEFAULT_SCHEMA,
                    "{\"reason\":\"bad_credentials\"}");
            throw e;
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/app/command/ControlPlaneAdminLoginCommand.java
============================================================
package brito.com.multitenancy001.controlplane.auth.app.command;



public record ControlPlaneAdminLoginCommand(
        String email,
        String password
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/api/admin/ControlPlanePaymentController.java
============================================================
package brito.com.multitenancy001.controlplane.billing.api.admin;

import brito.com.multitenancy001.controlplane.billing.app.ControlPlanePaymentService;
import brito.com.multitenancy001.shared.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import jakarta.validation.Valid;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@RestController
@RequestMapping("/api/admin/billing/payments")
@RequiredArgsConstructor
@Validated
public class ControlPlanePaymentController {

    private final ControlPlanePaymentService controlPlanePaymentService;

    // Cria/processa um pagamento manual para uma conta (cross-tenant) e aplica efeitos no billing da conta.
    @PostMapping("/by-account/{accountId}")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.name())"
                    + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_WRITE.name())"
    )
    public ResponseEntity<PaymentResponse> processPaymentForAccount(
            @PathVariable Long accountId,
            @Valid @RequestBody AdminPaymentRequest body
    ) {
        AdminPaymentRequest adminPaymentRequest = new AdminPaymentRequest(
                accountId,
                body.amount(),
                body.paymentMethod(),
                body.paymentGateway(),
                body.description()
        );

        PaymentResponse response = controlPlanePaymentService.processPaymentForAccount(adminPaymentRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    // Lista pagamentos de uma conta (cross-tenant).
    @GetMapping("/by-account/{accountId}")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.name())"
                    + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())"
    )
    public ResponseEntity<List<PaymentResponse>> getPaymentsByAccountAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByAccount(accountId));
    }

    // Informa se existe um pagamento COMPLETED vigente para a conta (cross-tenant).
    @GetMapping("/by-account/{accountId}/active")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.name())"
                    + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())"
    )
    public ResponseEntity<Boolean> hasCurrentPaymentAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentService.hasActivePayment(accountId));
    }

    // Verifica se um paymentId pertence a um accountId (cross-tenant).
    @GetMapping("/by-account/{accountId}/exists/{paymentId}")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.name())"
                    + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())"
    )
    public ResponseEntity<Boolean> existsByIdAndAccountId(
            @PathVariable Long accountId,
            @PathVariable Long paymentId
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.paymentExistsForAccount(paymentId, accountId));
    }

    // Lista pagamentos de uma conta filtrados por status (cross-tenant).
    @GetMapping("/by-account/{accountId}/status/{status}")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.name())"
                    + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())"
    )
    public ResponseEntity<List<PaymentResponse>> getPaymentsByAccountAndStatus(
            @PathVariable Long accountId,
            @PathVariable PaymentStatus status
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByAccountAndStatus(accountId, status));
    }

    // Busca pagamento por transactionId (admin global).
    @GetMapping("/by-transaction/{transactionId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())")
    public ResponseEntity<PaymentResponse> getByTransactionId(@PathVariable String transactionId) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentByTransactionId(transactionId));
    }

    // Informa se existe pagamento com transactionId (admin global).
    @GetMapping("/exists/by-transaction/{transactionId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())")
    public ResponseEntity<Boolean> existsByTransactionId(@PathVariable String transactionId) {
        return ResponseEntity.ok(controlPlanePaymentService.existsByTransactionId(transactionId));
    }

    // Lista pagamentos por status cujo validUntil é anterior a uma data (admin global).
    @GetMapping("/valid-until-before")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())")
    public ResponseEntity<List<PaymentResponse>> listByValidUntilBeforeAndStatus(
            @RequestParam("date")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant date,
            @RequestParam("status") PaymentStatus status
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByValidUntilBeforeAndStatus(date, status));
    }

    // Lista pagamentos COMPLETED de uma conta, ordenados por data de pagamento (cross-tenant).
    @GetMapping("/by-account/{accountId}/completed")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.name())"
                    + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())"
    )
    public ResponseEntity<List<PaymentResponse>> getCompletedPaymentsByAccount(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentService.getCompletedPaymentsByAccount(accountId));
    }

    // Lista pagamentos dentro de um período (admin global).
    @GetMapping("/period")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())")
    public ResponseEntity<List<PaymentResponse>> listPaymentsInPeriod(
            @RequestParam("start")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant startDate,
            @RequestParam("end")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant endDate
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsInPeriod(startDate, endDate));
    }

    // Soma a receita (pagamentos COMPLETED) no período informado (admin global).
    @GetMapping("/revenue")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())")
    public ResponseEntity<BigDecimal> getRevenue(
            @RequestParam("start")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant startDate,
            @RequestParam("end")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant endDate
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getTotalRevenue(startDate, endDate));
    }

    // Marca um pagamento PENDING como COMPLETED manualmente (admin global) e aplica efeitos na conta.
    @PostMapping("/{paymentId}/complete-manual")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_WRITE.name())")
    public ResponseEntity<PaymentResponse> completeManually(@PathVariable Long paymentId) {
        return ResponseEntity.ok(controlPlanePaymentService.completePaymentManually(paymentId));
    }

    // Reembolsa um pagamento elegível (total ou parcial) registrando o motivo (admin global).
    @PostMapping("/{paymentId}/refund")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_WRITE.name())")
    public ResponseEntity<PaymentResponse> refund(
            @PathVariable Long paymentId,
            @Valid @RequestBody RefundRequest refundRequest
    ) {
        PaymentResponse response =
                controlPlanePaymentService.refundPayment(paymentId, refundRequest.amount(), refundRequest.reason());
        return ResponseEntity.ok(response);
    }

    public record RefundRequest(
            @DecimalMin(value = "0.01", message = "amount deve ser > 0 quando informado")
            BigDecimal amount,
            @NotBlank(message = "reason é obrigatório")
            String reason
    ) {}
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/api/admin/ControlPlanePaymentQueryController.java
============================================================
package brito.com.multitenancy001.controlplane.billing.api.admin;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import brito.com.multitenancy001.controlplane.billing.app.query.ControlPlanePaymentQueryService;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/admin/billing/payments/query")
@RequiredArgsConstructor
public class ControlPlanePaymentQueryController {

    private final ControlPlanePaymentQueryService service;

    /**
     * Lista pagamentos por status (ex.: PENDING/COMPLETED/FAILED...).
     */
    @GetMapping("/status/{status}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())")
    public ResponseEntity<List<PaymentResponse>> findByStatus(@PathVariable PaymentStatus status) {
        return ResponseEntity.ok(service.findByStatus(status));
    }

    /**
     * Soma total pago (COMPLETED) por conta em um período.
     */
    @GetMapping("/accounts/{accountId}/total-paid")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())"
            + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.name())"
    )
    public ResponseEntity<BigDecimal> getTotalPaidInPeriod(
            @PathVariable Long accountId,
            @RequestParam("startDate") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant startDate,
            @RequestParam("endDate")   @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant endDate
    ) {
        return ResponseEntity.ok(service.getTotalPaidInPeriod(accountId, startDate, endDate));
    }

    /**
     * Quantidade de pagamentos COMPLETED por conta.
     */
    @GetMapping("/accounts/{accountId}/count-completed")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.name())"
            + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.name())"
    )
    public ResponseEntity<Long> countCompletedPayments(@PathVariable Long accountId) {
        return ResponseEntity.ok(service.countCompletedPayments(accountId));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/app/ControlPlanePaymentService.java
============================================================
package brito.com.multitenancy001.controlplane.billing.app;

import brito.com.multitenancy001.controlplane.accounts.app.AccountStatusService;
import brito.com.multitenancy001.controlplane.accounts.app.command.AccountStatusChangeCommand;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.billing.domain.Payment;
import brito.com.multitenancy001.controlplane.billing.persistence.ControlPlanePaymentRepository;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ControlPlanePaymentService {

    private final AccountRepository accountRepository;
    private final ControlPlanePaymentRepository controlPlanePaymentRepository;
    private final SecurityUtils securityUtils;
    private final AppClock appClock;
    private final AccountStatusService accountStatusService;

    @Scheduled(cron = "${app.payment.check-cron:0 0 0 * * *}")
    public void checkPayments() {
        log.info("Iniciando verificação de pagamentos...");
        Instant now = appClock.instant();

        // Trials expirados: trialEndAt é Instant (timestamptz)
        List<Account> expiredTrials = accountRepository.findExpiredTrialsNotDeleted(now, AccountStatus.FREE_TRIAL);

        for (Account account : expiredTrials) {
            if (account.getStatus() != AccountStatus.SUSPENDED) {
                suspendAccount(account, "Trial expirado");
            }
        }

        // Pagamentos vencidos: paymentDueDate é LocalDate (DATE) => hoje é LocalDate em UTC (sem timezone implícito)
        LocalDate todayUtc = LocalDate.ofInstant(now, ZoneOffset.UTC);
        List<Account> overdueAccounts = accountRepository.findOverdueAccountsNotDeleted(AccountStatus.ACTIVE, todayUtc);

        for (Account account : overdueAccounts) {
            if (account.getStatus() != AccountStatus.SUSPENDED) {
                suspendAccount(account, "Pagamento atrasado");
            }
        }

        checkExpiredPendingPayments(now);
    }

    private void suspendAccount(Account account, String reason) {
        accountStatusService.changeAccountStatus(
                account.getId(),
                new AccountStatusChangeCommand(AccountStatus.SUSPENDED)
        );

        sendSuspensionEmail(account, reason);
    }

    private void checkExpiredPendingPayments(Instant now) {
        Instant thirtyMinutesAgo = now.minusSeconds(30 * 60);

        List<Payment> expiredPayments = controlPlanePaymentRepository
                .findByStatusAndAudit_CreatedAtBefore(PaymentStatus.PENDING, thirtyMinutesAgo);

        for (Payment payment : expiredPayments) {
            payment.setStatus(PaymentStatus.EXPIRED);
            controlPlanePaymentRepository.save(payment);
        }
    }

    @Transactional
    public PaymentResponse processPaymentForAccount(AdminPaymentRequest adminPaymentRequest) {

        if (adminPaymentRequest.accountId() == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        }

        Account account = accountRepository.findById(adminPaymentRequest.accountId())
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

        Instant now = appClock.instant();
        validatePayment(account, adminPaymentRequest.amount(), now);

        Payment payment = Payment.builder()
                .account(account)
                .amount(adminPaymentRequest.amount())
                .paymentMethod(adminPaymentRequest.paymentMethod())
                .paymentGateway(adminPaymentRequest.paymentGateway())
                .description(adminPaymentRequest.description())
                .status(PaymentStatus.PENDING)
                .paymentDate(now)
                .build();

        payment = controlPlanePaymentRepository.save(payment);

        boolean ok = processWithPaymentGateway(payment,
                new PaymentRequest(
                        adminPaymentRequest.amount(),
                        adminPaymentRequest.paymentMethod(),
                        adminPaymentRequest.paymentGateway(),
                        adminPaymentRequest.description()
                )
        );

        if (ok) {
            completePayment(payment, account, now);
            return mapToResponse(payment);
        }

        failPayment(payment, "Falha no processamento do pagamento");
        throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
    }

    @Transactional
    public PaymentResponse processPaymentForMyAccount(PaymentRequest paymentRequest) {
        Long accountId = securityUtils.getCurrentAccountId();
        Account account = findAccountOrThrow(accountId);

        Instant now = appClock.instant();
        validatePayment(account, paymentRequest.amount(), now);

        Payment payment = Payment.builder()
                .account(account)
                .amount(paymentRequest.amount())
                .paymentMethod(paymentRequest.paymentMethod())
                .paymentGateway(paymentRequest.paymentGateway())
                .description(paymentRequest.description())
                .status(PaymentStatus.PENDING)
                .paymentDate(now)
                .build();

        payment = controlPlanePaymentRepository.save(payment);

        boolean ok = processWithPaymentGateway(payment, paymentRequest);

        if (ok) {
            completePayment(payment, account, now);
            return mapToResponse(payment);
        }

        failPayment(payment, "Falha no processamento do pagamento");
        throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentByIdForMyAccount(Long paymentId) {
        Long accountId = securityUtils.getCurrentAccountId();

        Payment payment = controlPlanePaymentRepository.findScopedByIdAndAccountId(paymentId, accountId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByMyAccount() {
        Long accountId = securityUtils.getCurrentAccountId();
        return getPaymentsByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public boolean hasActivePaymentMyAccount() {
        Long accountId = securityUtils.getCurrentAccountId();
        return hasActivePayment(accountId);
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByAccount(Long accountId) {
        return controlPlanePaymentRepository.findByAccount_Id(accountId)
                .stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
    }


    @Transactional(readOnly = true)
    public boolean hasActivePayment(Long accountId) {
        return controlPlanePaymentRepository.existsActivePayment(accountId, appClock.instant());
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentById(Long paymentId) {
        Payment payment = controlPlanePaymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));
        return mapToResponse(payment);
    }

    @Transactional
    public PaymentResponse completePaymentManually(Long paymentId) {

        Payment payment = controlPlanePaymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        if (payment.getStatus() != PaymentStatus.PENDING) {
            throw new ApiException("INVALID_PAYMENT_STATUS", "Pagamento não está pendente", 409);
        }

        Instant now = appClock.instant();
        completePayment(payment, payment.getAccount(), now);
        return mapToResponse(payment);
    }

    @Transactional
    public PaymentResponse refundPayment(Long paymentId, BigDecimal amount, String reason) {

        Payment payment = controlPlanePaymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        Instant now = appClock.instant();

        if (!payment.canBeRefunded(now)) {
            throw new ApiException("PAYMENT_NOT_REFUNDABLE", "Pagamento não pode ser reembolsado", 409);
        }

        if (amount == null) {
            payment.refundFully(now, reason);
        } else {
            payment.refundPartially(now, amount, reason);
        }

        controlPlanePaymentRepository.save(payment);
        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    public BigDecimal getTotalRevenue(Instant startDate, Instant endDate) {
        List<Object[]> revenueByAccount = controlPlanePaymentRepository.getRevenueByAccount(startDate, endDate);

        return revenueByAccount.stream()
                .map(obj -> (BigDecimal) obj[1])
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private Account findAccountOrThrow(Long accountId) {
        return accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
    }

    private void completePayment(Payment payment, Account account, Instant now) {
        payment.markAsCompleted(now);
        controlPlanePaymentRepository.save(payment);

        account.setStatus(AccountStatus.ACTIVE);

        // ✅ paymentDueDate é LocalDate (civil)
        account.setPaymentDueDate(calculateNextDueDate(payment.getValidUntil(), now));
        accountRepository.save(account);

        sendPaymentConfirmationEmail(account, payment);
    }

    private void failPayment(Payment payment, String reason) {
        payment.markAsFailed(reason);
        controlPlanePaymentRepository.save(payment);
    }

    private void validatePayment(Account account, BigDecimal amount, Instant now) {

        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new ApiException("INVALID_AMOUNT", "Valor do pagamento inválido", 400);
        }

        if (account.isDeleted()) {
            throw new ApiException("ACCOUNT_DELETED", "Conta deletada", 410);
        }

        if (account.isBuiltInAccount()) {
            throw new ApiException("BUILTIN_ACCOUNT_NO_BILLING", "Conta BUILTIN não possui billing", 409);
        }

        boolean hasActive = controlPlanePaymentRepository.existsActivePayment(account.getId(), now);

        if (hasActive) {
            throw new ApiException("PAYMENT_ALREADY_EXISTS", "Já existe um pagamento ativo para esta conta", 409);
        }
    }

    @Transactional(readOnly = true)
    public boolean paymentExistsForAccount(Long paymentId, Long accountId) {
        if (paymentId == null) {
            throw new ApiException("PAYMENT_ID_REQUIRED", "paymentId é obrigatório", 400);
        }
        if (accountId == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        }
        return controlPlanePaymentRepository.existsByIdAndAccount_Id(paymentId, accountId);
    }


    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByAccountAndStatus(Long accountId, PaymentStatus status) {
        if (accountId == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        }
        if (status == null) {
            throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
        }

        return controlPlanePaymentRepository.findByAccount_IdAndStatus(accountId, status)
                .stream()
                .map(this::mapToResponse)
                .toList();
    }


    @Transactional(readOnly = true)
    public PaymentResponse getPaymentByTransactionId(String transactionId) {
        if (transactionId == null || transactionId.isBlank()) {
            throw new ApiException("INVALID_TRANSACTION_ID", "transactionId é obrigatório", 400);
        }

        Payment payment = controlPlanePaymentRepository.findByTransactionId(transactionId.trim())
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    public boolean existsByTransactionId(String transactionId) {
        if (transactionId == null || transactionId.isBlank()) {
            throw new ApiException("INVALID_TRANSACTION_ID", "transactionId é obrigatório", 400);
        }
        return controlPlanePaymentRepository.existsByTransactionId(transactionId.trim());
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByValidUntilBeforeAndStatus(Instant date, PaymentStatus status) {
        if (date == null) {
            throw new ApiException("INVALID_DATE", "date é obrigatório", 400);
        }
        if (status == null) {
            throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
        }

        return controlPlanePaymentRepository.findByValidUntilBeforeAndStatus(date, status)
                .stream()
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getCompletedPaymentsByAccount(Long accountId) {
        if (accountId == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        }

        return controlPlanePaymentRepository.findCompletedPaymentsByAccount(accountId)
                .stream()
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsInPeriod(Instant startDate, Instant endDate) {
        if (startDate == null || endDate == null) {
            throw new ApiException("INVALID_DATE_RANGE", "startDate e endDate são obrigatórios", 400);
        }
        if (endDate.isBefore(startDate)) {
            throw new ApiException("INVALID_DATE_RANGE", "endDate deve ser >= startDate", 400);
        }

        return controlPlanePaymentRepository.findPaymentsInPeriod(startDate, endDate)
                .stream()
                .map(this::mapToResponse)
                .toList();
    }

    private void sendSuspensionEmail(Account account, String reason) {
        log.info("Enviando email de suspensão para: {}", account.getLoginEmail());
    }

    private void sendPaymentConfirmationEmail(Account account, Payment payment) {
        log.info("Enviando confirmação de pagamento para: {}", account.getLoginEmail());
    }

    private LocalDate calculateNextDueDate(Instant validUntil, Instant now) {
        Instant base = (validUntil != null ? validUntil : now.plusSeconds(30L * 24 * 3600));
        return LocalDate.ofInstant(base, ZoneOffset.UTC);
    }

    private boolean processWithPaymentGateway(Payment payment, PaymentRequest paymentRequest) {

        log.info("Processando pagamento com gateway: {}", paymentRequest.paymentGateway());

        try {
            Thread.sleep(1000);
            return Math.random() < 0.9;

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Erro ao processar pagamento no gateway", e);
            return false;
        }
    }

    /**
     * ✅ PaymentResponse record (ordem e semântica):
     * (id, accountId, amount, paymentMethod, paymentGateway, paymentStatus, description, paidAt, validUntil, refundedAt, createdAt, updatedAt)
     */
    private PaymentResponse mapToResponse(Payment payment) {
        return new PaymentResponse(
                payment.getId(),
                payment.getAccount().getId(),

                payment.getAmount(),
                payment.getPaymentMethod(),
                payment.getPaymentGateway(),
                payment.getStatus(),

                payment.getDescription(),

                // paidAt: no seu domínio é paymentDate
                payment.getPaymentDate(),
                payment.getValidUntil(),
                payment.getRefundedAt(),

                // auditoria única
                payment.getAudit() != null ? payment.getAudit().getCreatedAt() : null,
                payment.getAudit() != null ? payment.getAudit().getUpdatedAt() : null
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/app/query/ControlPlanePaymentQueryService.java
============================================================
package brito.com.multitenancy001.controlplane.billing.app.query;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.billing.domain.Payment;
import brito.com.multitenancy001.controlplane.billing.persistence.ControlPlanePaymentRepository;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.billing.PaymentQueryFacade;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlanePaymentQueryService implements PaymentQueryFacade {

    private final ControlPlanePaymentRepository controlPlanePaymentRepository;
    private final brito.com.multitenancy001.shared.time.AppClock appClock;

    @Transactional(readOnly = true)
    @Override
    public List<PaymentResponse> findByStatus(PaymentStatus status) {
        if (status == null) throw new ApiException("PAYMENT_STATUS_REQUIRED", "status é obrigatório", 400);

        return controlPlanePaymentRepository.findByStatus(status)
                .stream()
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    @Override
    public BigDecimal getTotalPaidInPeriod(Long accountId, Instant startDate, Instant endDate) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);
        if (startDate == null || endDate == null) throw new ApiException("DATE_RANGE_REQUIRED", "startDate/endDate são obrigatórios", 400);

        BigDecimal total = controlPlanePaymentRepository.getTotalPaidInPeriod(accountId, startDate, endDate);
        return total != null ? total : BigDecimal.ZERO;
    }

    @Transactional(readOnly = true)
    @Override
    public long countCompletedPayments(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);

        Long count = controlPlanePaymentRepository.countCompletedPayments(accountId);
        return count != null ? count : 0L;
    }

    @Transactional(readOnly = true)
    @Override
    public List<PaymentResponse> listByAccount(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);

        return controlPlanePaymentRepository.findByAccount_IdOrderByAudit_CreatedAtDesc(accountId)
                .stream()
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    @Override
    public PaymentResponse getByAccount(Long accountId, Long paymentId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);
        if (paymentId == null) throw new ApiException("PAYMENT_ID_REQUIRED", "paymentId é obrigatório", 400);

        Payment payment = controlPlanePaymentRepository.findByIdAndAccount_Id(paymentId, accountId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    @Override
    public boolean hasActivePayment(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);

        return controlPlanePaymentRepository.existsActivePayment(accountId, appClock.instant());
    }

    private PaymentResponse mapToResponse(Payment payment) {
        return new PaymentResponse(
                payment.getId(),
                payment.getAccount().getId(),

                payment.getAmount(),
                payment.getPaymentMethod(),
                payment.getPaymentGateway(),
                payment.getStatus(),

                payment.getDescription(),

                payment.getPaymentDate(),
                payment.getValidUntil(),
                payment.getRefundedAt(),

                payment.getAudit() != null ? payment.getAudit().getCreatedAt() : null,
                payment.getAudit() != null ? payment.getAudit().getUpdatedAt() : null
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/domain/Payment.java
============================================================
package brito.com.multitenancy001.controlplane.billing.domain;

import jakarta.persistence.*;
import lombok.*;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.UUID;

@Entity
@Table(name = "payments", indexes = {
        @Index(name = "idx_payment_account", columnList = "account_id"),
        @Index(name = "idx_payment_status", columnList = "status"),
        @Index(name = "idx_payment_date", columnList = "payment_date")
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment implements Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(nullable = false, precision = 14, scale = 2)
    private BigDecimal amount;

    @Column(name = "payment_date", nullable = false, columnDefinition = "timestamptz")
    private Instant paymentDate;

    @Column(name = "valid_until", columnDefinition = "timestamptz")
    private Instant validUntil;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private PaymentStatus status = PaymentStatus.PENDING;

    @Column(name = "transaction_id", unique = true, length = 100)
    private String transactionId;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", nullable = false, length = 50)
    private PaymentMethod paymentMethod;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_gateway", nullable = false, length = 50)
    private PaymentGateway paymentGateway;

    @Column(name = "currency", length = 3, nullable = false)
    @Builder.Default
    private String currency = "BRL";

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    @Column(name = "invoice_url", columnDefinition = "TEXT")
    private String invoiceUrl;

    @Column(name = "receipt_url", columnDefinition = "TEXT")
    private String receiptUrl;

    // ===== AUDIT (ator)
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Column(name = "refunded_at", columnDefinition = "timestamptz")
    private Instant refundedAt;

    @Column(name = "refund_amount", precision = 10, scale = 2)
    private BigDecimal refundAmount;

    @Column(name = "refund_reason", length = 500)
    private String refundReason;

    @PrePersist
    protected void onCreate() {
        if (this.transactionId == null) {
            this.transactionId = "PAY_" + UUID.randomUUID().toString()
                    .replace("-", "")
                    .substring(0, 16)
                    .toUpperCase();
        }

        if (this.paymentDate == null) {
            throw new IllegalStateException("paymentDate deve ser definido pela aplicação (Clock/AppClock).");
        }

        if (this.status == PaymentStatus.COMPLETED && this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    private Instant calculateDefaultValidUntil(Instant baseDate) {
        return baseDate.plus(30, ChronoUnit.DAYS);
    }

    public void markAsCompleted(Instant now) {
        this.status = PaymentStatus.COMPLETED;
        if (this.paymentDate == null) this.paymentDate = now;
        if (this.validUntil == null) this.validUntil = calculateDefaultValidUntil(this.paymentDate);
    }

    public void markAsFailed(String reason) {
        this.status = PaymentStatus.FAILED;
        if (this.metadataJson == null) {
            this.metadataJson = "{\"failure_reason\":\"" + reason + "\"}";
        }
    }

    public boolean canBeRefunded(Instant now) {
        if (this.status != PaymentStatus.COMPLETED) return false;
        if (this.refundedAt != null) return false;
        if (this.paymentDate == null) return false;

        // até 90 dias após paymentDate
        Instant limit = now.minus(90, ChronoUnit.DAYS);
        return this.paymentDate.isAfter(limit);
    }

    public void refundPartially(Instant now, BigDecimal amount, String reason) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0 || amount.compareTo(this.amount) > 0) {
            throw new IllegalArgumentException("Valor de reembolso inválido");
        }
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento não pode ser reembolsado");
        }

        this.refundAmount = amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }

    public void refundFully(Instant now, String reason) {
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento não pode ser reembolsado");
        }

        this.refundAmount = this.amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/persistence/ControlPlanePaymentRepository.java
============================================================
package brito.com.multitenancy001.controlplane.billing.persistence;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.billing.domain.Payment;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlanePaymentRepository extends JpaRepository<Payment, Long> {

    // =========================================================
    // API "DDD": accountId (o domínio trabalha com ids)
    // Internamente (JPA): account.id (property-path)
    // =========================================================

    // ---------- scoped ----------
    default Optional<Payment> findScopedByIdAndAccountId(Long id, Long accountId) {
        return findByIdAndAccount_Id(id, accountId);
    }

    default Optional<Payment> findByIdAndAccountId(Long id, Long accountId) {
        return findByIdAndAccount_Id(id, accountId);
    }

    default boolean existsByIdAndAccountId(Long id, Long accountId) {
        return existsByIdAndAccount_Id(id, accountId);
    }

    // ---------- queries por account ----------
    default List<Payment> findByAccountId(Long accountId) {
        return findByAccount_Id(accountId);
    }

    default Page<Payment> findByAccountId(Long accountId, Pageable pageable) {
        return findByAccount_Id(accountId, pageable);
    }

    default List<Payment> findByAccountIdAndStatus(Long accountId, PaymentStatus status) {
        return findByAccount_IdAndStatus(accountId, status);
    }

    default List<Payment> findByAccountIdOrderByCreatedAtDesc(Long accountId) {
        // compat: se alguém ainda chamar esse nome antigo
        return findByAccount_IdOrderByAudit_CreatedAtDesc(accountId);
    }

    default List<Payment> findByAccountIdOrderByAudit_CreatedAtDesc(Long accountId) {
        return findByAccount_IdOrderByAudit_CreatedAtDesc(accountId);
    }

    // =========================================================
    // Métodos reais (JPA property-path) - NÃO use diretamente nos services
    // =========================================================

    Optional<Payment> findByIdAndAccount_Id(Long id, Long accountId);
    boolean existsByIdAndAccount_Id(Long id, Long accountId);

    List<Payment> findByAccount_Id(Long accountId);
    Page<Payment> findByAccount_Id(Long accountId, Pageable pageable);
    List<Payment> findByAccount_IdAndStatus(Long accountId, PaymentStatus status);

    List<Payment> findByAccount_IdOrderByAudit_CreatedAtDesc(Long accountId);

    // =========================================================
    // Outras queries
    // =========================================================

    Optional<Payment> findByTransactionId(String transactionId);
    boolean existsByTransactionId(String transactionId);

    List<Payment> findByStatus(PaymentStatus status);

    // ✅ audit.createdAt (clean, sem JPQL)
    List<Payment> findByStatusAndAudit_CreatedAtBefore(PaymentStatus status, Instant date);

    List<Payment> findByValidUntilBeforeAndStatus(Instant date, PaymentStatus status);

    @Query("""
        select p
          from Payment p
         where p.account.id = :accountId
           and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
         order by p.paymentDate desc
    """)
    List<Payment> findCompletedPaymentsByAccount(@Param("accountId") Long accountId);

    @Query("""
        select coalesce(sum(p.amount), 0)
          from Payment p
         where p.account.id = :accountId
           and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
           and p.paymentDate between :startDate and :endDate
    """)
    BigDecimal getTotalPaidInPeriod(
            @Param("accountId") Long accountId,
            @Param("startDate") Instant startDate,
            @Param("endDate") Instant endDate
    );

    @Query("""
        select count(p)
          from Payment p
         where p.account.id = :accountId
           and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
    """)
    Long countCompletedPayments(@Param("accountId") Long accountId);

    @Query("""
        select p
          from Payment p
         where p.paymentDate between :startDate and :endDate
    """)
    List<Payment> findPaymentsInPeriod(
            @Param("startDate") Instant startDate,
            @Param("endDate") Instant endDate
    );

    @Query("""
        select p.account.id, sum(p.amount)
          from Payment p
         where p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
           and p.paymentDate between :startDate and :endDate
         group by p.account.id
    """)
    List<Object[]> getRevenueByAccount(
            @Param("startDate") Instant startDate,
            @Param("endDate") Instant endDate
    );

    @Query("""
        select (count(p) > 0)
          from Payment p
         where p.account.id = :accountId
           and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
           and p.validUntil is not null
           and p.validUntil >= :now
    """)
    boolean existsActivePayment(@Param("accountId") Long accountId, @Param("now") Instant now);
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/scheduling/app/AccountJobScheduleService.java
============================================================
package brito.com.multitenancy001.controlplane.scheduling.app;

import brito.com.multitenancy001.controlplane.scheduling.domain.AccountJobSchedule;
import brito.com.multitenancy001.controlplane.scheduling.persistence.AccountJobScheduleRepository;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.*;
import java.time.zone.ZoneOffsetTransition;
import java.time.zone.ZoneRules;

@Service
@RequiredArgsConstructor
public class AccountJobScheduleService {

    private final AccountJobScheduleRepository repo;
    private final AppClock appClock;

    /**
     * Calcula o próximo run baseado em "horário civil do tenant".
     * Regra: guarda LocalTime + ZoneId, e converte para Instant só na execução.
     */
    public Instant computeNextRun(Instant now, LocalTime localTime, ZoneId zoneId) {
        ZonedDateTime zonedNow = now.atZone(zoneId);

        LocalDate date = zonedNow.toLocalDate();
        ZonedDateTime candidateToday = safeZoned(date, localTime, zoneId);

        if (candidateToday.isAfter(zonedNow)) {
            return candidateToday.toInstant();
        }

        ZonedDateTime candidateTomorrow = safeZoned(date.plusDays(1), localTime, zoneId);
        return candidateTomorrow.toInstant();
    }

    /**
     * Resolve problemas de DST (gap/overlap) sem explodir:
     * - Se for "gap" (horário inexistente), anda para o próximo horário válido.
     * - Se for "overlap" (horário duplicado), o Java resolve por padrão.
     */
    private ZonedDateTime safeZoned(LocalDate date, LocalTime time, ZoneId zoneId) {
        LocalDateTime ldt = LocalDateTime.of(date, time);
        try {
            return ZonedDateTime.of(ldt, zoneId);
        } catch (DateTimeException ex) {
            // gap: pega o próximo instante válido após a transição
            ZoneRules rules = zoneId.getRules();
            ZoneOffsetTransition t = rules.nextTransition(ldt.atZone(zoneId).toInstant());
            if (t != null) {
                return t.getDateTimeAfter().atZone(zoneId);
            }
            // fallback extremo: joga +1h
            return ZonedDateTime.of(ldt.plusHours(1), zoneId);
        }
    }

    public AccountJobSchedule ensureNextRun(AccountJobSchedule s) {
        Instant now = appClock.instant();
        if (s.getNextRunAt() == null) {
            Instant next = computeNextRun(now, s.getLocalTime(), ZoneId.of(s.getZoneId()));
            s.setNextRunAt(next);
        }
        s.setUpdatedAt(now);
        return repo.save(s);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/scheduling/domain/AccountJobSchedule.java
============================================================
package brito.com.multitenancy001.controlplane.scheduling.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.time.LocalTime;

@Getter
@Setter
@Entity
@Table(name = "account_job_schedules")
public class AccountJobSchedule {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(name = "job_key", nullable = false, length = 80)
    private String jobKey;

    @Column(name = "local_time", nullable = false)
    private LocalTime localTime;

    @Column(name = "zone_id", nullable = false, length = 60)
    private String zoneId;

    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;

    @Column(name = "last_run_at")
    private Instant lastRunAt;

    @Column(name = "next_run_at")
    private Instant nextRunAt;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/scheduling/infra/AccountJobScheduler.java
============================================================
package brito.com.multitenancy001.controlplane.scheduling.infra;

import java.time.Instant;

import org.springframework.context.annotation.DependsOn;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.scheduling.persistence.AccountJobScheduleRepository;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Scheduler do Control Plane.
 *
 * ✅ DependsOn("flywayInitializer") garante que o Flyway do PUBLIC já rodou
 * antes deste bean existir/rodar (sem sleep/delay).
 */
@Component
@RequiredArgsConstructor
@Slf4j
@DependsOn("flywayInitializer")
public class AccountJobScheduler {

    private final AccountJobScheduleRepository repo;
    private final PublicUnitOfWork uow;

    @Scheduled(fixedDelayString = "PT30S")
    public void runDueJobs() {
        uow.requiresNew(() -> {
            var now = Instant.now();
            var due = repo.findDue(now);

            if (!due.isEmpty()) {
                log.info("⏱️ Encontrados {} jobs vencidos (now={})", due.size(), now);
            }

            // TODO: executar jobs
        });
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/scheduling/persistence/AccountJobScheduleRepository.java
============================================================
package brito.com.multitenancy001.controlplane.scheduling.persistence;

import brito.com.multitenancy001.controlplane.scheduling.domain.AccountJobSchedule;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

public interface AccountJobScheduleRepository extends JpaRepository<AccountJobSchedule, Long> {

    Optional<AccountJobSchedule> findByAccountIdAndJobKey(Long accountId, String jobKey);

    @Query("""
        select s
        from AccountJobSchedule s
        where s.enabled = true
          and s.nextRunAt is not null
          and s.nextRunAt <= :now
        order by s.nextRunAt asc
    """)
    List<AccountJobSchedule> findDue(Instant now);
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlanePermission.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.PermissionCode;

public enum ControlPlanePermission implements PermissionCode {

    CP_TENANT_READ,
    CP_TENANT_SUSPEND,
    CP_TENANT_RESUME,
    CP_TENANT_DELETE,

    CP_BILLING_READ,
    CP_BILLING_WRITE,

    CP_USER_READ,
    CP_USER_WRITE,
    CP_USER_DELETE,

    CP_USER_PASSWORD_RESET;

    @Override
    public String asAuthority() {
        return name();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRole.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum ControlPlaneRole implements RoleAuthority {

    CONTROLPLANE_OWNER,
    CONTROLPLANE_ADMIN,
    CONTROLPLANE_BILLING_MANAGER,
    CONTROLPLANE_SUPPORT,
    CONTROLPLANE_VIEWER,
    CONTROLPLANE_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isOwner() {
        return this == CONTROLPLANE_OWNER;
    }

    public boolean isBillingManager() {
        return this == CONTROLPLANE_BILLING_MANAGER;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRolePermissions.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Set;

/**
 * Centraliza a matriz Role -> Permissions do Control Plane.
 *
 * Regras:
 * - sempre devolve Set imutável
 * - toda role deve estar mapeada explicitamente (evita "role nova = permissão vazia" por acidente)
 * - FAIL-FAST: role sem mapeamento explode na inicialização e/ou no uso
 */
public final class ControlPlaneRolePermissions {

    private ControlPlaneRolePermissions() {}

    private static final EnumMap<ControlPlaneRole, Set<ControlPlanePermission>> MAP =
            new EnumMap<>(ControlPlaneRole.class);

    static {
        // OWNER = tudo
        MAP.put(ControlPlaneRole.CONTROLPLANE_OWNER,
                unmodifiable(EnumSet.allOf(ControlPlanePermission.class)));

        // ADMIN = forte, mas sem ações mais destrutivas (produção-friendly)
        // Removemos deletes para evitar "um admin apaga tudo" por erro/ataque.
        EnumSet<ControlPlanePermission> admin = EnumSet.allOf(ControlPlanePermission.class);
        admin.remove(ControlPlanePermission.CP_TENANT_DELETE);
        admin.remove(ControlPlanePermission.CP_USER_DELETE);

        MAP.put(ControlPlaneRole.CONTROLPLANE_ADMIN, unmodifiable(admin));

        // BILLING_MANAGER = billing + leitura básica do tenant
        MAP.put(ControlPlaneRole.CONTROLPLANE_BILLING_MANAGER, unmodifiable(EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_BILLING_READ,
                ControlPlanePermission.CP_BILLING_WRITE
        )));

        // SUPPORT = operações de suporte (inclui reset de senha)
        MAP.put(ControlPlaneRole.CONTROLPLANE_SUPPORT, unmodifiable(EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_TENANT_SUSPEND,
                ControlPlanePermission.CP_TENANT_RESUME,
                ControlPlanePermission.CP_TENANT_DELETE,
                ControlPlanePermission.CP_USER_READ,
                ControlPlanePermission.CP_USER_WRITE,
                ControlPlanePermission.CP_USER_DELETE,
                ControlPlanePermission.CP_USER_PASSWORD_RESET
        )));

        // OPERATOR = leitura operacional
        MAP.put(ControlPlaneRole.CONTROLPLANE_OPERATOR, unmodifiable(EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_USER_READ
        )));

        // VIEWER = somente leitura
        MAP.put(ControlPlaneRole.CONTROLPLANE_VIEWER, unmodifiable(EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_BILLING_READ,
                ControlPlanePermission.CP_USER_READ
        )));

        // FAIL-FAST: garante que todas as roles do enum estão mapeadas
        for (ControlPlaneRole role : ControlPlaneRole.values()) {
            if (!MAP.containsKey(role)) {
                throw new IllegalStateException("Role do ControlPlane sem mapeamento em ControlPlaneRolePermissions: " + role);
            }
        }
    }

    public static Set<ControlPlanePermission> permissionsFor(ControlPlaneRole role) {
        Set<ControlPlanePermission> perms = MAP.get(role);
        if (perms == null) {
            throw new IllegalArgumentException("Role do ControlPlane sem permissões mapeadas: " + role);
        }
        return perms;
    }

    private static Set<ControlPlanePermission> unmodifiable(EnumSet<ControlPlanePermission> set) {
        return Collections.unmodifiableSet(set);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneSystemRoleMapper.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.SystemRoleName;

public final class ControlPlaneSystemRoleMapper {

    private ControlPlaneSystemRoleMapper() {}

    public static SystemRoleName toSystemRole(ControlPlaneRole role) {
        if (role == null) return null;
        // nomes são iguais
        return SystemRoleName.valueOf(role.name());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/SignupRequest.java
============================================================
package brito.com.multitenancy001.controlplane.signup.api.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;
import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public record SignupRequest(
        @NotBlank(message = "Nome da empresa é obrigatório")
        @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
        String displayName,

        @NotBlank(message = "Email da empresa é obrigatório")
        @Email(message = "Email inválido")
        String loginEmail,

        @NotNull(message = "Tipo de documento é obrigatório (CPF ou CNPJ)")
        TaxIdType taxIdType,

        @NotBlank(message = "Número do documento é obrigatório")
        String taxIdNumber,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
        	    regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
        	    message = "Senha deve ter pelo menos 8 caracteres, contendo letras e números"
        	)
        String password,

        @NotBlank(message = "Confirmação de senha é obrigatória")
        String confirmPassword
) {
    @AssertTrue(message = "As senhas não coincidem")
    public boolean isPasswordMatching() {
        if (password == null || confirmPassword == null) return true;
        return password.equals(confirmPassword);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/SignupResponse.java
============================================================
package brito.com.multitenancy001.controlplane.signup.api.dto;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountResponse;

public record SignupResponse(
        AccountResponse account,
        TenantAdminResponse tenantAdmin
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/TenantAdminResponse.java
============================================================
package brito.com.multitenancy001.controlplane.signup.api.dto;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * DTO do ControlPlane (Signup).
 *
 * Mantém role tipada sem depender do enum do contexto Tenant.
 */
public record TenantAdminResponse(
        Long id,
        String email,
        TenantRoleName role
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/api/publicweb/AccountSignupController.java
============================================================
package brito.com.multitenancy001.controlplane.signup.api.publicweb;

import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.accounts.app.AccountLifecycleService;
import brito.com.multitenancy001.controlplane.signup.api.dto.SignupRequest;
import brito.com.multitenancy001.controlplane.signup.api.dto.SignupResponse;
import brito.com.multitenancy001.controlplane.signup.api.dto.TenantAdminResponse;
import brito.com.multitenancy001.controlplane.signup.app.command.SignupCommand;
import brito.com.multitenancy001.controlplane.signup.app.dto.SignupResult;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/signup")
@RequiredArgsConstructor
public class AccountSignupController {

    private final AccountLifecycleService accountLifecycleService;
    private final AccountApiMapper accountApiMapper;

    @PostMapping
    public ResponseEntity<SignupResponse> signup(@Valid @RequestBody SignupRequest req) {

        SignupResult result = accountLifecycleService.createAccount(new SignupCommand(
                req.displayName(),
                req.loginEmail(),
                req.taxIdType(),
                req.taxIdNumber(),
                req.password(),
                req.confirmPassword()
        ));

        SignupResponse http = new SignupResponse(
                accountApiMapper.toResponse(result.account()),
                new TenantAdminResponse(
                        result.tenantAdmin().id(),
                        result.tenantAdmin().email(),
                        result.tenantAdmin().role()
                )
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(http);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/app/AccountOnboardingService.java
============================================================
package brito.com.multitenancy001.controlplane.signup.app;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import org.flywaydb.core.api.FlywayException;
import org.springframework.dao.DataAccessException;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.controlplane.accounts.app.AccountFactory;
import brito.com.multitenancy001.controlplane.accounts.app.audit.AccountProvisioningAuditService;
import brito.com.multitenancy001.controlplane.accounts.app.command.CreateAccountCommand;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.signup.app.command.SignupCommand;
import brito.com.multitenancy001.controlplane.signup.app.dto.SignupResult;
import brito.com.multitenancy001.controlplane.signup.app.dto.TenantAdminResult;
import brito.com.multitenancy001.infrastructure.tenant.TenantSchemaProvisioningFacade;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserProvisioningFacade;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityProvisioningService;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountOnboardingService {

    private static final String DEFAULT_TAX_COUNTRY_CODE = "BR";
    private static final long DEFAULT_TRIAL_DAYS = 14L;

    private final TenantSchemaProvisioningFacade tenantSchemaProvisioningFacade;
    private final TenantUserProvisioningFacade tenantUserProvisioningFacade;

    private final LoginIdentityProvisioningService loginIdentityProvisioningService;

    private final AccountRepository accountRepository;
    private final PublicUnitOfWork publicUnitOfWork;
    private final AppClock appClock;

    private final AccountProvisioningAuditService provisioningAuditService;

    public SignupResult createAccount(SignupCommand signupCommand) {
        SignupData data = validateAndNormalize(signupCommand);

        log.info("Tentando criar conta | loginEmail={}", data.loginEmail());

        // 1) Cria Account no PUBLIC (TX CP)
        Account account;
        try {
            account = publicUnitOfWork.tx(() -> {
                CreateAccountCommand cmd = new CreateAccountCommand(
                        data.displayName(),
                        data.loginEmail(),
                        data.taxCountryCode(),
                        data.taxIdType(),
                        data.taxIdNumber()
                );

                Account created = AccountFactory.newTenantAccount(cmd);

                // status inicial deve refletir que ainda falta schema+user
                created.setStatus(AccountStatus.PROVISIONING);

                return accountRepository.save(created);
            });
        } catch (RuntimeException ex) {
            log.error("❌ Falha criando Account no PUBLIC | loginEmail={}", data.loginEmail(), ex);
            throw ex;
        }

        // 2) Auditoria STARTED
        provisioningAuditService.started(
                account.getId(),
                "Provisioning started",
                buildDetailsJson(account, data, "STARTED", null, null)
        );

        UserSummaryData tenantOwner = null;

        try {
            // 3) Provisionamento fora do TX do CP (envolve infra/DDL/migrations)
            try {
                tenantSchemaProvisioningFacade.ensureSchemaExistsAndMigrate(account.getSchemaName());
            } catch (FlywayException ex) {
                throw provisioningFailed(ProvisioningFailureCode.TENANT_MIGRATION_ERROR, ex);
            } catch (DataAccessException ex) {
                throw provisioningFailed(ProvisioningFailureCode.SCHEMA_CREATION_ERROR, ex);
            } catch (RuntimeException ex) {
                ProvisioningFailureCode code = (ex instanceof ApiException)
                        ? ProvisioningFailureCode.VALIDATION_ERROR
                        : ProvisioningFailureCode.UNKNOWN;
                throw provisioningFailed(code, ex);
            }

            // 4) Criação do tenant owner
            try {
                tenantOwner = tenantUserProvisioningFacade.createTenantOwner(
                        account.getSchemaName(),
                        account.getId(),
                        account.getDisplayName(),
                        data.loginEmail(),
                        data.password()
                );
            } catch (RuntimeException ex) {
                throw provisioningFailed(ProvisioningFailureCode.TENANT_ADMIN_CREATION_ERROR, ex);
            }

            // 5) Registrar identidade de login no PUBLIC (para /api/tenant/auth/login)
            try {
                publicUnitOfWork.tx(() -> {
                    loginIdentityProvisioningService.ensureTenantIdentity(data.loginEmail(), account.getId());
                    return null;
                });
            } catch (RuntimeException ex) {
                throw provisioningFailed(ProvisioningFailureCode.PUBLIC_PERSISTENCE_ERROR, ex);
            }

            // 6) Finaliza status/trial no PUBLIC
            Account finalized;
            try {
                finalized = finalizeProvisioning(account.getId());
            } catch (RuntimeException ex) {
                throw provisioningFailed(ProvisioningFailureCode.PUBLIC_PERSISTENCE_ERROR, ex);
            }

            // 7) Auditoria SUCCESS
            provisioningAuditService.success(
                    finalized.getId(),
                    "Provisioning success",
                    buildDetailsJson(finalized, data, "SUCCESS", null, null)
            );

            log.info("✅ Account criada | accountId={} | schemaName={} | slug={} | status={} | trialEndAt={}",
                    finalized.getId(),
                    finalized.getSchemaName(),
                    finalized.getSlug(),
                    finalized.getStatus(),
                    finalized.getTrialEndAt()
            );

            TenantAdminResult tenantAdminResult = new TenantAdminResult(
                    tenantOwner.id(),
                    tenantOwner.email(),
                    tenantOwner.role()
            );

            return new SignupResult(finalized, tenantAdminResult);

        } catch (ProvisioningFailedException wrapped) {
            ProvisioningFailureCode code = wrapped.code();

            String message = safeMessage(wrapped.getCause());
            provisioningAuditService.failed(
                    account.getId(),
                    code,
                    message,
                    buildDetailsJson(account, data, "FAILED", code, wrapped.getCause())
            );

            log.error("❌ Falha no provisioning | accountId={} | schemaName={} | code={}",
                    account.getId(), account.getSchemaName(), code, wrapped.getCause());

            if (wrapped.getCause() instanceof RuntimeException re) {
                throw re;
            }
            throw wrapped;

        } catch (RuntimeException ex) {
            provisioningAuditService.failed(
                    account.getId(),
                    ProvisioningFailureCode.UNKNOWN,
                    safeMessage(ex),
                    buildDetailsJson(account, data, "FAILED", ProvisioningFailureCode.UNKNOWN, ex)
            );

            log.error("❌ Falha inesperada no provisioning | accountId={} | schemaName={}",
                    account.getId(), account.getSchemaName(), ex);

            throw ex;
        }
    }

    private Account finalizeProvisioning(Long accountId) {
        return publicUnitOfWork.tx(() -> {
            Account managed = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada após criação", 500));

            Instant now = appClock.instant();

            if (managed.getStatus() == AccountStatus.PROVISIONING) {
                managed.setStatus(AccountStatus.FREE_TRIAL);
            }

            // FREE_TRIAL precisa de trialEndAt (Instant)
            if (managed.getStatus() == AccountStatus.FREE_TRIAL && managed.getTrialEndAt() == null) {
                managed.setTrialEndAt(now.plus(DEFAULT_TRIAL_DAYS, ChronoUnit.DAYS));
            }

            return accountRepository.save(managed);
        });
    }

    private SignupData validateAndNormalize(SignupCommand cmd) {
        if (cmd == null) {
            throw new ApiException("INVALID_REQUEST", "Requisição inválida", 400);
        }

        String displayName = safeTrim(cmd.displayName());
        if (!StringUtils.hasText(displayName)) {
            throw new ApiException("INVALID_COMPANY_NAME", "Nome da empresa é obrigatório", 400);
        }

        String loginEmail = normalizeEmail(cmd.loginEmail());
        if (!StringUtils.hasText(loginEmail)) {
            throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
        }
        if (!looksLikeEmail(loginEmail)) {
            throw new ApiException("INVALID_EMAIL", "Email inválido", 400);
        }

        if (cmd.taxIdType() == null) {
            throw new ApiException("INVALID_COMPANY_DOC_TYPE", "Tipo de documento é obrigatório", 400);
        }

        String taxIdNumber = safeTrim(cmd.taxIdNumber());
        if (!StringUtils.hasText(taxIdNumber)) {
            throw new ApiException("INVALID_COMPANY_DOC_NUMBER", "Número do documento é obrigatório", 400);
        }

        String password = cmd.password();
        String confirmPassword = cmd.confirmPassword();

        if (!StringUtils.hasText(password) || !StringUtils.hasText(confirmPassword)) {
            throw new ApiException("INVALID_PASSWORD", "Senha e confirmação são obrigatórias", 400);
        }
        if (!password.equals(confirmPassword)) {
            throw new ApiException("PASSWORD_MISMATCH", "As senhas não coincidem", 400);
        }

        String taxCountryCode = DEFAULT_TAX_COUNTRY_CODE;

        if (accountRepository.existsByLoginEmailAndDeletedFalse(loginEmail)) {
            throw new ApiException("EMAIL_ALREADY_REGISTERED", "Email já cadastrado na plataforma", 409);
        }

        if (accountRepository.existsByTaxCountryCodeAndTaxIdTypeAndTaxIdNumberAndDeletedFalse(
                taxCountryCode, cmd.taxIdType(), taxIdNumber
        )) {
            throw new ApiException("DOC_ALREADY_REGISTERED", "Documento já cadastrado na plataforma", 409);
        }

        return new SignupData(displayName, loginEmail, taxCountryCode, cmd.taxIdType(), taxIdNumber, password);
    }

    private static String safeTrim(String s) {
        return s == null ? null : s.trim();
    }

    private static String normalizeEmail(String email) {
        if (email == null) return null;
        return email.trim().toLowerCase();
    }

    private static boolean looksLikeEmail(String email) {
        int at = email.indexOf('@');
        if (at <= 0) return false;
        if (at != email.lastIndexOf('@')) return false;
        if (at == email.length() - 1) return false;
        return true;
    }

    private String buildDetailsJson(
            Account account,
            SignupData data,
            String stage,
            ProvisioningFailureCode failureCode,
            Throwable error
    ) {
        String taxIdMasked = maskTaxId(data.taxIdNumber());
        String errorType = (error == null) ? null : error.getClass().getName();
        String errorMsg = (error == null) ? null : safeMessage(error);

        return "{"
                + "\"stage\":\"" + escape(stage) + "\""
                + ",\"accountId\":" + (account == null ? "null" : account.getId())
                + ",\"schemaName\":\"" + escape(account == null ? null : account.getSchemaName()) + "\""
                + ",\"slug\":\"" + escape(account == null ? null : account.getSlug()) + "\""
                + ",\"status\":\"" + escape(account == null ? null : String.valueOf(account.getStatus())) + "\""
                + ",\"displayName\":\"" + escape(data.displayName()) + "\""
                + ",\"loginEmail\":\"" + escape(data.loginEmail()) + "\""
                + ",\"taxCountryCode\":\"" + escape(data.taxCountryCode()) + "\""
                + ",\"taxIdType\":\"" + escape(String.valueOf(data.taxIdType())) + "\""
                + ",\"taxIdMasked\":\"" + escape(taxIdMasked) + "\""
                + ",\"failureCode\":\"" + escape(failureCode == null ? null : failureCode.name()) + "\""
                + ",\"errorType\":\"" + escape(errorType) + "\""
                + ",\"errorMessage\":\"" + escape(errorMsg) + "\""
                + "}";
    }

    private static String maskTaxId(String taxId) {
        if (!StringUtils.hasText(taxId)) return null;
        String digits = taxId.trim();
        if (digits.length() <= 4) return "****";
        return "****" + digits.substring(digits.length() - 4);
    }

    private static String safeMessage(Throwable t) {
        if (t == null) return null;
        String msg = t.getMessage();
        if (!StringUtils.hasText(msg)) return t.getClass().getSimpleName();
        return msg;
    }

    private static String escape(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .trim();
    }

    private static ProvisioningFailedException provisioningFailed(ProvisioningFailureCode code, Throwable cause) {
        return new ProvisioningFailedException(code, cause);
    }

    private record SignupData(
            String displayName,
            String loginEmail,
            String taxCountryCode,
            brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType taxIdType,
            String taxIdNumber,
            String password
    ) {}

    private static class ProvisioningFailedException extends RuntimeException {
        private static final long serialVersionUID = 1L;
        private final ProvisioningFailureCode code;

        private ProvisioningFailedException(ProvisioningFailureCode code, Throwable cause) {
            super(cause);
            this.code = code == null ? ProvisioningFailureCode.UNKNOWN : code;
        }

        public ProvisioningFailureCode code() {
            return code;
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/app/command/SignupCommand.java
============================================================
package brito.com.multitenancy001.controlplane.signup.app.command;

import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;

public record SignupCommand(
        String displayName,
        String loginEmail,
        TaxIdType taxIdType,
        String taxIdNumber,
        String password,
        String confirmPassword
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/app/dto/SignupResult.java
============================================================
package brito.com.multitenancy001.controlplane.signup.app.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;

public record SignupResult(
        Account account,
        TenantAdminResult tenantAdmin
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/app/dto/TenantAdminResult.java
============================================================
package brito.com.multitenancy001.controlplane.signup.app.dto;

import brito.com.multitenancy001.shared.security.TenantRoleName;

public record TenantAdminResult(
        Long id,
        String email,
        TenantRoleName role
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/admin/ControlPlaneMeController.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.admin;

import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneChangeMyPasswordRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneMeResponse;
import brito.com.multitenancy001.controlplane.users.app.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/controlplane/me")
@RequiredArgsConstructor
public class ControlPlaneMeController {

    private final ControlPlaneUserService controlPlaneUserService;

    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_ME_READ.name())")
    public ResponseEntity<ControlPlaneMeResponse> me() {
        return ResponseEntity.ok(controlPlaneUserService.getMe());
    }

    @PatchMapping("/password")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_ME_PASSWORD_CHANGE.name())")
    public ResponseEntity<Void> changeMyPassword(@Valid @RequestBody ControlPlaneChangeMyPasswordRequest request) {
        controlPlaneUserService.changeMyPassword(request);
        return ResponseEntity.noContent().build();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/admin/ControlPlaneUserController.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.admin;

import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserPasswordResetRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserPermissionsUpdateRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserUpdateRequest;
import brito.com.multitenancy001.controlplane.users.app.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/controlplane-users")
@RequiredArgsConstructor
public class ControlPlaneUserController {

    private final ControlPlaneUserService controlPlaneUserService;

    // Cria um novo usuário do Control Plane (Admin), aplicando validações e regras de negócio (ex.: email único, role/permissões válidas).
    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.name())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> createControlPlaneUser(
            @Valid @RequestBody ControlPlaneUserCreateRequest request
    ) {
        ControlPlaneUserDetailsResponse response = controlPlaneUserService.createControlPlaneUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    // Lista todos os usuários do Control Plane (Admin), incluindo estados (suspensões/deleção) conforme regras do serviço.
    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_READ.name())")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listControlPlaneUsers() {
        return ResponseEntity.ok(controlPlaneUserService.listControlPlaneUsers());
    }

    // Obtém os detalhes de um usuário do Control Plane (Admin) pelo id (pode incluir usuário suspenso/deletado, conforme regras do serviço).
    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_READ.name())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getControlPlaneUser(userId));
    }

    // Atualiza dados do usuário do Control Plane (Admin) pelo id (ex.: nome, email, role, flags e/ou campos permitidos), conforme validações do serviço.
    @PatchMapping("/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.name())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUser(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserUpdateRequest request
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUser(userId, request));
    }

    // Atualiza o conjunto de permissões explícitas (overrides) do usuário do Control Plane (Admin), validando escopo e consistência (somente CP_*).
    @PatchMapping("/{userId}/permissions")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.name())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUserPermissions(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserPermissionsUpdateRequest request
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUserPermissions(userId, request));
    }

    // Reseta/define uma nova senha para o usuário do Control Plane (Admin) (ação administrativa), conforme política de senha e regras do serviço.
    @PatchMapping("/{userId}/reset-password")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_PASSWORD_RESET.name())")
    public ResponseEntity<Void> resetPassword(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserPasswordResetRequest request
    ) {
        controlPlaneUserService.resetControlPlaneUserPassword(userId, request);
        return ResponseEntity.noContent().build();
    }

    // Realiza soft delete do usuário do Control Plane (Admin) pelo id (marca como deleted, preservando histórico/auditoria).
    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_DELETE.name())")
    public ResponseEntity<Void> deleteControlPlaneUser(@PathVariable Long userId) {
        controlPlaneUserService.softDeleteControlPlaneUser(userId);
        return ResponseEntity.noContent().build();
    }

    // Restaura (undelete) um usuário do Control Plane (Admin) previamente soft-deletado, conforme regras do serviço.
    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.name())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> restoreControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.restoreControlPlaneUser(userId));
    }

    // Lista apenas usuários "habilitados" para operação: não deletados e não suspensos (nem por admin nem por conta), conforme regra do serviço.
    @GetMapping("/enabled")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_READ.name())")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listEnabled() {
        return ResponseEntity.ok(controlPlaneUserService.listEnabledControlPlaneUsers());
    }

    // Obtém usuário "habilitado" pelo id: retorna apenas se estiver apto para operar (não deletado e não suspenso), conforme regra do serviço.
    @GetMapping("/{userId}/enabled")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_READ.name())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getEnabled(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getEnabledControlPlaneUser(userId));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneAdminUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

public record ControlPlaneAdminUserSummaryResponse(
        Long id,

        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneChangeMyPasswordRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record ControlPlaneChangeMyPasswordRequest(
        @NotBlank(message = "Senha atual é obrigatória")
        @Size(min = 8, max = 72, message = "Senha atual deve ter entre 8 e 72 caracteres")
        String currentPassword,

        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, max = 72, message = "Nova senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar senha é obrigatório")
        @Size(min = 8, max = 72, message = "Confirmar senha deve ter entre 8 e 72 caracteres")
        String confirmPassword
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneMeResponse.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import brito.com.multitenancy001.shared.security.SystemRoleName;

public record ControlPlaneMeResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        SystemRoleName  role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserCreateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.List;

@Builder
public record ControlPlaneUserCreateRequest(

        @NotBlank(message = "Nome é obrigatório")
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @NotBlank(message = "Email é obrigatório")
        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email não pode exceder 150 caracteres")
        String email,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
                regexp = ValidationPatterns.PASSWORD_PATTERN,
                message = "Senha fraca / inválida"
        )
        String password,

        @NotNull(message = "Role é obrigatória")
        ControlPlaneRole role,

        List<String> permissions,

        @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, message = "Telefone inválido")
        @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
        String phone,

        @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
        String avatarUrl
) {
    public ControlPlaneUserCreateRequest {
        if (phone != null) phone = phone.trim();
        if (avatarUrl != null) avatarUrl = avatarUrl.trim();
        if (email != null) email = email.trim().toLowerCase();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserDetailsResponse.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import brito.com.multitenancy001.shared.security.SystemRoleName;

import java.time.Instant;

public record ControlPlaneUserDetailsResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        SystemRoleName role,

        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled,

        Instant createdAt
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserPasswordResetRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record ControlPlaneUserPasswordResetRequest(
        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, max = 72, message = "Senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar senha é obrigatório")
        @Size(min = 8, max = 72, message = "Confirmar senha deve ter entre 8 e 72 caracteres")
        String confirmPassword
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserPermissionsUpdateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Pattern;

import java.util.List;

public record ControlPlaneUserPermissionsUpdateRequest(
        @NotEmpty(message = "Lista de permissões não pode ser vazia")
        List<
                @Pattern(
                        regexp = "^CP_[A-Z0-9_]+$",
                        message = "Permissões de ControlPlane devem começar com CP_"
                )
                        String
                > permissions
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserUpdateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

import java.util.List;

public record ControlPlaneUserUpdateRequest(
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email deve ter no máximo 150 caracteres")
        String email,

        ControlPlaneRole role,

        List<
                @Pattern(
                        regexp = "^CP_[A-Z0-9_]+$",
                        message = "Permissões de ControlPlane devem começar com CP_"
                )
                String
        > permissions
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/mapper/ControlPlaneUserApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.mapper;

import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;

import org.springframework.stereotype.Component;

@Component
public class ControlPlaneUserApiMapper {

    public ControlPlaneAdminUserSummaryResponse toAdminSummary(ControlPlaneUser controlPlaneUser) {
        return new ControlPlaneAdminUserSummaryResponse(
                controlPlaneUser.getId(),
   
                controlPlaneUser.getEmail(),
                controlPlaneUser.isSuspendedByAccount(),
                controlPlaneUser.isSuspendedByAdmin()
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserExplicitPermissionsService.java
============================================================
package brito.com.multitenancy001.controlplane.users.app;

import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ControlPlaneUserExplicitPermissionsService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final ControlPlaneUserRepository controlPlaneUserRepository;

    /**
     * Define permissions explícitas (override) a partir de strings.
     *
     * Regras:
     * - Só aceita "CP_*" (STRICT).
     * - Converte para enum ControlPlanePermission (explode se não existir).
     * - Persiste no usuário (public schema).
     */
    public void setExplicitPermissionsFromCodes(Long userId, Collection<String> permissionCodes) {

        LinkedHashSet<String> normalized = PermissionScopeValidator.normalizeControlPlaneStrict(permissionCodes);

        Set<ControlPlanePermission> perms = normalized.stream()
                .map(code -> {
                    try {
                        return ControlPlanePermission.valueOf(code);
                    } catch (IllegalArgumentException e) {
                        throw new ApiException(
                                "INVALID_PERMISSION",
                                "Permission não existe no enum ControlPlanePermission: " + code,
                                400
                        );
                    }
                })
                .collect(Collectors.toCollection(LinkedHashSet::new));

        publicUnitOfWork.tx(() -> {
            ControlPlaneUser user = controlPlaneUserRepository.findByIdAndDeletedFalse(userId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            // domínio manda (evita setPermissions inexistente / leaking)
            user.replaceExplicitPermissions(perms);

            controlPlaneUserRepository.save(user);
            return null;
        });
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserService.java
============================================================
package brito.com.multitenancy001.controlplane.users.app;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneChangeMyPasswordRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneMeResponse;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserPasswordResetRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserPermissionsUpdateRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneUserUpdateRequest;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.SystemRoleName;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlaneUserService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final AccountRepository accountRepository;
    private final ControlPlaneUserRepository controlPlaneUserRepository;

    // =========================================================
    // ADMIN ENDPOINTS (/api/admin/controlplane-users)
    // =========================================================

    public ControlPlaneUserDetailsResponse createControlPlaneUser(ControlPlaneUserCreateRequest request) {
        return publicUnitOfWork.tx(() -> {
            if (request == null) {
                throw new ApiException("INVALID_REQUEST", "request é obrigatório", 400);
            }

            // Sem o seu modelo completo (policy + password hashing + permission overrides),
            // não dá pra implementar com segurança aqui sem “inventar” regra.
            throw new ApiException(
                    "NOT_IMPLEMENTED",
                    "createControlPlaneUser() ainda não foi ligado ao modelo real (hash de senha, policy e permissões)",
                    501
            );
        });
    }

    public List<ControlPlaneUserDetailsResponse> listControlPlaneUsers() {
        return publicUnitOfWork.readOnly(() -> {
            Account cp = getControlPlaneAccount();

            // ✅ SEM depender de métodos custom no repository (para não quebrar compile):
            // usa findAll() e filtra por accountId (ControlPlane).
            return controlPlaneUserRepository.findAll().stream()
                    .filter(u -> u.getAccount() != null && u.getAccount().getId() != null && u.getAccount().getId().equals(cp.getId()))
                    .map(this::mapToResponse)
                    .toList();
        });
    }

    public ControlPlaneUserDetailsResponse getControlPlaneUser(Long userId) {
        return publicUnitOfWork.readOnly(() -> {
            if (userId == null) throw new ApiException("USER_ID_REQUIRED", "userId é obrigatório", 400);

            Account cp = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository.findById(userId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            if (user.getAccount() == null || user.getAccount().getId() == null || !user.getAccount().getId().equals(cp.getId())) {
                throw new ApiException("USER_OUT_OF_SCOPE", "Usuário não pertence ao Control Plane", 403);
            }

            return mapToResponse(user);
        });
    }

    public ControlPlaneUserDetailsResponse updateControlPlaneUser(Long userId, ControlPlaneUserUpdateRequest request) {
        return publicUnitOfWork.tx(() -> {
            if (userId == null) throw new ApiException("USER_ID_REQUIRED", "userId é obrigatório", 400);
            if (request == null) throw new ApiException("INVALID_REQUEST", "request é obrigatório", 400);

            // Garantia de escopo (CP)
            getControlPlaneUser(userId);

            throw new ApiException(
                    "NOT_IMPLEMENTED",
                    "updateControlPlaneUser() ainda não foi ligado ao modelo real (campos mutáveis + validações + unicidade)",
                    501
            );
        });
    }

    public ControlPlaneUserDetailsResponse updateControlPlaneUserPermissions(
            Long userId,
            ControlPlaneUserPermissionsUpdateRequest request
    ) {
        return publicUnitOfWork.tx(() -> {
            if (userId == null) throw new ApiException("USER_ID_REQUIRED", "userId é obrigatório", 400);
            if (request == null) throw new ApiException("INVALID_REQUEST", "request é obrigatório", 400);

            // Garantia de escopo (CP)
            getControlPlaneUser(userId);

            throw new ApiException(
                    "NOT_IMPLEMENTED",
                    "updateControlPlaneUserPermissions() ainda não foi ligado ao seu modelo de overrides/validação de escopo",
                    501
            );
        });
    }

    public void resetControlPlaneUserPassword(Long userId, ControlPlaneUserPasswordResetRequest request) {
        publicUnitOfWork.tx(() -> {
            if (userId == null) throw new ApiException("USER_ID_REQUIRED", "userId é obrigatório", 400);
            if (request == null) throw new ApiException("INVALID_REQUEST", "request é obrigatório", 400);

            // Garantia de escopo (CP)
            getControlPlaneUser(userId);

            throw new ApiException(
                    "NOT_IMPLEMENTED",
                    "resetControlPlaneUserPassword() depende do seu PasswordEncoder/policy e campos de senha no domínio",
                    501
            );
        });
    }

    public void softDeleteControlPlaneUser(Long userId) {
        publicUnitOfWork.tx(() -> {
            if (userId == null) throw new ApiException("USER_ID_REQUIRED", "userId é obrigatório", 400);

            // Garantia de escopo (CP)
            getControlPlaneUser(userId);

            throw new ApiException(
                    "NOT_IMPLEMENTED",
                    "softDeleteControlPlaneUser() ainda não foi ligado ao seu SoftDelete padrão (deleted + audit.deletedAt)",
                    501
            );
        });
    }

    public ControlPlaneUserDetailsResponse restoreControlPlaneUser(Long userId) {
        return publicUnitOfWork.tx(() -> {
            if (userId == null) throw new ApiException("USER_ID_REQUIRED", "userId é obrigatório", 400);

            // Garantia de escopo (CP)
            getControlPlaneUser(userId);

            throw new ApiException(
                    "NOT_IMPLEMENTED",
                    "restoreControlPlaneUser() ainda não foi ligado ao seu modelo de restore (deleted=false + audit.deletedAt=null)",
                    501
            );
        });
    }

    // =========================================================
    // ENABLED ENDPOINTS (já existiam no seu service)
    // =========================================================

    public List<ControlPlaneUserDetailsResponse> listEnabledControlPlaneUsers() {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            List<ControlPlaneUser> users =
                    controlPlaneUserRepository.findEnabledByAccountId(controlPlaneAccount.getId());

            return users.stream().map(this::mapToResponse).toList();
        });
    }

    public ControlPlaneUserDetailsResponse getEnabledControlPlaneUser(Long userId) {
        return publicUnitOfWork.tx(() -> {
            if (userId == null) throw new ApiException("USER_ID_REQUIRED", "userId é obrigatório", 400);

            Account controlPlaneAccount = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository
                    .findEnabledByIdAndAccountId(userId, controlPlaneAccount.getId())
                    .orElseThrow(() -> new ApiException(
                            "USER_NOT_ENABLED",
                            "Usuário não encontrado ou não habilitado",
                            404
                    ));

            return mapToResponse(user);
        });
    }

    // =========================================================
    // ME ENDPOINTS (/api/controlplane/me)
    // =========================================================

    public ControlPlaneMeResponse getMe() {
        return publicUnitOfWork.readOnly(() -> {
            throw new ApiException(
                    "NOT_IMPLEMENTED",
                    "getMe() ainda não foi ligado ao SecurityContext/SecurityUtils do ControlPlane",
                    501
            );
        });
    }

    public void changeMyPassword(ControlPlaneChangeMyPasswordRequest request) {
        publicUnitOfWork.tx(() -> {
            if (request == null) {
                throw new ApiException("INVALID_REQUEST", "request é obrigatório", 400);
            }
            throw new ApiException(
                    "NOT_IMPLEMENTED",
                    "changeMyPassword() ainda não foi ligado ao SecurityContext + política de senha do ControlPlane",
                    501
            );
        });
    }

    // =========================================================
    // Helpers
    // =========================================================

    private ControlPlaneUserDetailsResponse mapToResponse(ControlPlaneUser user) {
        return new ControlPlaneUserDetailsResponse(
                user.getId(),
                user.getAccount().getId(),
                user.getName(),
                user.getEmail(),
                SystemRoleName.fromString(user.getRole() == null ? null : user.getRole().name()),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.isDeleted(),
                user.isEnabled(),
                user.getAudit() == null ? null : user.getAudit().getCreatedAt()
        );
    }

    private Account getControlPlaneAccount() {
        return accountRepository.findControlPlaneAccount()
                .orElseThrow(() -> new ApiException(
                        "CONTROLPLANE_ACCOUNT_NOT_FOUND",
                        "Conta controlplane não encontrada",
                        500
                ));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/domain/ControlPlaneBuiltInUsers.java
============================================================
package brito.com.multitenancy001.controlplane.users.domain;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;

import java.util.Set;

/**
 * Emails reservados do sistema (BUILT_IN).
 *
 * Regra:
 * - comparação deve ser case-insensitive via CITEXT no banco;
 * - aqui normalizamos uma única vez via EmailNormalizer (trim + lower) para manter consistência.
 */
public final class ControlPlaneBuiltInUsers {

    private ControlPlaneBuiltInUsers() {}

    public static final String SUPERADMIN_EMAIL = "superadmin@platform.local";
    public static final String BILLING_EMAIL    = "billing@platform.local";
    public static final String SUPPORT_EMAIL    = "support@platform.local";
    public static final String OPERATOR_EMAIL   = "operator@platform.local";

    public static final Set<String> RESERVED_EMAILS = Set.of(
            SUPERADMIN_EMAIL,
            BILLING_EMAIL,
            SUPPORT_EMAIL,
            OPERATOR_EMAIL
    );

    public static boolean isReservedEmail(String email) {
        String norm = EmailNormalizer.normalizeOrNull(email);
        if (norm == null) return false;
        return RESERVED_EMAILS.contains(norm);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/domain/ControlPlaneUser.java
============================================================
package brito.com.multitenancy001.controlplane.users.domain;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import jakarta.persistence.*;
import lombok.*;

import java.time.Instant;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(name = "controlplane_users")
@EntityListeners(AuditEntityListener.class)
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"account", "password", "explicitPermissions"})
public class ControlPlaneUser implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Setter(AccessLevel.NONE)
    @Enumerated(EnumType.STRING)
    @Column(name = "user_origin", nullable = false, length = 20)
    @Builder.Default
    private EntityOrigin origin = EntityOrigin.ADMIN;

    public boolean isBuiltInUser() {
        return this.origin == EntityOrigin.BUILT_IN;
    }

    @Setter(AccessLevel.NONE)
    @Column(nullable = false, length = 100)
    private String name;

    @Setter(AccessLevel.NONE)
    @Column(name = "password", nullable = false, length = 255)
    private String password;

    @Setter(AccessLevel.NONE)
    @Column(name = "email", nullable = false, columnDefinition = "citext")
    private String email;


    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", length = 50)
    private ControlPlaneRole role;

    // ==========
    // AUTH / SECURITY (instantes reais => Instant)
    // ==========
    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private boolean mustChangePassword = false;

    @Column(name = "last_login", columnDefinition = "TIMESTAMPTZ")
    private Instant lastLoginAt;

    @Column(name = "locked_until", columnDefinition = "TIMESTAMPTZ")
    private Instant lockedUntil;

    @Column(name = "password_changed_at", columnDefinition = "TIMESTAMPTZ")
    private Instant passwordChangedAt;

    @Column(name = "password_reset_token", length = 200)
    private String passwordResetToken;

    @Column(name = "password_reset_expires", columnDefinition = "TIMESTAMPTZ")
    private Instant passwordResetExpiresAt;

    // ==========
    // STATUS
    // ==========
    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    // ==========
    // AUDIT (fonte única)
    // ==========
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    // ==========
    // SOFT DELETE
    // ==========
    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    // ==========
    // Permissões explícitas (override)
    // ==========
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
            name = "controlplane_user_permissions",
            joinColumns = @JoinColumn(name = "user_id")
    )
    @Enumerated(EnumType.STRING)
    @Column(name = "permission", length = 120, nullable = false)
    @Builder.Default
    private Set<ControlPlanePermission> explicitPermissions = new LinkedHashSet<>();

    // ==========
    // Contracts (Auditable / SoftDeletable)
    // ==========
    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // ==========
    // Rules (status)
    // ==========
    public boolean isSuspended() {
        return suspendedByAccount || suspendedByAdmin;
    }

    public boolean isEnabled() {
        return !deleted && !isSuspended();
    }

    public boolean isAccountNonLocked(Instant now) {
        if (now == null) now = Instant.now();
        return lockedUntil == null || !now.isBefore(lockedUntil);
    }

    public boolean isEnabledForLogin(Instant now) {
        return isEnabled() && isAccountNonLocked(now);
    }

    // ==========
    // Mutations
    // ==========
    public void rename(String newName) {
        if (newName == null || newName.isBlank()) {
            throw new IllegalArgumentException("name é obrigatório");
        }
        this.name = newName.trim();
    }

    public void changePasswordHash(String newPasswordHash) {
        if (newPasswordHash == null || newPasswordHash.isBlank()) {
            throw new IllegalArgumentException("password hash é obrigatório");
        }
        this.password = newPasswordHash;
    }

    public void requirePasswordChange() {
        this.mustChangePassword = true;
    }

    public void clearMustChangePassword() {
        this.mustChangePassword = false;
    }

    public void changeRole(ControlPlaneRole newRole) {
        this.role = newRole;
    }

    public void suspendByAccount() {
        this.suspendedByAccount = true;
    }

    public void unsuspendByAccount() {
        this.suspendedByAccount = false;
    }

    public void suspendByAdmin() {
        this.suspendedByAdmin = true;
    }

    public void unsuspendByAdmin() {
        this.suspendedByAdmin = false;
    }

    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        if (this.audit != null) {
            this.audit.clearDeleted();
        }
    }

    public void clearSecurityLockState() {
        this.lockedUntil = null;
    }

    public void clearPasswordResetToken() {
        this.passwordResetToken = null;
        this.passwordResetExpiresAt = null;
    }

    // ==========
    // Explicit permissions API (domínio manda)
    // ==========
    public Set<ControlPlanePermission> getExplicitPermissions() {
        return Set.copyOf(explicitPermissions);
    }

    /**
     * Alias de compat para infra legada (AuthoritiesFactory usa getPermissions()).
     */
    public Set<ControlPlanePermission> getPermissions() {
        return getExplicitPermissions();
    }

    public void grantExplicitPermission(ControlPlanePermission p) {
        PermissionScopeValidator.requireControlPlanePermission(p);
        this.explicitPermissions.add(p);
    }

    public void revokeExplicitPermission(ControlPlanePermission p) {
        this.explicitPermissions.remove(p);
    }

    public void replaceExplicitPermissions(Set<ControlPlanePermission> newPermissions) {
        this.explicitPermissions.clear();
        if (newPermissions == null || newPermissions.isEmpty()) return;

        for (ControlPlanePermission p : newPermissions) {
            PermissionScopeValidator.requireControlPlanePermission(p);
            this.explicitPermissions.add(p);
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/persistence/ControlPlaneUserRepository.java
============================================================
package brito.com.multitenancy001.controlplane.users.persistence;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlaneUserRepository extends JpaRepository<ControlPlaneUser, Long> {

    // =========================================================
    // BASICS
    // =========================================================

    Optional<ControlPlaneUser> findByEmailAndDeletedFalse(String email);

    Optional<ControlPlaneUser> findByEmailAndAccount_IdAndDeletedFalse(String email, Long accountId);

    // =========================================================
    // NOT DELETED (deleted=false) -> default do domínio
    // =========================================================

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.account.id = :accountId AND u.deleted = false")
    List<ControlPlaneUser> findNotDeletedByAccountId(@Param("accountId") Long accountId);

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.id = :id AND u.account.id = :accountId AND u.deleted = false")
    Optional<ControlPlaneUser> findNotDeletedByIdAndAccountId(@Param("id") Long id,
                                                              @Param("accountId") Long accountId);

    /**
     * Agora: usuário BUILT_IN + role CONTROLPLANE_OWNER.
     */
    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.origin = :origin
               AND u.role = :role
           """)
    Optional<ControlPlaneUser> findNotDeletedBuiltInOwner(@Param("accountId") Long accountId,
                                                         @Param("origin") EntityOrigin origin,
                                                         @Param("role") ControlPlaneRole role);

    long countByAccount_IdAndDeletedFalse(Long accountId);

    // =========================================================
    // ADMIN (para telas de Account Admin Details)
    // =========================================================

    /**
     * "Admin" aqui = primeiro usuário operacional (enabled) com role de maior privilégio
     * (OWNER > ADMIN), dentro de uma conta.
     *
     * - Retorna Optional.empty() se não houver usuário elegível.
     * - Não usa getSingleResult para evitar NonUniqueResultException.
     */
    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.suspendedByAccount = false
               AND u.suspendedByAdmin = false
               AND u.role IN ('CONTROLPLANE_OWNER', 'CONTROLPLANE_ADMIN')
             ORDER BY
               CASE WHEN u.role = 'CONTROLPLANE_OWNER' THEN 0 ELSE 1 END,
               u.id ASC
           """)
    List<ControlPlaneUser> findAdminsOrderedByPriority(@Param("accountId") Long accountId);

    default Optional<ControlPlaneUser> findFirstAdminByAccountId(Long accountId) {
        if (accountId == null) return Optional.empty();
        List<ControlPlaneUser> users = findAdminsOrderedByPriority(accountId);
        return (users == null || users.isEmpty()) ? Optional.empty() : Optional.of(users.get(0));
    }

    // =========================================================
    // ENABLED = NOT DELETED + NOT suspended -> default segurança
    // =========================================================

    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.suspendedByAccount = false
               AND u.suspendedByAdmin = false
           """)
    List<ControlPlaneUser> findEnabledByAccountId(@Param("accountId") Long accountId);

    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.id = :id
               AND u.account.id = :accountId
               AND u.deleted = false
               AND u.suspendedByAccount = false
               AND u.suspendedByAdmin = false
           """)
    Optional<ControlPlaneUser> findEnabledByIdAndAccountId(@Param("id") Long id,
                                                          @Param("accountId") Long accountId);

    // =========================================================
    // ANY = BYPASS consciente (inclui deleted) ⚠️
    // =========================================================

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.id = :id AND u.account.id = :accountId")
    Optional<ControlPlaneUser> findAnyByIdAndAccountId(@Param("id") Long id,
                                                       @Param("accountId") Long accountId);

    // =========================================================
    // UNICIDADE NOT DELETED (deleted=false)
    //
    // IMPORTANTE:
    // - A coluna email é CITEXT (case-insensitive no Postgres).
    // - Logo a comparação pode (e deve) ser direta: u.email = :email
    // - A normalização (trim/lower) deve acontecer fora (EmailNormalizer).
    // =========================================================

    @Query("""
            SELECT (COUNT(u) > 0)
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.email = :email
           """)
    boolean existsNotDeletedByEmailIgnoreCase(@Param("accountId") Long accountId,
                                              @Param("email") String email);

    @Query("""
            SELECT (COUNT(u) > 0)
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.email = :email
               AND u.id <> :userId
           """)
    boolean existsOtherNotDeletedByEmailIgnoreCase(@Param("accountId") Long accountId,
                                                   @Param("email") String email,
                                                   @Param("userId") Long userId);

    @Query("""
        select u
        from ControlPlaneUser u
        where u.id = :id
          and u.deleted = false
          and u.suspendedByAdmin = false
          and u.suspendedByAccount = false
    """)
    Optional<ControlPlaneUser> findEnabledById(@Param("id") Long id);
    
    /**
     * Default do domínio (NOT DELETED): igual AccountRepository.
     */
    Optional<ControlPlaneUser> findByIdAndDeletedFalse(Long id);
    
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/config/time/TimeConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.config.time;

import java.time.Clock;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Clock único do sistema.
 * Regra: UTC para correlação perfeita entre logs, auditoria e eventos.
 */
@Configuration
public class TimeConfig {

    @Bean
    public Clock clock() {
        return Clock.systemUTC();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.flyway.FlywayMigrationInitializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import brito.com.multitenancy001.shared.db.Schemas;

/**
 * Flyway do schema PUBLIC (Control Plane).
 *
 * ✅ Migra no bootstrap
 * ✅ Evita race com @Scheduled (use @DependsOn("flywayInitializer"))
 *
 * IMPORTANTE:
 * - bean "flyway" → usado pelo Spring Boot
 * - bean "flywayInitializer" → gatilho oficial de migração
 */
@Configuration
public class PublicFlywayConfig {

    @Bean(name = "flyway")
    public Flyway flyway(DataSource dataSource) {
        return Flyway.configure()
                .dataSource(dataSource)
                .schemas(Schemas.CONTROL_PLANE)       // "public"
                .defaultSchema(Schemas.CONTROL_PLANE)
                .locations("classpath:db/migration/accounts")
                .baselineOnMigrate(false)
                .validateOnMigrate(true)
                .cleanDisabled(true)
                .load();
    }

    @Bean(name = "flywayInitializer")
    public FlywayMigrationInitializer flywayInitializer(@Qualifier("flyway") Flyway flyway) {
        return new FlywayMigrationInitializer(flyway, null);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayRunner.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import org.flywaydb.core.Flyway;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * ⚠️ Por padrão DESLIGADO. O Flyway do PUBLIC deve rodar no bootstrap do Spring.
 * Ligue somente se você quiser forçar migração manual (não recomendado).
 */
@Component
@RequiredArgsConstructor
@Slf4j
@ConditionalOnProperty(value = "app.flyway.public.manual", havingValue = "true")
public class PublicFlywayRunner implements ApplicationRunner {

    private final Flyway flyway;

    @Override
    public void run(ApplicationArguments args) {
        log.info("⚠️ app.flyway.public.manual=true -> Executando Flyway PUBLIC manualmente (não recomendado)");
        flyway.migrate();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicSchemaVerifier.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.db.Schemas;

@Slf4j
@Component
@RequiredArgsConstructor
public class PublicSchemaVerifier {
    
    private final JdbcTemplate jdbcTemplate;
    
    @EventListener(ApplicationReadyEvent.class)
    public void verifyTables() {
        log.info("🔍 Verificando tabelas criadas pelo Flyway...");
        
        try {
            // Apenas VERIFICA, não cria
        	Integer accountsCount = jdbcTemplate.queryForObject(
        		    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = ? AND table_name = 'accounts'",
        		    Integer.class,
        		    Schemas.CONTROL_PLANE
        		);

        		Integer usersCount = jdbcTemplate.queryForObject(
        		    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = ? AND table_name = 'controlplane_users'",
        		    Integer.class,
        		    Schemas.CONTROL_PLANE
        		);    

            
            log.info("✅ Verificação OK! Tabelas encontradas: accounts={}, controlplane_users={}", accountsCount, usersCount);

        } catch (Exception e) {
            log.error("⚠️ Aviso na verificação: {}", e.getMessage());
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/flyway/tenantschema/TenantSchemaFlywayMigrationService.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.tenantschema;

import lombok.RequiredArgsConstructor;
import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;

@Service
@RequiredArgsConstructor
public class TenantSchemaFlywayMigrationService {

    private final DataSource dataSource;

    public void migrateTenantSchema(String schemaName) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas(schemaName)
                .defaultSchema(schemaName) // 🔥 ESSENCIAL
                .createSchemas(false)
                .locations("classpath:db/migration/tenants")
                .baselineOnMigrate(true)
                .load();

        flyway.migrate();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/jpa/publicschema/PublicPersistenceConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.jpa.publicschema;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Wiring de repositories do schema PUBLIC (Control Plane).
 *
 * - Usa o EntityManagerFactory default do Spring Boot (bean: "entityManagerFactory")
 * - Cria um alias semântico: "publicEntityManagerFactory"
 *
 * IMPORTANTE:
 * - Repositórios do public schema agora ficam em:
 *   - controlplane.<módulo>.persistence
 *   - infrastructure.publicschema.* (ex.: auth/TenantLoginChallengeRepository)
 *
 * Não use mais:
 * - brito.com.multitenancy001.controlplane.persistence (não existe mais)
 * - brito.com.multitenancy001.shared.persistence (não existe mais)
 */
@Configuration
@EnableJpaRepositories(
        basePackages = {
                "brito.com.multitenancy001.controlplane.accounts.persistence",
                "brito.com.multitenancy001.controlplane.users.persistence",
                "brito.com.multitenancy001.controlplane.billing.persistence",

                // ✅ necessário para encontrar AccountJobScheduleRepository
                "brito.com.multitenancy001.controlplane.scheduling.persistence",

                "brito.com.multitenancy001.infrastructure.publicschema"
        },
        entityManagerFactoryRef = "publicEntityManagerFactory",
        transactionManagerRef = "publicTransactionManager"
)
public class PublicPersistenceConfig {

    @Bean(name = "publicEntityManagerFactory")
    @Primary
    public EntityManagerFactory publicEntityManagerFactory(
            @Qualifier("entityManagerFactory") EntityManagerFactory emf
    ) {
        return emf;
    }

    @Bean(name = "publicTransactionManager")
    @Primary
    public PlatformTransactionManager publicTransactionManager(
            @Qualifier("publicEntityManagerFactory") EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/jpa/publicschema/PublicSchemaHibernateConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.jpa.publicschema;

import brito.com.multitenancy001.shared.db.Schemas;
import lombok.RequiredArgsConstructor;
import org.hibernate.cfg.AvailableSettings;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.hibernate5.SpringBeanContainer;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class PublicSchemaHibernateConfig {

    private final DataSource dataSource;
    private final ConfigurableListableBeanFactory configurableListableBeanFactory;

    /**
     * EntityManagerFactory do schema PUBLIC (Control Plane).
     *
     * Escaneia:
     * - Entidades do ControlPlane (módulo-first: controlplane.accounts/users/billing etc.)
     * - Entidades técnicas do schema public (ex.: infrastructure.publicschema.auth.TenantLoginChallenge)
     *
     * Obs: não use mais packages antigos como:
     * - brito.com.multitenancy001.controlplane.domain (não existe mais)
     * - brito.com.multitenancy001.shared.persistence (não existe mais)
     */
    @Bean(name = "entityManagerFactory")
    @Primary
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        emf.setPackagesToScan(
                "brito.com.multitenancy001.controlplane",
                "brito.com.multitenancy001.infrastructure.publicschema"
        );

        emf.setPersistenceUnitName("PUBLIC_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put(AvailableSettings.DEFAULT_SCHEMA, Schemas.CONTROL_PLANE);

        // Bean container para injeção em listeners/converters/etc
        props.put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(configurableListableBeanFactory));

        emf.setJpaPropertyMap(props);
        return emf;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/jpa/tenantschema/TenantPersistenceConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.jpa.tenantschema;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

/**
 * Wiring dos repositories do schema TENANT.
 *
 * Observação:
 * - Seus repositories agora estão em tenant.<módulo>.persistence,
 *   então escaneamos "brito.com.multitenancy001.tenant" como raiz.
 */
@Configuration
@EnableJpaRepositories(
        basePackages = "brito.com.multitenancy001.tenant",
        entityManagerFactoryRef = "tenantEntityManagerFactory",
        transactionManagerRef = "tenantTransactionManager"
)
public class TenantPersistenceConfig {
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/CurrentTenantSchemaResolver.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.extern.slf4j.Slf4j;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;

@Slf4j
@Component
public class CurrentTenantSchemaResolver implements CurrentTenantIdentifierResolver<String> {

    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    // ---------------------------------------------------------------------
    // ✅ NOVO PADRÃO (limpo, coerente)
    // ---------------------------------------------------------------------

    public static void bindSchemaToCurrentThread(String tenantSchema) {
        TenantContext.bindTenantSchema(tenantSchema);
    }

    public static String resolveBoundSchemaOrNull() {
        return TenantContext.getOrNull(); // null = PUBLIC
    }

    public static String resolveBoundSchemaOrDefault() {
        String schema = TenantContext.getOrNull();
        return (schema != null ? schema : DEFAULT_SCHEMA);
    }

    public static void unbindSchemaFromCurrentThread() {
        TenantContext.clear();
    }

    // ---------------------------------------------------------------------
    // ⚠️ COMPATIBILIDADE (NÃO USAR EM CÓDIGO NOVO)
    // ---------------------------------------------------------------------

  

 






    // ---------------------------------------------------------------------
    // Hibernate integration
    // ---------------------------------------------------------------------

    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenantSchema = TenantContext.getOrNull(); // null = public
        String resolved = (StringUtils.hasText(tenantSchema) ? tenantSchema : DEFAULT_SCHEMA);

        if (log.isDebugEnabled()) {
            log.debug("🏷️ Hibernate resolveu schema={} (bound={}, default={})",
                    resolved, tenantSchema, DEFAULT_SCHEMA);
        }
        return resolved;
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return false;
    }

    @Override
    public boolean isRoot(String tenantIdentifier) {
        return DEFAULT_SCHEMA.equals(tenantIdentifier);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TenantSchemaConnectionProvider.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;

import javax.sql.DataSource;
import java.sql.*;

@Slf4j
@Component
@RequiredArgsConstructor
public class TenantSchemaConnectionProvider
        extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String> {

    private static final long serialVersionUID = 1L;

    /**
     * ✅ Default/root = Control Plane (hoje: "public")
     */
    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    private final DataSource dataSource;

    @Override
    protected DataSource selectAnyDataSource() {
        return dataSource;
    }

    @Override
    protected DataSource selectDataSource(String tenantIdentifier) {
        return dataSource;
    }

    @Override
    public Connection getConnection(String tenantIdentifier) throws SQLException {

        long threadId = Thread.currentThread().threadId();

        // ✅ TenantContext guarda tenantSchema (null = PUBLIC). Aqui nunca devolve null.
        String threadTenantSchema = TenantContext.getOrDefaultPublic();

        // ✅ Hibernate pode passar vazio/null no root/public — isso é normal.
        String effectiveTenantSchema = StringUtils.hasText(tenantIdentifier)
                ? tenantIdentifier.trim()
                : DEFAULT_SCHEMA;

        // ✅ Log inteligente:
        // - tenantIdentifier vazio é NORMAL no root/public → DEBUG
        // - WARN só quando há divergência real entre tenantParam e tenantThread
        if (!StringUtils.hasText(tenantIdentifier)) {
            if (log.isDebugEnabled()) {
                log.debug("🏠 [MT] tenantParam vazio → usando DEFAULT ({}) | thread={} | tenantSchemaThread={}",
                        DEFAULT_SCHEMA, threadId, threadTenantSchema);
            }
        } else if (!effectiveTenantSchema.equals(threadTenantSchema)) {
            log.warn("⚠️ [MT] mismatch tenantSchemaParam vs tenantSchemaThread | thread={} | tenantSchemaParam={} | tenantSchemaThread={}",
                    threadId, effectiveTenantSchema, threadTenantSchema);
        }

        validateSchemaName(effectiveTenantSchema);

        Connection connection = dataSource.getConnection();

        try (Statement stmt = connection.createStatement()) {

            if (!DEFAULT_SCHEMA.equals(effectiveTenantSchema)) {
                ensureSchemaExists(connection, effectiveTenantSchema);

                String quotedTenant = quoteIdentifier(effectiveTenantSchema);
                String quotedDefault = quoteIdentifier(DEFAULT_SCHEMA);

                String setSearchPath = "SET search_path TO " + quotedTenant + ", " + quotedDefault;
                log.info("🎯 [MT] getConnection | thread={} | tenantSchemaParam={} | tenantSchemaThread={} | SQL={}",
                        threadId, effectiveTenantSchema, threadTenantSchema, setSearchPath);

                stmt.execute(setSearchPath);

            } else {
                String quotedDefault = quoteIdentifier(DEFAULT_SCHEMA);

                String setSearchPath = "SET search_path TO " + quotedDefault + ";";
                log.info("🏠 [MT] getConnection | thread={} | tenantSchemaParam={} | tenantSchemaThread={} | SQL={}",
                        threadId, effectiveTenantSchema, threadTenantSchema, setSearchPath);

                stmt.execute(setSearchPath);
            }

            return connection;

        } catch (SQLException e) {
            log.error("❌ [MT] Erro configurando conexão | effectiveTenantSchema={}", effectiveTenantSchema, e);
            try { connection.close(); } catch (SQLException ignore) {}
            throw e;
        }
    }

    @Override
    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
        long threadId = Thread.currentThread().threadId();

        if (connection == null) {
            if (log.isDebugEnabled()) {
                log.debug("🧹 [MT] releaseConnection ignorado (connection=null) | thread={} | tenantSchemaParam={}",
                        threadId, tenantIdentifier);
            }
            return;
        }

        if (connection.isClosed()) {
            if (log.isDebugEnabled()) {
                log.debug("🧹 [MT] releaseConnection ignorado (connection já fechada) | thread={} | tenantSchemaParam={}",
                        threadId, tenantIdentifier);
            }
            return;
        }

        try (Statement stmt = connection.createStatement()) {
            String resetSearchPath = "SET search_path TO " + quoteIdentifier(DEFAULT_SCHEMA) + ";";

            if (log.isDebugEnabled()) {
                log.debug("🧹 [MT] releaseConnection | thread={} | tenantSchemaParam={} | SQL={}",
                        threadId, tenantIdentifier, resetSearchPath);
            }

            stmt.execute(resetSearchPath);

        } catch (SQLException e) {
            log.warn("⚠️ [MT] Falha ao resetar search_path no releaseConnection | thread={} | tenantSchemaParam={}",
                    threadId, tenantIdentifier, e);
        } finally {
            connection.close();

            if (log.isDebugEnabled()) {
                log.debug("🔒 [MT] conexão fechada | thread={} | tenantSchemaParam={}", threadId, tenantIdentifier);
            }
        }
    }

    private void ensureSchemaExists(Connection connection, String schemaName) throws SQLException {
        String quotedSchema = quoteIdentifier(schemaName);

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE SCHEMA IF NOT EXISTS " + quotedSchema);
        }

        try (PreparedStatement ps = connection.prepareStatement(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = ?")) {
            ps.setString(1, schemaName);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    throw new SQLException("Schema " + schemaName + " não encontrado após CREATE");
                }
            }
        }
    }

    private void validateSchemaName(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new IllegalArgumentException("schemaName vazio");
        }
        if (!schemaName.matches("[A-Za-z_][A-Za-z0-9_]*")) {
            throw new IllegalArgumentException("schemaName inválido: " + schemaName);
        }
    }

    private String quoteIdentifier(String identifier) {
        // Mantive simples igual ao seu, pois você já valida o regex seguro.
        return "\"" + identifier + "\"";
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TenantSchemaHibernateConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import org.hibernate.cfg.AvailableSettings;
import org.hibernate.cfg.MultiTenancySettings;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.hibernate5.SpringBeanContainer;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class TenantSchemaHibernateConfig {

    private final DataSource dataSource;
    private final TenantSchemaConnectionProvider tenantSchemaConnectionProvider;
    private final CurrentTenantSchemaResolver currentTenantSchemaResolver;
    private final ConfigurableListableBeanFactory configurableListableBeanFactory;

    @Bean(name = "tenantEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        /**
         * Entidades do TENANT (módulo-first: tenant.users/products/categories/etc.)
         *
         * Obs: não use mais "brito.com.multitenancy001.tenant.domain" (não existe mais).
         */
        emf.setPackagesToScan("brito.com.multitenancy001.tenant");

        emf.setPersistenceUnitName("TENANT_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);

        // ✅ Multi-tenancy por schema (strategy)
        props.put("hibernate.multiTenancy", "SCHEMA");

        // ✅ Provider/Resolver
        props.put(MultiTenancySettings.MULTI_TENANT_CONNECTION_PROVIDER, tenantSchemaConnectionProvider);
        props.put(MultiTenancySettings.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantSchemaResolver);

        // ✅ Hibernate resolve beans do Spring (EntityListeners @Component etc.)
        props.put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(configurableListableBeanFactory));

        emf.setJpaPropertyMap(props);
        return emf;
    }

    @Bean(name = "tenantTransactionManager")
    public PlatformTransactionManager tenantTransactionManager(
            @Qualifier("tenantEntityManagerFactory") jakarta.persistence.EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TransactionManagementConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
public class TransactionManagementConfig {
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/observability/TenantContextMonitor.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.observability;

import brito.com.multitenancy001.shared.context.TenantContext;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

@Aspect
@Component
@Slf4j
public class TenantContextMonitor {

    @Around("@within(org.springframework.stereotype.Service)")
    public Object monitorServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();

        String boundTenant = TenantContext.getOrNull();               // null ou tenant real
        String effectiveTenant = TenantContext.getOrDefaultPublic();  // tenant ou public/controlplane

        log.debug("🏁 INÍCIO {} - Tenant(bound={}, effective={})", methodName, boundTenant, effectiveTenant);

        try {
            Object result = joinPoint.proceed();

            String boundAfter = TenantContext.getOrNull();
            String effectiveAfter = TenantContext.getOrDefaultPublic();

            log.debug("✅ FIM {} - Tenant(bound={}, effective={})", methodName, boundAfter, effectiveAfter);
            return result;

        } catch (Throwable e) {

            // ✅ Login inválido = fluxo normal (não é erro do sistema)
            if (isInvalidLogin(e)) {
                log.info("🔐 AUTH inválida {} - Tenant(bound={}, effective={}) - {}",
                        methodName, boundTenant, effectiveTenant, safeMsg(e));
                throw e;
            }

            // ❌ Erro real
            log.error("❌ ERRO {} - Tenant(bound={}, effective={}) - Erro: {}",
                    methodName, boundTenant, effectiveTenant, safeMsg(e), e);
            throw e;
        }
    }

    private boolean isInvalidLogin(Throwable ex) {
        if (ex == null) return false;

        // Spring Security (senha errada / user inexistente após map)
        if (ex instanceof BadCredentialsException) return true;

        // user inexistente no UserDetailsService
        if (ex instanceof UsernameNotFoundException unf) {
            return "INVALID_USER".equalsIgnoreCase(unf.getMessage());
        }

        // encadeado (muito comum virem wrapped)
        Throwable cause = ex.getCause();
        if (cause != null && cause != ex) return isInvalidLogin(cause);

        return false;
    }

    private String safeMsg(Throwable ex) {
        String msg = ex.getMessage();
        return (msg != null && !msg.isBlank()) ? msg : ex.getClass().getSimpleName();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/openapi/OpenApiConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.openapi;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;

import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    public static final String SECURITY_SCHEME_NAME = "bearerAuth";

    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("Multitenancy001 API")
                .description("ControlPlane / Tenant APIs")
                .version("v1"))
            .addSecurityItem(new SecurityRequirement().addList(SECURITY_SCHEME_NAME))
            .components(new Components()
                .addSecuritySchemes(SECURITY_SCHEME_NAME,
                    new SecurityScheme()
                        .type(SecurityScheme.Type.HTTP)
                        .scheme("bearer")
                        .bearerFormat("JWT")
                )
            );
    }




@Bean
public GroupedOpenApi adminApi() {
    return GroupedOpenApi.builder()
        .group("admin")
        .pathsToMatch("/api/admin/**")
        .build();
}

@Bean
public GroupedOpenApi controlPlaneApi() {
    return GroupedOpenApi.builder()
        .group("controlplane")
        .pathsToMatch("/api/controlplane/**")
        .build();
}

@Bean
public GroupedOpenApi tenantApi() {
    return GroupedOpenApi.builder()
        .group("tenant")
        .pathsToMatch("/api/tenant/**", "/api/me/**")
        .build();
}

@Bean
public GroupedOpenApi publicApi() {
    return GroupedOpenApi.builder()
        .group("public")
        .pathsToMatch("/api/signup", "/api/accounts/auth/**")
        .build();
}

}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/TransactionExecutor.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence;

import java.util.function.Supplier;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

@Component
public class TransactionExecutor {

    private final TransactionTemplate transactionTemplatePublicTx;
    private final TransactionTemplate transactionTemplatePublicRequiresNew;

    private final TransactionTemplate transactionTemplatePublicReadOnlyTx;
    private final TransactionTemplate transactionTemplatePublicRequiresNewReadOnly;

    private final TransactionTemplate transactionTemplateTenantTx;
    private final TransactionTemplate transactionTemplateTenantRequiresNew;

    private final TransactionTemplate transactionTemplateTenantReadOnlyTx;
    private final TransactionTemplate transactionTemplateTenantRequiresNewReadOnly;

    public TransactionExecutor(
            @Qualifier("publicTransactionManager") PlatformTransactionManager publicTm,
            @Qualifier("tenantTransactionManager") PlatformTransactionManager tenantTm
    ) {
        // PUBLIC - REQUIRED
        this.transactionTemplatePublicTx = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // PUBLIC - REQUIRES_NEW
        this.transactionTemplatePublicRequiresNew = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // PUBLIC - REQUIRED READONLY
        this.transactionTemplatePublicReadOnlyTx = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.transactionTemplatePublicReadOnlyTx.setReadOnly(true);

        // PUBLIC - REQUIRES_NEW READONLY
        this.transactionTemplatePublicRequiresNewReadOnly = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.transactionTemplatePublicRequiresNewReadOnly.setReadOnly(true);

        // TENANT - REQUIRED
        this.transactionTemplateTenantTx = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // TENANT - REQUIRES_NEW
        this.transactionTemplateTenantRequiresNew = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // TENANT - REQUIRED READONLY
        this.transactionTemplateTenantReadOnlyTx = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.transactionTemplateTenantReadOnlyTx.setReadOnly(true);

        // TENANT - REQUIRES_NEW READONLY
        this.transactionTemplateTenantRequiresNewReadOnly = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.transactionTemplateTenantRequiresNewReadOnly.setReadOnly(true);
    }

    // ---------- PUBLIC ----------
    public <T> T inPublicTx(Supplier<T> fn) {
        return transactionTemplatePublicTx.execute(status -> fn.get());
    }
    public void inPublicTx(Runnable fn) {
        transactionTemplatePublicTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T inPublicRequiresNew(Supplier<T> fn) {
        return transactionTemplatePublicRequiresNew.execute(status -> fn.get());
    }
    public void inPublicRequiresNew(Runnable fn) {
        transactionTemplatePublicRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T inPublicReadOnlyTx(Supplier<T> fn) {
        return transactionTemplatePublicReadOnlyTx.execute(status -> fn.get());
    }
    public void inPublicReadOnlyTx(Runnable fn) {
        transactionTemplatePublicReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T inPublicRequiresNewReadOnly(Supplier<T> fn) {
        return transactionTemplatePublicRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void inPublicRequiresNewReadOnly(Runnable fn) {
        transactionTemplatePublicRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }

    // ---------- TENANT ----------
    public <T> T inTenantTx(Supplier<T> fn) {
        return transactionTemplateTenantTx.execute(status -> fn.get());
    }
    public void inTenantTx(Runnable fn) {
        transactionTemplateTenantTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T inTenantRequiresNew(Supplier<T> fn) {
        return transactionTemplateTenantRequiresNew.execute(status -> fn.get());
    }
    public void inTenantRequiresNew(Runnable fn) {
        transactionTemplateTenantRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T inTenantReadOnlyTx(Supplier<T> fn) {
        return transactionTemplateTenantReadOnlyTx.execute(status -> fn.get());
    }
    public void inTenantReadOnlyTx(Runnable fn) {
        transactionTemplateTenantReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T inTenantRequiresNewReadOnly(Supplier<T> fn) {
        return transactionTemplateTenantRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void inTenantRequiresNewReadOnly(Runnable fn) {
        transactionTemplateTenantRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEvent.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(name = "auth_events")
public class AuthEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "occurred_at", nullable = false)
    private Instant occurredAt;

    @Column(name = "request_id")
    private UUID requestId;

    @Column(name = "method")
    private String method;

    @Column(name = "uri")
    private String uri;

    @Column(name = "ip")
    private String ip;

    @Column(name = "user_agent")
    private String userAgent;

    @Column(name = "auth_domain")
    private String authDomain;

    @Column(name = "event_type", nullable = false)
    private String eventType;

    @Column(name = "outcome", nullable = false)
    private String outcome;

    @Column(name = "principal_email")
    private String principalEmail;

    @Column(name = "principal_user_id")
    private Long principalUserId;

    @Column(name = "account_id")
    private Long accountId;

    @Column(name = "tenant_schema")
    private String tenantSchema;

    @Column(name = "details", columnDefinition = "jsonb")
    private String detailsJson;
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEventRepository.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import org.springframework.data.jpa.repository.JpaRepository;

public interface AuthEventRepository extends JpaRepository<AuthEvent, Long> {
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditEvent.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(name = "security_audit_events")
public class SecurityAuditEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "occurred_at", nullable = false)
    private Instant occurredAt;

    @Column(name = "request_id")
    private UUID requestId;

    @Column(name = "method")
    private String method;

    @Column(name = "uri")
    private String uri;

    @Column(name = "ip")
    private String ip;

    @Column(name = "user_agent")
    private String userAgent;

    @Column(name = "action_type", nullable = false)
    private String actionType;

    @Column(name = "outcome", nullable = false)
    private String outcome;

    @Column(name = "actor_email")
    private String actorEmail;

    @Column(name = "actor_user_id")
    private Long actorUserId;

    @Column(name = "target_email")
    private String targetEmail;

    @Column(name = "target_user_id")
    private Long targetUserId;

    @Column(name = "account_id")
    private Long accountId;

    @Column(name = "tenant_schema")
    private String tenantSchema;

    @Column(name = "details", columnDefinition = "jsonb")
    private String detailsJson;
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditEventRepository.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import org.springframework.data.jpa.repository.JpaRepository;

public interface SecurityAuditEventRepository extends JpaRepository<SecurityAuditEvent, Long> {
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallenge.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

@Entity
@Table(name = "tenant_login_challenges", schema = "public")
@Getter
@Setter
public class TenantLoginChallenge {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", updatable = false, nullable = false)
    private UUID id;

    // migration: CITEXT (recomendado explicitar)
    @Column(name = "email", nullable = false, columnDefinition = "citext")
    private String email;

    @Column(name = "candidate_account_ids_csv", nullable = false, columnDefinition = "text")
    private String candidateAccountIdsCsv;

    @Column(name = "created_at", nullable = false, columnDefinition = "timestamptz")
    private Instant createdAt;

    @Column(name = "expires_at", nullable = false, columnDefinition = "timestamptz")
    private Instant expiresAt;

    @Column(name = "used_at", columnDefinition = "timestamptz")
    private Instant usedAt;

    @PrePersist
    private void prePersist() {
        if (this.id == null) this.id = UUID.randomUUID();
        if (this.createdAt == null) this.createdAt = Instant.now();
        if (this.candidateAccountIdsCsv == null) this.candidateAccountIdsCsv = "";
        if (this.email != null) this.email = this.email.trim();
    }

    public Set<Long> candidateAccountIds() {
        if (candidateAccountIdsCsv == null || candidateAccountIdsCsv.isBlank()) return Set.of();

        return Arrays.stream(candidateAccountIdsCsv.split(","))
                .map(String::trim)
                .filter(s -> !s.isBlank())
                .map(Long::valueOf)
                .collect(Collectors.toCollection(LinkedHashSet::new));
    }

    public void setCandidateAccountIds(Set<Long> ids) {
        if (ids == null || ids.isEmpty()) {
            this.candidateAccountIdsCsv = "";
            return;
        }
        this.candidateAccountIdsCsv = ids.stream()
                .filter(Objects::nonNull)
                .distinct()
                .sorted()
                .map(String::valueOf)
                .collect(Collectors.joining(","));
    }

    public boolean isUsed() {
        return usedAt != null;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallengeRepository.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import org.springframework.data.jpa.repository.JpaRepository;

import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

public interface TenantLoginChallengeRepository extends JpaRepository<TenantLoginChallenge, UUID> {

    Optional<TenantLoginChallenge> findByIdAndExpiresAtAfterAndUsedAtIsNull(UUID id, Instant now);
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/AuthenticatedUserContext.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.security.AuthenticatedPrincipal;
import brito.com.multitenancy001.shared.security.RoleAuthority;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;

import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.Instant;
import java.util.Collection;

/**
 * Principal autenticado usado pelo Spring Security.
 *
 * Observação importante:
 * - O método do contrato UserDetails se chama getUsername().
 * - No nosso domínio, login é por email.
 * - Por isso, aqui guardamos o principal como principalEmail e
 *   implementamos getUsername() retornando esse email.
 */
public class AuthenticatedUserContext implements UserDetails, AuthenticatedPrincipal {

    private static final long serialVersionUID = 1L;

    private final Long userId;

    /** Email usado como principal (UserDetails#getUsername). */
    private final String principalEmail;

    private final String name;
    private final String email;

    private final String password;
    private final boolean mustChangePassword;

    private final boolean enabled;
    private final boolean accountNonLocked;

    private final Long accountId;
    private final String schemaName;

    private final boolean suspendedByAccount;
    private final boolean suspendedByAdmin;
    private final boolean deleted;

    private final RoleAuthority roleAuthority;

    private final Collection<? extends GrantedAuthority> authorities;

    private AuthenticatedUserContext(
            Long userId,
            String principalEmail,
            String name,
            String email,
            String password,
            boolean mustChangePassword,
            boolean enabled,
            boolean accountNonLocked,
            Long accountId,
            String schemaName,
            boolean suspendedByAccount,
            boolean suspendedByAdmin,
            boolean deleted,
            RoleAuthority roleAuthority,
            Collection<? extends GrantedAuthority> authorities
    ) {
        this.userId = userId;
        this.principalEmail = principalEmail;
        this.name = name;
        this.email = email;
        this.password = password;
        this.mustChangePassword = mustChangePassword;
        this.enabled = enabled;
        this.accountNonLocked = accountNonLocked;
        this.accountId = accountId;
        this.schemaName = schemaName;
        this.suspendedByAccount = suspendedByAccount;
        this.suspendedByAdmin = suspendedByAdmin;
        this.deleted = deleted;
        this.roleAuthority = roleAuthority;
        this.authorities = authorities;
    }

    @Override
    public Long getUserId() {
        return userId;
    }

    public String getName() {
        return name;
    }

    /**
     * Email principal usado para autenticação (mesmo valor de getUsername()).
     * Exposto por clareza.
     */
    public String getPrincipalEmail() {
        return principalEmail;
    }

    /**
     * Contrato do AuthenticatedPrincipal.
     */
    @Override
    public String getEmail() {
        return email;
    }

    public boolean isMustChangePassword() {
        return mustChangePassword;
    }

    public Long getAccountId() {
        return accountId;
    }

    public String getSchemaName() {
        return schemaName;
    }

    public boolean isSuspendedByAccount() {
        return suspendedByAccount;
    }

    public boolean isSuspendedByAdmin() {
        return suspendedByAdmin;
    }

    public boolean isDeleted() {
        return deleted;
    }

    public RoleAuthority getRoleAuthorityEnum() {
        return roleAuthority;
    }

    public String getRoleAuthority() {
        return roleAuthority == null ? null : roleAuthority.asAuthority();
    }

    public String getRoleName() {
        return roleAuthority == null ? null : roleAuthority.toString();
    }

    /** Compat com código antigo que chamava getRole() */
    public String getRole() {
        return getRoleName();
    }

    public static AuthenticatedUserContext fromTenantUser(
            TenantUser user,
            String tenantSchema,
            Instant now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        String email = user.getEmail();

        if (!user.isEnabledForLogin(now)) {
            throw new BadCredentialsException("USER_DISABLED");
        }

        return new AuthenticatedUserContext(
                user.getId(),
                email,
                user.getName(),
                email,
                user.getPassword(),
                user.isMustChangePassword(),
                user.isEnabled(),
                user.isAccountNonLocked(now),
                user.getAccountId(),
                tenantSchema,
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.isDeleted(),
                user.getRole(),
                authorities
        );
    }

    public static AuthenticatedUserContext fromControlPlaneUser(
            ControlPlaneUser user,
            String tenantSchema,
            Instant now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        String email = user.getEmail();

        if (!user.isEnabledForLogin(now)) {
            throw new BadCredentialsException("USER_DISABLED");
        }

        return new AuthenticatedUserContext(
                user.getId(),
                email,
                user.getName(),
                email,
                user.getPassword(),
                user.isMustChangePassword(),
                user.isEnabled(),
                user.isAccountNonLocked(now),
                user.getAccount().getId(),
                tenantSchema,
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.isDeleted(),
                user.getRole(),
                authorities
        );
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    /**
     * Contrato do Spring Security. No nosso sistema, isso é SEMPRE o email.
     */
    @Override
    public String getUsername() {
        return principalEmail;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityConstants.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

/**
 * Constantes de segurança (infra).
 * Mantém strings de domínios e rotas em um só lugar.
 */
public final class SecurityConstants {

    private SecurityConstants() {}

    public static final class AuthDomains {
        private AuthDomains() {}
        public static final String TENANT = "TENANT";
        public static final String CONTROLPLANE = "CONTROLPLANE";
        public static final String REFRESH = "REFRESH";
    }

    public static final class ApiPaths {
        private ApiPaths() {}

        public static final String ADMIN_PREFIX = "/api/admin/";
        public static final String CONTROLPLANE_PREFIX = "/api/controlplane/";
        public static final String TENANT_PREFIX = "/api/tenant/";

        // ✅ TENANT "me" fora do prefixo /api/tenant
        public static final String ME = "/api/me";
        public static final String ME_PREFIX = "/api/me/";
    }
    


}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityUtils.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.security.TenantRole;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

@Component
public class SecurityUtils {

    public Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getUserId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }

    public Long getCurrentAccountId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getAccountId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }

    public String getCurrentSchema() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getSchemaName();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }

    public String getCurrentEmail() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getEmail();
        }
        return authentication != null ? authentication.getName() : null;
    }

    public String getCurrentRoleAuthority() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getRoleAuthority(); // ex: "ROLE_TENANT_OWNER" ou "ROLE_CONTROLPLANE_OWNER"
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }

    /**
     * Extrai o nome da role de um authority no formato "ROLE_XYZ".
     */
    private String extractRoleName(String roleAuthority) {
        if (roleAuthority == null || roleAuthority.isBlank() || !roleAuthority.startsWith("ROLE_")) {
            throw new ApiException("FORBIDDEN", "Role inválida no contexto", 403);
        }
        return roleAuthority.substring("ROLE_".length()).trim();
    }

    /**
     * Role do tenant (ex.: TENANT_OWNER).
     */
    public TenantRole getCurrentTenantRole() {
        String roleName = extractRoleName(getCurrentRoleAuthority());
        try {
            return TenantRole.valueOf(roleName);
        } catch (IllegalArgumentException e) {
            throw new ApiException("FORBIDDEN", "Role de tenant não reconhecida: " + roleName, 403);
        }
    }

    /**
     * Role do control plane (ex.: CONTROLPLANE_OWNER).
     */
    public ControlPlaneRole getCurrentControlPlaneRole() {
        String roleName = extractRoleName(getCurrentRoleAuthority());
        try {
            return ControlPlaneRole.valueOf(roleName);
        } catch (IllegalArgumentException e) {
            throw new ApiException("FORBIDDEN", "Role de control plane não reconhecida: " + roleName, 403);
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/authorities/AuthoritiesFactory.java
============================================================
package brito.com.multitenancy001.infrastructure.security.authorities;

import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRolePermissions;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;

public final class AuthoritiesFactory {

    private AuthoritiesFactory() {}

    public static Set<GrantedAuthority> forControlPlane(ControlPlaneUser user) {
        Set<String> merged = new LinkedHashSet<>();

        for (ControlPlanePermission p : ControlPlaneRolePermissions.permissionsFor(user.getRole())) {
            merged.add(p.name());
        }

        if (user.getPermissions() != null) {
            for (ControlPlanePermission p : user.getPermissions()) {
                if (p == null) continue;
                merged.add(p.name());
            }
        }

        merged = PermissionScopeValidator.normalizeControlPlaneStrict(merged);

        Set<GrantedAuthority> authorities = new LinkedHashSet<>();
        for (String perm : merged) {
            if (perm == null || perm.isBlank()) continue;
            authorities.add(new SimpleGrantedAuthority(perm.trim().toUpperCase(Locale.ROOT)));
        }
        return authorities;
    }

    public static Set<GrantedAuthority> forTenant(TenantUser user) {
        Set<String> merged = new LinkedHashSet<>();

        // defaults por role
        if (user.getRole() != null) {
            for (TenantPermission p : TenantRolePermissions.permissionsFor(user.getRole())) {
                merged.add(p.name());
            }
        }

        // permissions explícitas do banco (JÁ É String code)
        if (user.getPermissions() != null) {
            for (String code : user.getPermissions()) {
                if (code == null || code.isBlank()) continue;
                merged.add(code.trim().toUpperCase(Locale.ROOT));
            }
        }

        merged = PermissionScopeValidator.normalizeTenantStrict(merged);

        Set<GrantedAuthority> authorities = new LinkedHashSet<>();
        for (String perm : merged) {
            if (perm == null || perm.isBlank()) continue;
            authorities.add(new SimpleGrantedAuthority(perm.trim().toUpperCase(Locale.ROOT)));
        }
        return authorities;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/config/RestAccessDeniedHandler.java
============================================================
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.shared.api.error.ApiEnumErrorResponse;
import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class RestAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper objectMapper;
    private final AppClock appClock;

    @Override
    public void handle(
            HttpServletRequest request,
            HttpServletResponse response,
            AccessDeniedException accessDeniedException
    ) throws IOException, ServletException {

        String message = resolveMessage(accessDeniedException);

        ApiEnumErrorResponse body = ApiEnumErrorResponse.builder()
                .timestamp(appClock.instant())
                .error("FORBIDDEN")
                .message(message)     // ✅ agora devolve a mensagem real quando existir
                .details(null)
                .build();

        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");

        response.getWriter().write(objectMapper.writeValueAsString(body));
    }

    private String resolveMessage(AccessDeniedException ex) {
        if (ex == null) return "Acesso negado";
        String msg = ex.getMessage();
        if (msg == null) return "Acesso negado";
        msg = msg.trim();
        return msg.isEmpty() ? "Acesso negado" : msg;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/config/RestAuthenticationEntryPoint.java
============================================================
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.shared.api.error.ApiEnumErrorResponse;
import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper objectMapper;
    private final AppClock appClock;

    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException {

        ApiEnumErrorResponse body = ApiEnumErrorResponse.builder()
                .timestamp(appClock.instant())
                .error("UNAUTHORIZED")
                .message("Não autenticado ou token inválido")
                .details(null)
                .build();

        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");

        response.getWriter().write(objectMapper.writeValueAsString(body));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/config/SecurityConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.infrastructure.security.filter.JwtAuthenticationFilter;
import brito.com.multitenancy001.infrastructure.security.filter.MustChangePasswordFilter;
import brito.com.multitenancy001.infrastructure.security.filter.RequestLoggingFilter;
import brito.com.multitenancy001.infrastructure.security.filter.RequestMetaContextFilter;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;

import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtTokenProvider jwtTokenProvider;
    private final MultiContextUserDetailsService multiContextUserDetailsService;

    private final RestAuthenticationEntryPoint restAuthenticationEntryPoint;
    private final RestAccessDeniedHandler restAccessDeniedHandler;

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter(
                jwtTokenProvider,
                multiContextUserDetailsService,
                restAuthenticationEntryPoint,
                restAccessDeniedHandler
        );
    }

    @Bean
    public MustChangePasswordFilter mustChangePasswordFilter() {
        return new MustChangePasswordFilter();
    }

    @Bean
    public RequestMetaContextFilter requestMetaContextFilter() {
        return new RequestMetaContextFilter();
    }

    @Bean
    public RequestLoggingFilter requestLoggingFilter() {
        return new RequestLoggingFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())

            // ✅ CORS (opcional, mas recomendado) + X-Request-Id
            .cors(cors -> cors.configurationSource(request -> {
                CorsConfiguration config = new CorsConfiguration();

                // ajuste conforme seu front
                config.setAllowedOriginPatterns(List.of(
                        "http://localhost:*",
                        "http://127.0.0.1:*"
                ));

                config.setAllowedMethods(List.of("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));

                // ✅ permite o cliente enviar X-Request-Id + X-Tenant
                config.setAllowedHeaders(List.of(
                        "Authorization",
                        "Content-Type",
                        "Accept",
                        "X-Request-Id",
                        "X-Tenant"
                ));

                // ✅ expõe X-Request-Id para leitura no front
                config.setExposedHeaders(List.of(
                        "Authorization",
                        "X-Request-Id"
                ));

                config.setAllowCredentials(true);
                config.setMaxAge(3600L);
                return config;
            }))

            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .exceptionHandling(ex -> ex
                    .authenticationEntryPoint(restAuthenticationEntryPoint) // 401
                    .accessDeniedHandler(restAccessDeniedHandler)           // 403
            )
            .authorizeHttpRequests(authz -> authz
                .requestMatchers(
                    "/v3/api-docs/**",
                    "/swagger-ui.html",
                    "/swagger-ui/**",
                    "/actuator/health",
                    "/api/admin/auth/login",
                    "/api/admin/auth/refresh",
                    "/api/tenant/auth/login",
                    "/api/tenant/auth/login/confirm",
                    "/api/tenant/auth/refresh",
                    "/api/tenant/password/forgot",
                    "/api/tenant/password/reset",
                    "/api/accounts/auth/checkuser",
                    "/api/signup"
                ).permitAll()

                .requestMatchers("/api/admin/me/password").authenticated()
                .requestMatchers("/api/me/**").authenticated()

                .requestMatchers("/api/admin/**").authenticated()
                .requestMatchers("/api/controlplane/**").authenticated()
                .requestMatchers("/api/tenant/**").authenticated()

                .anyRequest().denyAll()
            );

        // ✅ 1) meta primeiro (requestId/ip/ua) + cleanup centralizado
        http.addFilterBefore(requestMetaContextFilter(), UsernamePasswordAuthenticationFilter.class);

        // ✅ 2) JWT cedo
        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

        // ✅ 3) política de senha
        http.addFilterAfter(mustChangePasswordFilter(), JwtAuthenticationFilter.class);

        // ✅ 4) log final do request
        http.addFilterAfter(requestLoggingFilter(), MustChangePasswordFilter.class);

        return http.build();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/JwtAuthenticationFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.SecurityConstants;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final String TENANT_HEADER = "X-Tenant";

    private final JwtTokenProvider jwtTokenProvider;
    private final MultiContextUserDetailsService multiContextUserDetailsService;
    private final AuthenticationEntryPoint authenticationEntryPoint; // 401
    private final AccessDeniedHandler accessDeniedHandler;           // 403

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest req,
            @NonNull HttpServletResponse res,
            @NonNull FilterChain chain
    ) throws ServletException, IOException {

        final String authHeader = req.getHeader("Authorization");

        // Sem Bearer: deixa o Spring decidir (permitAll passa; protegido vira 401 via entryPoint global)
        if (!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
            chain.doFilter(req, res);
            return;
        }

        final String jwt = authHeader.substring(7).trim();
        if (!StringUtils.hasText(jwt)) {
            authenticationEntryPoint.commence(req, res, new BadCredentialsException("Missing JWT token"));
            return;
        }

        // Token inválido/adulterado/expirado => 401 (sem stacktrace)
        if (!jwtTokenProvider.validateToken(jwt)) {
            authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT token"));
            return;
        }

        final String authDomain = normalizeLower(jwtTokenProvider.getAuthDomain(jwt));
        final String email = normalizeLower(jwtTokenProvider.getEmailFromToken(jwt));

        if (!StringUtils.hasText(email)) {
            authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (email)"));
            return;
        }

        // Se já tem auth no contexto, segue
        if (SecurityContextHolder.getContext().getAuthentication() != null) {
            chain.doFilter(req, res);
            return;
        }

        // NORMALIZA authDomain (se vier vazio, isso é token ruim => 401)
        if (!StringUtils.hasText(authDomain)) {
            SecurityContextHolder.clearContext();
            authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (authDomain)"));
            return;
        }

        // ======================
        // Regras de domínio por rota
        // ======================
        boolean needsControlPlane = requiresControlPlane(req);
        boolean needsTenant = requiresTenant(req);

        if (needsControlPlane && "tenant".equals(authDomain)) {
            // ✅ 403 DIRETO: não lança exception (senão vaza pro dispatcherServlet)
            accessDeniedHandler.handle(req, res,
                    new org.springframework.security.access.AccessDeniedException("Tenant token cannot access control plane routes"));
            return;
        }

        if (needsTenant && "controlplane".equals(authDomain)) {
            // ✅ 403 DIRETO
            accessDeniedHandler.handle(req, res,
                    new org.springframework.security.access.AccessDeniedException("Control plane token cannot access tenant routes"));
            return;
        }

        // ======================
        // TENANT
        // ======================
        if ("tenant".equals(authDomain)) {

            final String tenantSchema = normalize(jwtTokenProvider.getTenantSchemaFromToken(jwt));
            if (!StringUtils.hasText(tenantSchema)) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (tenantSchema)"));
                return;
            }
            if (Schemas.CONTROL_PLANE.equalsIgnoreCase(tenantSchema)) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid tenant schema"));
                return;
            }
            if (!tenantSchema.matches("^[a-zA-Z0-9_]+$")) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid tenant schema format"));
                return;
            }

            Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
            if (accountId == null) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (accountId)"));
                return;
            }

            // ✅ mismatch do header TEM que ser 403
            final String headerTenant = normalize(req.getHeader(TENANT_HEADER));
            if (StringUtils.hasText(headerTenant) && !headerTenant.equalsIgnoreCase(tenantSchema)) {
                accessDeniedHandler.handle(req, res,
                        new org.springframework.security.access.AccessDeniedException("X-Tenant header does not match token tenant"));
                return;
            }

            // ✅ Bind tenant por TODA a request (daqui pra frente)
            try (TenantContext.Scope ignored = TenantContext.scope(tenantSchema)) {
                UserDetails userDetails = multiContextUserDetailsService.loadTenantUserByEmail(email, accountId);
                setAuth(req, userDetails);
                chain.doFilter(req, res);
                return;
            } catch (Exception e) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid authentication context"));
                return;
            }
        }

        // ======================
        // CONTROLPLANE
        // ======================
        if ("controlplane".equals(authDomain)) {

            String context = normalize(jwtTokenProvider.getContextFromToken(jwt));
            if (StringUtils.hasText(context) && !Schemas.CONTROL_PLANE.equalsIgnoreCase(context)) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (context)"));
                return;
            }

            Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
            if (accountId == null) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (accountId)"));
                return;
            }

            try {
                UserDetails userDetails = multiContextUserDetailsService.loadControlPlaneUserByEmail(email, accountId);
                setAuth(req, userDetails);
                chain.doFilter(req, res);
                return;
            } catch (Exception e) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid authentication context"));
                return;
            }
        }

        // Qualquer outro authDomain é inválido => 401 (sem stacktrace)
        SecurityContextHolder.clearContext();
        authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid authDomain"));
    }

    private void setAuth(HttpServletRequest request, UserDetails userDetails) {
        UsernamePasswordAuthenticationToken auth =
                new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
        auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(auth);
    }

    private boolean requiresControlPlane(HttpServletRequest req) {
        String path = req.getRequestURI();
        return path.startsWith(SecurityConstants.ApiPaths.ADMIN_PREFIX)
                || path.startsWith(SecurityConstants.ApiPaths.CONTROLPLANE_PREFIX);
    }

    private boolean requiresTenant(HttpServletRequest req) {
        String path = req.getRequestURI();
        boolean isMe = SecurityConstants.ApiPaths.ME.equals(path)
                || path.startsWith(SecurityConstants.ApiPaths.ME_PREFIX);
        return path.startsWith(SecurityConstants.ApiPaths.TENANT_PREFIX) || isMe;
    }

    private String normalize(String s) {
        if (s == null) return null;
        String t = s.trim();
        return t.isEmpty() ? null : t;
    }

    private String normalizeLower(String s) {
        String t = normalize(s);
        return (t == null) ? null : t.toLowerCase();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/MustChangePasswordFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Map;

public class MustChangePasswordFilter extends OncePerRequestFilter {

    private static final String CHANGE_PASSWORD_PATH = "/api/admin/me/password";
    private static final String ME_PATH              = "/api/admin/me";

    private static final String LOGIN_PATH   = "/api/admin/auth/login";
    private static final String REFRESH_PATH = "/api/admin/auth/refresh";

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        String method = request.getMethod();
        String path = request.getRequestURI();

        // ✅ libera preflight (CORS)
        if ("OPTIONS".equalsIgnoreCase(method)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera login/refresh
        if (path.startsWith(LOGIN_PATH) || path.startsWith(REFRESH_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera troca de senha
        if (path.startsWith(CHANGE_PASSWORD_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication == null || !(authentication.getPrincipal() instanceof AuthenticatedUserContext ctx)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera /me (pra UI conseguir saber que precisa trocar senha)
        if (path.startsWith(ME_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        if (ctx.isMustChangePassword()) {
            response.setStatus(428);
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);

            Map<String, Object> body = Map.of(
                    "error", "MUST_CHANGE_PASSWORD",
                    "message", "Você precisa alterar a senha antes de continuar.",
                    "status", 428,
                    "details", Map.of(
                            "userId", ctx.getUserId(),
                            "email", ctx.getEmail(),
                            "accountId", ctx.getAccountId()
                    )
            );

            response.getWriter().write(objectMapper.writeValueAsString(body));
            return;
        }

        filterChain.doFilter(request, response);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/RequestLoggingFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j
public class RequestLoggingFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws ServletException, IOException {

        long threadId = Thread.currentThread().threadId();
        String method = req.getMethod();
        String uri = req.getRequestURI();

        try {
            chain.doFilter(req, res);
        } finally {
            String tenant = TenantContext.getOrNull();
            String tenantForLog = (tenant == null ? "PUBLIC" : tenant);

            RequestMeta meta = RequestMetaContext.getOrNull();
            String requestId = (meta != null && meta.requestId() != null) ? meta.requestId().toString() : "-";
            String ip = (meta != null && meta.ip() != null) ? meta.ip() : "-";

            log.info("🌐 [REQ] {} {} | tenant={} | status={} | ip={} | requestId={} | thread={}",
                    method, uri, tenantForLog, res.getStatus(), ip, requestId, threadId);
        }
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/actuator")
                || path.startsWith("/swagger")
                || path.startsWith("/v3/api-docs")
                || path.startsWith("/favicon.ico");
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/RequestMetaContextFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.UUID;

public class RequestMetaContextFilter extends OncePerRequestFilter {

    public static final String REQUEST_ID_HEADER = "X-Request-Id";
    public static final String FORWARDED_FOR_HEADER = "X-Forwarded-For";

    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws ServletException, IOException {

        RequestMeta meta = new RequestMeta(
                resolveRequestId(req),
                req.getMethod(),
                req.getRequestURI(),
                resolveClientIp(req),
                resolveUserAgent(req)
        );

        RequestMetaContext.set(meta);

        if (meta.requestId() != null) {
            res.setHeader(REQUEST_ID_HEADER, meta.requestId().toString());
        }

        try {
            chain.doFilter(req, res);
        } finally {
            // ✅ limpeza centralizada
            try { TenantContext.clear(); } catch (Exception ignore) {}
            RequestMetaContext.clear();
        }
    }

    private UUID resolveRequestId(HttpServletRequest req) {
        String raw = req.getHeader(REQUEST_ID_HEADER);
        if (StringUtils.hasText(raw)) {
            try { return UUID.fromString(raw.trim()); } catch (Exception ignore) {}
        }
        return UUID.randomUUID();
    }

    private String resolveClientIp(HttpServletRequest req) {
        String xff = req.getHeader(FORWARDED_FOR_HEADER);
        if (StringUtils.hasText(xff)) {
            String first = xff.split(",")[0].trim();
            if (StringUtils.hasText(first)) return first;
        }
        return req.getRemoteAddr();
    }

    private String resolveUserAgent(HttpServletRequest req) {
        String ua = req.getHeader("User-Agent");
        return StringUtils.hasText(ua) ? ua.trim() : null;
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/actuator")
                || path.startsWith("/swagger")
                || path.startsWith("/v3/api-docs")
                || path.startsWith("/favicon.ico");
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/TenantHeaderTenantContextFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j
public class TenantHeaderTenantContextFilter extends OncePerRequestFilter {

    public static final String TENANT_HEADER = "X-Tenant";

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        final long threadId = Thread.currentThread().threadId();
        final String method = request.getMethod();
        final String uri = request.getRequestURI();

        // ✅ Se tem Bearer, QUEM MANDA É O TOKEN (não o header)
        final String authHeader = request.getHeader("Authorization");
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            String raw = request.getHeader(TENANT_HEADER);
            String tenantHeader = (raw == null ? null : raw.trim());
            String tenantForLog = StringUtils.hasText(tenantHeader) ? tenantHeader : "PUBLIC";

            log.info("🌐 [REQ] {} {} | X-Tenant={} | thread={}",
                    method, uri, tenantForLog, threadId);

            filterChain.doFilter(request, response);
            return;
        }

        // ✅ Sem Bearer (ex.: rotas públicas) -> pode bindar por header se você quiser
        final String raw = request.getHeader(TENANT_HEADER);
        final String tenantHeader = (raw == null ? null : raw.trim());
        final String tenantForLog = StringUtils.hasText(tenantHeader) ? tenantHeader : "PUBLIC";

        try (TenantContext.Scope ignored = TenantContext.scope(tenantHeader)) {
            log.info("🌐 [REQ] {} {} | X-Tenant={} | thread={}",
                    method, uri, tenantForLog, threadId);
            filterChain.doFilter(request, response);

        } finally {
            try { TenantContext.clear(); } catch (Exception ignore) {}
        }
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/actuator")
                || path.startsWith("/swagger")
                || path.startsWith("/v3/api-docs")
                || path.startsWith("/favicon.ico");
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/jwt/JwtTokenProvider.java
============================================================
package brito.com.multitenancy001.infrastructure.security.jwt;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.time.AppClock;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtTokenProvider {

    public static final String CLAIM_AUTHORITIES = "authorities";
    public static final String CLAIM_AUTH_DOMAIN = "authDomain";
    public static final String CLAIM_CONTEXT = "context";
    public static final String CLAIM_ACCOUNT_ID = "accountId";
    public static final String CLAIM_USER_ID = "userId";

    public static final String CLAIM_ROLE_NAME = "roleName";
    public static final String CLAIM_ROLE_AUTHORITY = "roleAuthority";

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private long jwtExpirationInMs;

    @Value("${app.jwt.refresh.expiration}")
    private long refreshExpirationInMs;

    private final AppClock appClock;
    private SecretKey key;

    public JwtTokenProvider(AppClock appClock) {
        this.appClock = appClock;
    }

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            throw new IllegalArgumentException("JWT secret must be at least 256 bits (32 chars)");
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    private Date issuedAt() {
        return Date.from(appClock.instant());
    }

    private Date expiresAtInMs(long ttlMillis) {
        Instant exp = appClock.instant().plusMillis(ttlMillis);
        return Date.from(exp);
    }

    public String generateControlPlaneToken(Authentication authentication, Long accountId, String context) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getEmail())
                .claim(CLAIM_AUTHORITIES, user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim(CLAIM_AUTH_DOMAIN, "CONTROLPLANE")
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, user.getUserId())
                .claim(CLAIM_ROLE_NAME, user.getRoleName())
                .claim(CLAIM_ROLE_AUTHORITY, user.getRoleAuthority())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public String generateTenantToken(Authentication authentication, Long accountId, String context) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getEmail())
                .claim(CLAIM_AUTHORITIES, user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim(CLAIM_AUTH_DOMAIN, "TENANT")
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, user.getUserId())
                .claim(CLAIM_ROLE_NAME, user.getRoleName())
                .claim(CLAIM_ROLE_AUTHORITY, user.getRoleAuthority())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /**
     * Refresh token NÃO precisa de authorities; ele serve para renovar sessão.
     * Guardamos apenas: subject(email) + authDomain + context(tenantSchema) + accountId
     */
    public String generateRefreshToken(String email, String context, Long accountId) {
        return Jwts.builder()
                .subject(email)
                .claim(CLAIM_AUTH_DOMAIN, "REFRESH")
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(refreshExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public String generatePasswordResetToken(String email, String context, Long accountId) {
        long oneHourMs = 3_600_000L;

        return Jwts.builder()
                .subject(email)
                .claim(CLAIM_AUTH_DOMAIN, "PASSWORD_RESET")
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(oneHourMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    public String getEmailFromToken(String token) {
        return getAllClaimsFromToken(token).getSubject();
    }

    public String getContextFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String context = claims.get(CLAIM_CONTEXT, String.class);
        if (context == null) context = claims.get("tenantSchema", String.class);

        String authDomain = getAuthDomain(token);

        if ("TENANT".equals(authDomain) && Schemas.CONTROL_PLANE.equalsIgnoreCase(context)) {
            throw new JwtException("Invalid context for TENANT token: public");
        }

        return context;
    }

    public String getTenantSchemaFromToken(String token) {
        return getContextFromToken(token);
    }

    public Long getAccountIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ACCOUNT_ID, Long.class);
    }

    public Long getUserIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_USER_ID, Long.class);
    }

    public String getAuthDomain(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authDomain = claims.get(CLAIM_AUTH_DOMAIN, String.class);
        if (!StringUtils.hasText(authDomain)) {
            authDomain = claims.get("type", String.class); // compat tokens antigos
        }

        return authDomain;
    }

    public String getRoleNameFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ROLE_NAME, String.class);
    }

    public String getRoleAuthorityFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ROLE_AUTHORITY, String.class);
    }

    public List<String> getAuthoritiesFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authorities = claims.get(CLAIM_AUTHORITIES, String.class);
        if (!StringUtils.hasText(authorities)) {
            authorities = claims.get("roles", String.class); // compat tokens antigos
        }

        return splitCsv(authorities);
    }

    private List<String> splitCsv(String csv) {
        if (!StringUtils.hasText(csv)) return List.of();

        return Arrays.stream(csv.split(","))
                .map(String::trim)
                .filter(StringUtils::hasText)
                .distinct()
                .toList();
    }

    public boolean isTokenExpired(String token) {
        try {
            Claims claims = getAllClaimsFromToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(Date.from(appClock.instant()));
        } catch (Exception e) {
            return true;
        }
    }

    public boolean validateToken(String token) {
        try {
            getAllClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public boolean isControlPlaneToken(String token) {
        return "CONTROLPLANE".equals(getAuthDomain(token));
    }

    public boolean isTenantToken(String token) {
        return "TENANT".equals(getAuthDomain(token));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/MultiContextUserDetailsService.java
============================================================
package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.authorities.AuthoritiesFactory;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.time.Instant;

@Service
@RequiredArgsConstructor
public class MultiContextUserDetailsService implements UserDetailsService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final TenantUserRepository tenantUserRepository;
    private final AppClock appClock;

    private Instant now() {
        return appClock.instant();
    }

    private static String normalizeEmailOrThrow(String raw) {
        String normalized = EmailNormalizer.normalizeOrNull(raw);
        if (normalized == null) {
            throw new UsernameNotFoundException("INVALID_USER");
        }
        return normalized;
    }

    /**
     * Spring Security exige essa assinatura, mas aqui tratamos o parâmetro como EMAIL.
     *
     * Regras:
     * - CONTROLPLANE: carrega por email no schema public
     * - TENANT: carrega por email dentro do schema do tenant (TenantContext já está bindado)
     */
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        String schemaName = TenantContext.getOrNull();
        String loginEmail = normalizeEmailOrThrow(email);

        // CONTROL PLANE: email é único globalmente
        if (schemaName == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(schemaName)) {
            return loadControlPlaneUserByEmail(loginEmail);
        }

        // TENANT: dentro do schema do tenant
        Instant now = now();

        TenantUser user = tenantUserRepository
                .findByEmailAndDeletedFalse(loginEmail)
                .orElseThrow(() -> new UsernameNotFoundException("INVALID_USER"));

        var authorities = AuthoritiesFactory.forTenant(user);
        return AuthenticatedUserContext.fromTenantUser(user, schemaName, now, authorities);
    }

    public UserDetails loadControlPlaneUserByEmail(String email, Long accountId) {
        Instant now = now();

        if (accountId == null) {
            throw new ApiException(
                    "ACCOUNT_REQUIRED",
                    "accountId é obrigatório para autenticar usuário da controlplane",
                    400
            );
        }

        String loginEmail = normalizeEmailOrThrow(email);

        ControlPlaneUser user = controlPlaneUserRepository
                .findByEmailAndAccount_IdAndDeletedFalse(loginEmail, accountId)
                .orElseThrow(() -> new UsernameNotFoundException("INVALID_USER"));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return AuthenticatedUserContext.fromControlPlaneUser(user, Schemas.CONTROL_PLANE, now, authorities);
    }

    public UserDetails loadControlPlaneUserByEmail(String email) {
        Instant now = now();

        String loginEmail = normalizeEmailOrThrow(email);

        ControlPlaneUser user = controlPlaneUserRepository.findByEmailAndDeletedFalse(loginEmail)
                .orElseThrow(() -> new UsernameNotFoundException("INVALID_USER"));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return AuthenticatedUserContext.fromControlPlaneUser(user, Schemas.CONTROL_PLANE, now, authorities);
    }

    public UserDetails loadTenantUserByEmail(String email, Long accountId) {
        String schemaName = TenantContext.getOrNull();
        if (schemaName == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(schemaName)) {
            throw new ApiException(
                    "TENANT_CONTEXT_REQUIRED",
                    "TenantContext não está bindado para autenticar usuário tenant",
                    401
            );
        }

        if (accountId == null) {
            throw new ApiException(
                    "ACCOUNT_REQUIRED",
                    "accountId é obrigatório para autenticar usuário tenant",
                    400
            );
        }

        Instant now = now();

        String loginEmail = normalizeEmailOrThrow(email);

        TenantUser user = tenantUserRepository
                .findByEmailAndAccountIdAndDeletedFalse(loginEmail, accountId)
                .orElseThrow(() -> new UsernameNotFoundException("INVALID_USER"));

        var authorities = AuthoritiesFactory.forTenant(user);
        return AuthenticatedUserContext.fromTenantUser(user, schemaName, now, authorities);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantExecutor.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.kernel.error.ApiException;

@Component
public class TenantExecutor {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public TenantExecutor(TenantSchemaProvisioningService tenantSchemaProvisioningService) {
        this.tenantSchemaProvisioningService = tenantSchemaProvisioningService;
    }

    // ---------------------------------------------------------------------
    // ✅ NOVO PADRÃO (semântico): "schema" / "tenantSchema"
    // ---------------------------------------------------------------------

    public <T> T runInSchema(String tenantSchema, Supplier<T> fn) {
        return run(tenantSchema, fn);
    }

    public void runInSchema(String tenantSchema, Runnable fn) {
        run(tenantSchema, fn);
    }

    public <T> T runInSchemaIfReady(String tenantSchema, String requiredTable, Supplier<T> fn, T defaultValue) {
        return runIfReady(tenantSchema, requiredTable, fn, defaultValue);
    }

    public <T> T runInSchemaIfReady(String tenantSchema, String requiredTable, Supplier<T> fn) {
        return runIfReady(tenantSchema, requiredTable, fn, null);
    }

    public void runInSchemaIfReady(String tenantSchema, String requiredTable, Runnable fn) {
        runIfReady(tenantSchema, requiredTable, fn);
    }

    public void assertSchemaReadyOrThrow(String tenantSchema, String requiredTable) {
        assertReadyOrThrow(tenantSchema, requiredTable);
    }

    public <T> T runInSchemaOrThrow(String tenantSchema, String requiredTable, Supplier<T> fn) {
        return runOrThrow(tenantSchema, requiredTable, fn);
    }

    public <T> T runInSchemaOrThrow(String tenantSchema, Supplier<T> fn) {
        return runOrThrow(tenantSchema, null, fn);
    }

    // ---------------------------------------------------------------------
    // ✅ API ATUAL (mantida): schemaName (compat)
    // ---------------------------------------------------------------------

    public <T> T run(String schemaName, Supplier<T> fn) {
        String tenantSchema = normalizeTenantSchemaOrNull(schemaName);

        if (tenantSchema == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(tenantSchema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inválido", 404);
        }

        try (TenantContext.Scope ignored = TenantContext.scope(tenantSchema)) {
            return fn.get();
        }
    }

    public void run(String schemaName, Runnable fn) {
        run(schemaName, () -> {
            fn.run();
            return null;
        });
    }

    /** Retorna defaultValue se tenantSchema/tabela não existir. */
    public <T> T runIfReady(String schemaName, String requiredTable, Supplier<T> fn, T defaultValue) {
        String tenantSchema = normalizeTenantSchemaOrNull(schemaName);

        if (tenantSchema == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(tenantSchema)) return defaultValue;
        if (!tenantSchemaProvisioningService.schemaExists(tenantSchema)) return defaultValue;
        if (requiredTable != null && !tenantSchemaProvisioningService.tableExists(tenantSchema, requiredTable)) return defaultValue;

        return run(tenantSchema, fn);
    }

    public <T> T runIfReady(String schemaName, String requiredTable, Supplier<T> fn) {
        return runIfReady(schemaName, requiredTable, fn, null);
    }

    public void runIfReady(String schemaName, String requiredTable, Runnable fn) {
        runIfReady(schemaName, requiredTable, () -> {
            fn.run();
            return null;
        }, null);
    }

    /** Lança ApiException se tenantSchema/tabela não existir. */
    public void assertReadyOrThrow(String schemaName, String requiredTable) {
        String tenantSchema = normalizeTenantSchemaOrNull(schemaName);

        if (tenantSchema == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(tenantSchema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inválido", 404);
        }
        if (!tenantSchemaProvisioningService.schemaExists(tenantSchema)) {
            throw new ApiException("TENANT_SCHEMA_NOT_FOUND", "SchemaName do tenant não existe", 404);
        }
        if (requiredTable != null && !tenantSchemaProvisioningService.tableExists(tenantSchema, requiredTable)) {
            throw new ApiException("TENANT_TABLE_NOT_FOUND", "Tabela " + requiredTable + " não existe no tenant", 404);
        }
    }

    public <T> T runOrThrow(String schemaName, String requiredTable, Supplier<T> fn) {
        assertReadyOrThrow(schemaName, requiredTable);
        return run(schemaName, fn);
    }

    public <T> T runOrThrow(String schemaName, Supplier<T> fn) {
        return runOrThrow(schemaName, null, fn);
    }

    private static String normalizeTenantSchemaOrNull(String schemaName) {
        String s = (schemaName == null ? null : schemaName.trim());
        return (s == null || s.isBlank()) ? null : s;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantReadyExecutor.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;

/**
 * Helpers prontos para executar código no tenant
 * SOMENTE quando o schema + tabelas mínimas existirem.
 *
 * ✅ Evita passar string de tabela na mão (usa TenantRequiredTables)
 * ✅ Usa o TenantExecutor por baixo (sem duplicar regra)
 */
@Component
@RequiredArgsConstructor
public class TenantReadyExecutor {

    private final TenantExecutor tenantExecutor;

    // ---------------------------------------------------------------------
    // USERS
    // ---------------------------------------------------------------------

    public <T> T runIfUsersReady(String tenantSchema, Supplier<T> fn, T defaultValue) {
        return tenantExecutor.runIfReady(tenantSchema, TenantRequiredTables.TENANT_USERS, fn, defaultValue);
    }

    public <T> T runIfUsersReady(String tenantSchema, Supplier<T> fn) {
        return tenantExecutor.runIfReady(tenantSchema, TenantRequiredTables.TENANT_USERS, fn, null);
    }

    public void runIfUsersReady(String tenantSchema, Runnable fn) {
        tenantExecutor.runIfReady(tenantSchema, TenantRequiredTables.TENANT_USERS, fn);
    }

    public void assertUsersReadyOrThrow(String tenantSchema) {
        tenantExecutor.assertReadyOrThrow(tenantSchema, TenantRequiredTables.TENANT_USERS);
    }

    public <T> T runUsersOrThrow(String tenantSchema, Supplier<T> fn) {
        return tenantExecutor.runOrThrow(tenantSchema, TenantRequiredTables.TENANT_USERS, fn);
    }

    public void runUsersOrThrow(String tenantSchema, Runnable fn) {
        tenantExecutor.runOrThrow(tenantSchema, TenantRequiredTables.TENANT_USERS, () -> {
            fn.run();
            return null;
        });
    }

    // ---------------------------------------------------------------------
    // PRODUCTS
    // ---------------------------------------------------------------------

    public <T> T runIfProductsReady(String tenantSchema, Supplier<T> fn, T defaultValue) {
        return tenantExecutor.runIfReady(tenantSchema, TenantRequiredTables.PRODUCTS, fn, defaultValue);
    }

    public <T> T runIfProductsReady(String tenantSchema, Supplier<T> fn) {
        return tenantExecutor.runIfReady(tenantSchema, TenantRequiredTables.PRODUCTS, fn, null);
    }

    public void runIfProductsReady(String tenantSchema, Runnable fn) {
        tenantExecutor.runIfReady(tenantSchema, TenantRequiredTables.PRODUCTS, fn);
    }

    public void assertProductsReadyOrThrow(String tenantSchema) {
        tenantExecutor.assertReadyOrThrow(tenantSchema, TenantRequiredTables.PRODUCTS);
    }

    public <T> T runProductsOrThrow(String tenantSchema, Supplier<T> fn) {
        return tenantExecutor.runOrThrow(tenantSchema, TenantRequiredTables.PRODUCTS, fn);
    }

    public void runProductsOrThrow(String tenantSchema, Runnable fn) {
        tenantExecutor.runOrThrow(tenantSchema, TenantRequiredTables.PRODUCTS, () -> {
            fn.run();
            return null;
        });
    }

    // ---------------------------------------------------------------------
    // GENÉRICO (se quiser usar com outras tabelas do TenantRequiredTables)
    // ---------------------------------------------------------------------

    public <T> T runIfReady(String tenantSchema, String requiredTable, Supplier<T> fn, T defaultValue) {
        return tenantExecutor.runIfReady(tenantSchema, requiredTable, fn, defaultValue);
    }

    public <T> T runOrThrow(String tenantSchema, String requiredTable, Supplier<T> fn) {
        return tenantExecutor.runOrThrow(tenantSchema, requiredTable, fn);
    }

    public void assertReadyOrThrow(String tenantSchema, String requiredTable) {
        tenantExecutor.assertReadyOrThrow(tenantSchema, requiredTable);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantRequiredTables.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

/**
 * Lista central de tabelas "âncora" do schema TENANT.
 *
 * Uso típico:
 * - tenantExecutor.runInSchemaOrThrow(schema, TenantRequiredTables.TENANT_USERS, () -> ...)
 * - tenantExecutor.runInSchemaIfReady(schema, TenantRequiredTables.PRODUCTS, () -> ..., defaultValue)
 *
 * Dica:
 * - escolha UMA tabela bem “core” (ex: TENANT_USERS) como "schema ready"
 * - use outras quando o caso exigir (ex: PRODUCTS)
 */
public final class TenantRequiredTables {

    private TenantRequiredTables() {}

    /** Tabela âncora: se existir, o schema tenant foi migrado (mínimo). */
    public static final String TENANT_USERS = "tenant_users";

    /** Permissões do tenant user. */
    public static final String TENANT_USER_PERMISSIONS = "tenant_user_permissions";

    /** Catálogo */
    public static final String CATEGORIES = "categories";
    public static final String SUBCATEGORIES = "subcategories";
    public static final String SUPPLIERS = "suppliers";
    public static final String PRODUCTS = "products";

    /** Vendas */
    public static final String SALES = "sales";
    public static final String SALES_ITEMS = "sales_items";

    /** “Pronto” para uso geral do tenant (âncora padrão) */
    public static String readinessAnchor() {
        return TENANT_USERS;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningFacade.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class TenantSchemaProvisioningFacade {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public boolean ensureSchemaExistsAndMigrate(String schemaName) {
        return tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(schemaName);
    }

    public void tryDropSchema(String schemaName) {
        tenantSchemaProvisioningService.tryDropSchema(schemaName);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningService.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.Duration;
import java.util.Objects;

import javax.sql.DataSource;

import org.springframework.jdbc.datasource.SingleConnectionDataSource;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.provisioning.infra.TenantFlywayMigrator;
import lombok.RequiredArgsConstructor;

/**
 * Provisionamento de schema TENANT (Postgres):
 * - cria schema se não existir
 * - roda flyway do tenant
 *
 * ✅ Zero corrida: usa pg_advisory_lock e executa Flyway NA MESMA connection
 * ✅ Clean: sem sleep, sem "depende de timing"
 *
 * Também expõe checks (schemaExists/tableExists) para o TenantExecutor.
 */
@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningService {

    private static final Duration DEFAULT_LOCK_TIMEOUT = Duration.ofSeconds(30);

    private final DataSource dataSource;
    private final TenantFlywayMigrator tenantFlywayMigrator;

    // =========================================================
    // Provisioning
    // =========================================================

    public boolean ensureSchemaExistsAndMigrate(String schemaName) {
        validateSchemaName(schemaName);

        try (Connection conn = dataSource.getConnection()) {

            long lockKey = advisoryKey(schemaName);

            if (!tryAdvisoryLock(conn, lockKey, DEFAULT_LOCK_TIMEOUT)) {
                throw new ApiException(
                        "TENANT_SCHEMA_LOCK_TIMEOUT",
                        "Não foi possível obter lock de provisionamento do schema '" + schemaName + "'",
                        409
                );
            }

            try {
                createSchemaIfNotExists(conn, schemaName);

                // Flyway do tenant usando a MESMA connection (lock continua válido)
                var single = new SingleConnectionDataSource(conn, true);
                tenantFlywayMigrator.migrate(single, schemaName);

                return true;

            } finally {
                advisoryUnlock(conn, lockKey);
            }

        } catch (SQLException e) {
            throw new ApiException(
                    "TENANT_SCHEMA_PROVISIONING_FAILED",
                    "Falha ao provisionar schema '" + schemaName + "': " + e.getMessage(),
                    500
            );
        }
    }

    public void tryDropSchema(String schemaName) {
        validateSchemaName(schemaName);

        try (Connection conn = dataSource.getConnection()) {

            long lockKey = advisoryKey(schemaName);

            if (!tryAdvisoryLock(conn, lockKey, DEFAULT_LOCK_TIMEOUT)) {
                throw new ApiException(
                        "TENANT_SCHEMA_LOCK_TIMEOUT",
                        "Não foi possível obter lock para drop do schema '" + schemaName + "'",
                        409
                );
            }

            try {
                dropSchemaIfExists(conn, schemaName);
            } finally {
                advisoryUnlock(conn, lockKey);
            }

        } catch (SQLException e) {
            throw new ApiException(
                    "TENANT_SCHEMA_DROP_FAILED",
                    "Falha ao dropar schema '" + schemaName + "': " + e.getMessage(),
                    500
            );
        }
    }

    // =========================================================
    // Read-only checks (usados por TenantExecutor)
    // =========================================================

    public boolean schemaExists(String schemaName) {
        validateSchemaName(schemaName);

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement("""
                 select exists (
                     select 1
                       from information_schema.schemata
                      where schema_name = ?
                 )
             """)) {

            ps.setString(1, schemaName);

            try (ResultSet rs = ps.executeQuery()) {
                rs.next();
                return rs.getBoolean(1);
            }

        } catch (SQLException e) {
            throw new ApiException(
                    "TENANT_SCHEMA_EXISTS_CHECK_FAILED",
                    "Falha ao verificar schema '" + schemaName + "': " + e.getMessage(),
                    500
            );
        }
    }

    public boolean tableExists(String schemaName, String tableName) {
        validateSchemaName(schemaName);

        if (tableName == null || tableName.isBlank()) {
            throw new ApiException("TABLE_REQUIRED", "requiredTable é obrigatório", 400);
        }

        String t = tableName.trim();

        if (!t.matches("^[a-z][a-z0-9_]*$")) {
            throw new ApiException("TABLE_INVALID", "Nome de tabela inválido: " + t, 400);
        }

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement("""
                 select exists (
                     select 1
                       from information_schema.tables
                      where table_schema = ?
                        and table_name = ?
                 )
             """)) {

            ps.setString(1, schemaName);
            ps.setString(2, t);

            try (ResultSet rs = ps.executeQuery()) {
                rs.next();
                return rs.getBoolean(1);
            }

        } catch (SQLException e) {
            throw new ApiException(
                    "TENANT_TABLE_EXISTS_CHECK_FAILED",
                    "Falha ao verificar tabela '" + schemaName + "." + t + "': " + e.getMessage(),
                    500
            );
        }
    }

    // =========================================================
    // SQL helpers
    // =========================================================

    private void createSchemaIfNotExists(Connection conn, String schemaName) throws SQLException {
        String sql = "create schema if not exists " + schemaName;
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.execute();
        }
    }

    private void dropSchemaIfExists(Connection conn, String schemaName) throws SQLException {
        String sql = "drop schema if exists " + schemaName + " cascade";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.execute();
        }
    }

    // =========================================================
    // Advisory lock helpers (Postgres)
    // =========================================================

    private boolean tryAdvisoryLock(Connection conn, long key, Duration timeout) throws SQLException {
        Objects.requireNonNull(timeout, "timeout");

        // sem atraso: tenta uma vez
        try (PreparedStatement ps = conn.prepareStatement("select pg_try_advisory_lock(?)")) {
            ps.setLong(1, key);
            try (var rs = ps.executeQuery()) {
                rs.next();
                return rs.getBoolean(1);
            }
        }
    }

    private void advisoryUnlock(Connection conn, long key) {
        try (PreparedStatement ps = conn.prepareStatement("select pg_advisory_unlock(?)")) {
            ps.setLong(1, key);
            ps.execute();
        } catch (SQLException ignored) {
            // best-effort
        }
    }

    private long advisoryKey(String schemaName) {
        return fnv1a64(schemaName);
    }

    private long fnv1a64(String s) {
        long hash = 0xcbf29ce484222325L;
        for (int i = 0; i < s.length(); i++) {
            hash ^= s.charAt(i);
            hash *= 0x100000001b3L;
        }
        return hash;
    }

    // =========================================================
    // Validation
    // =========================================================

    private void validateSchemaName(String schemaName) {
        if (schemaName == null || schemaName.isBlank()) {
            throw new ApiException("SCHEMA_REQUIRED", "schemaName é obrigatório", 400);
        }

        String s = schemaName.trim();

        if (s.length() > 63) {
            throw new ApiException("SCHEMA_INVALID", "schemaName excede 63 caracteres", 400);
        }

        if (!s.matches("^[a-z][a-z0-9_]*$")) {
            throw new ApiException(
                    "SCHEMA_INVALID",
                    "schemaName inválido. Use apenas [a-z0-9_] e comece com letra. Ex: t_minha_loja_abcdef",
                    400
            );
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantUnitOfWork.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.infrastructure.persistence.TransactionExecutor;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class TenantUnitOfWork {

    private final TenantExecutor tenantExecutor;
    private final TransactionExecutor transactionExecutor;

    public <T> T tx(String schemaName, Supplier<T> fn) {
        return tenantExecutor.run(schemaName, () -> transactionExecutor.inTenantTx(fn));
    }
    public void tx(String schemaName, Runnable fn) {
        tenantExecutor.run(schemaName, () -> transactionExecutor.inTenantTx(fn));
    }

    public <T> T readOnly(String schemaName, Supplier<T> fn) {
        return tenantExecutor.run(schemaName, () -> transactionExecutor.inTenantReadOnlyTx(fn));
    }

    public <T> T requiresNew(String schemaName, Supplier<T> fn) {
        return tenantExecutor.run(schemaName, () -> transactionExecutor.inTenantRequiresNew(fn));
    }

    public <T> T requiresNewReadOnly(String schemaName, Supplier<T> fn) {
        return tenantExecutor.run(schemaName, () -> transactionExecutor.inTenantRequiresNewReadOnly(fn));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantUserProvisioningFacade.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.time.Instant;
import java.util.List;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.infrastructure.persistence.TransactionExecutor;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.TenantRoleName;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantUserProvisioningFacade {

    private static final String REQUIRED_TABLE = "tenant_users";
    private static final String OWNER_NAME_FALLBACK = "Owner";

    private final TenantExecutor tenantExecutor;
    private final TransactionExecutor transactionExecutor;

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;

    private final AppClock appClock;

    public List<UserSummaryData> listUserSummaries(String schemaName, Long accountId, boolean onlyOperational) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                transactionExecutor.inTenantReadOnlyTx(() -> {

                    var users = onlyOperational
                            ? tenantUserRepository.findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId)
                            : tenantUserRepository.findByAccountId(accountId);

                    return users.stream()
                            .map(u -> new UserSummaryData(
                                    u.getId(),
                                    u.getAccountId(),
                                    u.getName(),
                                    u.getEmail(),
                                    u.getRole() == null ? null : TenantRoleName.valueOf(u.getRole().name()),
                                    u.isSuspendedByAccount(),
                                    u.isSuspendedByAdmin(),
                                    u.isDeleted()
                            ))
                            .toList();
                })
        );
    }

    /**
     * Cria o usuário dono (TENANT_OWNER) no schema do Tenant.
     *
     * ✅ Ajuste: permissões NÃO são inseridas manualmente.
     * - A entidade TenantUser já gerencia permissões via @ElementCollection (tenant_user_permissions)
     *   no @PrePersist/@PreUpdate (TenantUser.onSave()).
     */
    public UserSummaryData createTenantOwner(
            String schemaName,
            Long accountId,
            String ownerDisplayName,
            String email,
            String rawPassword
    ) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                transactionExecutor.inTenantTx(() -> {

                    if (accountId == null) {
                        throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);
                    }
                    if (!StringUtils.hasText(email)) {
                        throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
                    }
                    if (!StringUtils.hasText(rawPassword)) {
                        throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);
                    }

                    String emailNorm = email.trim().toLowerCase();

                    boolean emailExists = tenantUserRepository.existsByEmailAndAccountId(emailNorm, accountId);
                    if (emailExists) {
                        throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já cadastrado nesta conta", 409);
                    }

                    String name = StringUtils.hasText(ownerDisplayName)
                            ? ownerDisplayName.trim()
                            : OWNER_NAME_FALLBACK;

                    TenantUser tenantUser = new TenantUser();
                    tenantUser.setAccountId(accountId);
                    tenantUser.setName(name);
                    tenantUser.setEmail(emailNorm);
                    tenantUser.setPassword(passwordEncoder.encode(rawPassword));
                    tenantUser.setRole(TenantRole.TENANT_OWNER);
                    tenantUser.setSuspendedByAccount(false);
                    tenantUser.setSuspendedByAdmin(false);
                    tenantUser.setTimezone("America/Sao_Paulo");
                    tenantUser.setLocale("pt_BR");

                    // ✅ aqui o onSave() da entidade garante as permissões do role.
                    TenantUser saved = tenantUserRepository.save(tenantUser);

                    return new UserSummaryData(
                            saved.getId(),
                            saved.getAccountId(),
                            saved.getName(),
                            saved.getEmail(),
                            saved.getRole() == null ? null : TenantRoleName.valueOf(saved.getRole().name()),
                            saved.isSuspendedByAccount(),
                            saved.isSuspendedByAdmin(),
                            saved.isDeleted()
                    );
                })
        );
    }

    public int suspendAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName,
                REQUIRED_TABLE,
                () -> transactionExecutor.inTenantRequiresNew(() -> tenantUserRepository.suspendAllByAccount(accountId)),
                0
        );
    }

    public int unsuspendAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName,
                REQUIRED_TABLE,
                () -> transactionExecutor.inTenantRequiresNew(() -> tenantUserRepository.unsuspendAllByAccount(accountId)),
                0
        );
    }

    public int softDeleteAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName,
                REQUIRED_TABLE,
                () -> transactionExecutor.inTenantRequiresNew(() -> tenantUserRepository.softDeleteAllByAccount(accountId, appClock.instant())),
                0
        );
    }

    public int restoreAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName,
                REQUIRED_TABLE,
                () -> transactionExecutor.inTenantRequiresNew(() -> tenantUserRepository.restoreAllByAccount(accountId)),
                0
        );
    }

    public void setSuspendedByAdmin(String schemaName, Long accountId, Long userId, boolean suspended) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        tenantExecutor.run(schemaName, () ->
                transactionExecutor.inTenantTx(() -> {
                    int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
                    if (updated == 0) {
                        throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado ou removido", 404);
                    }
                    return null;
                })
        );
    }

    public void setPasswordResetToken(String schemaName, Long accountId, Long userId, String token, Instant expiresAt) {
        tenantExecutor.runIfReady(schemaName, REQUIRED_TABLE, () ->
                transactionExecutor.inTenantTx(() -> {
                    TenantUser user = tenantUserRepository.findEnabledByIdAndAccountId(userId, accountId)
                            .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

                    user.setPasswordResetToken(token);
                    user.setPasswordResetExpiresAt(expiresAt);

                    tenantUserRepository.save(user);
                    return null;
                })
        );
    }

    public TenantUser findByPasswordResetToken(String schemaName, Long accountId, String token) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                transactionExecutor.inTenantReadOnlyTx(() ->
                        tenantUserRepository.findByPasswordResetTokenAndAccountId(token, accountId)
                                .orElseThrow(() -> new ApiException("TOKEN_INVALID", "Token inválido", 400))
                )
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/account/UserLimitPolicy.java
============================================================
package brito.com.multitenancy001.shared.account;

public enum UserLimitPolicy {
    SEATS_IN_USE,        // deleted=false
    SEATS_ENABLED,
    ACTIVE_USERS_ONLY    // deleted=false AND suspendedByAccount=false AND suspendedByAdmin=false
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/auth/JwtResponse.java
============================================================
package brito.com.multitenancy001.shared.api.dto.auth;

import brito.com.multitenancy001.shared.security.SystemRoleName;

public record JwtResponse(
        String accessToken,
        String refreshToken,

        /**
         * HTTP Authorization scheme (ex: "Bearer").
         * NÃO confundir com o "authDomain" do JWT (TENANT/CONTROLPLANE/etc).
         */
        String tokenType,

        Long userId,

        /**
         * ✅ Identidade canônica de login (única).
         */
        String email,

        /**
         * ✅ Role "name" (ex: CONTROLPLANE_OWNER, TENANT_ADMIN)
         */
        SystemRoleName  role,

        Long accountId,

        /**
         * ✅ Para tenant: schema do tenant. Para controlplane: Schemas.CONTROL_PLANE.
         */
        String tenantSchema
) {
    public JwtResponse {
        if (tokenType == null || tokenType.isBlank()) tokenType = "Bearer";
    }

    /** ✅ Construtor curto (sem tokenType). */
    public JwtResponse(
            String accessToken,
            String refreshToken,
            Long userId,
            String email,
            SystemRoleName  role,
            Long accountId,
            String tenantSchema
    ) {
        this(accessToken, refreshToken, "Bearer", userId, email, role, accountId, tenantSchema);
    }

    public static JwtResponse forEmailLogin(
            String accessToken,
            String refreshToken,
            Long userId,
            String email,
            SystemRoleName  role,
            Long accountId,
            String tenantSchema
    ) {
        return new JwtResponse(accessToken, refreshToken, "Bearer", userId, email, role, accountId, tenantSchema);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/billing/AdminPaymentRequest.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record AdminPaymentRequest(
        @NotNull Long accountId,

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotNull PaymentMethod paymentMethod,
        @NotNull PaymentGateway paymentGateway,

        String description
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentRequest.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record PaymentRequest(
        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotNull PaymentMethod paymentMethod,
        @NotNull PaymentGateway paymentGateway,

        String description
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentResponse.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.Instant;

public record PaymentResponse(
        Long id,
        Long accountId,

        BigDecimal amount,
        PaymentMethod paymentMethod,
        PaymentGateway paymentGateway,
        PaymentStatus paymentStatus,

        String description,

        Instant paidAt,
        Instant validUntil,
        Instant refundedAt,

        Instant createdAt,
        Instant updatedAt
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/error/ApiEnumErrorResponse.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;

import java.time.Instant;
import java.util.List;

@Builder
public record ApiEnumErrorResponse(
        Instant timestamp,
        String error,
        String message,

        // opcional: erros de enum/constraint
        String field,
        String invalidValue,
        List<String> allowedValues,

        // ✅ qualquer payload extra (ex.: lista de tenants para seleção)
        Object details
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorResponse.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;

import java.time.Instant;
import java.util.List;

@Builder
public record ApiErrorResponse(
        Instant timestamp,
        String error,
        String message,
        List<String> details
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/error/GlobalExceptionHandler.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import brito.com.multitenancy001.shared.domain.DomainException;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RestControllerAdvice
@RequiredArgsConstructor
@Slf4j
public class GlobalExceptionHandler {

    private final AppClock appClock;

    private Instant now() {
        return appClock.instant();
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleNotReadable(HttpMessageNotReadableException ex) {

        Throwable cause = ex.getCause();

        if (cause instanceof InvalidFormatException ife) {
            Class<?> targetType = ife.getTargetType();

            if (targetType != null && targetType.isEnum()) {
                String fieldName = ife.getPath().isEmpty() ? "status" : ife.getPath().get(0).getFieldName();
                String invalidValue = ife.getValue() != null ? ife.getValue().toString() : "null";

                List<String> allowedValues = Arrays.stream(targetType.getEnumConstants())
                        .map(Object::toString)
                        .toList();

                return ResponseEntity.badRequest().body(
                        ApiEnumErrorResponse.builder()
                                .timestamp(now())
                                .error("INVALID_ENUM")
                                .message("Valor inválido para o campo " + fieldName)
                                .field(fieldName)
                                .invalidValue(invalidValue)
                                .allowedValues(allowedValues)
                                .build()
                );
            }
        }

        return ResponseEntity.badRequest().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INVALID_REQUEST_BODY")
                        .message("Corpo da requisição inválido")
                        .build()
        );
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {

        String errorMessage = ex.getMostSpecificCause() != null ? ex.getMostSpecificCause().getMessage() : ex.getMessage();
        if (!StringUtils.hasText(errorMessage)) errorMessage = "";

        log.debug("DataIntegrityViolationException: {}", errorMessage);

        if (errorMessage.contains("tax_id_number")) {
            String cnpj = extractValue(errorMessage, "tax_id_number");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_NUMBER")
                            .message("Já existe uma conta com o Number: " + cnpj)
                            .field("taxIdNumber")
                            .invalidValue(cnpj)
                            .build()
            );
        }

        if (errorMessage.contains("LoginEmail")) {
            String email = extractValue(errorMessage, "LoginEmail");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_EMAIL")
                            .message("Já existe uma conta com o email " + email)
                            .field("loginEmail")
                            .invalidValue(email)
                            .build()
            );
        }

        if (errorMessage.contains("slug")) {
            String slug = extractValue(errorMessage, "slug");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_SLUG")
                            .message("Já existe uma conta com o slug " + slug)
                            .field("slug")
                            .invalidValue(slug)
                            .build()
            );
        }

        if (errorMessage.contains("schema_name")) {
            String schema = extractValue(errorMessage, "schema_name");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_SCHEMA")
                            .message("Erro interno: schema " + schema + " já existe")
                            .build()
            );
        }

        return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("DUPLICATE_ENTRY")
                        .message("Registro duplicado. Verifique os dados informados.")
                        .build()
        );
    }

    private String extractValue(String message, String fieldName) {
        try {
            Pattern pattern = Pattern.compile("\\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher = pattern.matcher(message);
            if (matcher.find()) return matcher.group(1);

            Pattern pattern2 = Pattern.compile("Key \\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher2 = pattern2.matcher(message);
            if (matcher2.find()) return matcher2.group(1);

        } catch (Exception e) {
            log.debug("Erro ao extrair valor do erro de constraint: {}", e.getMessage());
        }

        return "não identificado";
    }

    @ExceptionHandler(ApiException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleApi(ApiException ex) {
        return ResponseEntity.status(ex.getStatus()).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error(ex.getError())
                        .message(ex.getMessage())
                        .field(ex.getField())
                        .invalidValue(ex.getInvalidValue())
                        .allowedValues(ex.getAllowedValues())
                        .details(ex.getDetails())
                        .build()
        );
    }


    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .toList();

        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(now())
                .error("VALIDATION_ERROR")
                .message("Erro de validação")
                .details(errors)
                .build();

        return ResponseEntity.badRequest().body(errorResponse);
    }

    /**
     * ✅ Login inválido (não vazar se o usuário existe).
     */
    @ExceptionHandler({
            BadCredentialsException.class,
            InternalAuthenticationServiceException.class,
            AuthenticationException.class
    })
    public ResponseEntity<ApiEnumErrorResponse> handleAuthentication(AuthenticationException ex) {

        log.warn("Authentication failed: {}", ex.getMessage());

        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INVALID_USER")
                        .message("usuario ou senha invalidos")
                        .build()
        );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiEnumErrorResponse> handleGeneric(Exception ex) {
        log.error("Unhandled exception: {}", ex.getMessage(), ex);

        return ResponseEntity.internalServerError().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INTERNAL_SERVER_ERROR")
                        .message("Erro interno inesperado. Contate o suporte.")
                        .build()
        );
    }

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ApiErrorResponse> handleDomainException(DomainException ex) {
        ApiErrorResponse body = ApiErrorResponse.builder()
                .timestamp(now())
                .error("DOMAIN_RULE_VIOLATION")
                .message(ex.getMessage())
                .build();

        return ResponseEntity.badRequest().body(body);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/audit/AuthEventAuditService.java
============================================================
package brito.com.multitenancy001.shared.audit;

import brito.com.multitenancy001.infrastructure.publicschema.audit.AuthEvent;
import brito.com.multitenancy001.infrastructure.publicschema.audit.AuthEventRepository;
import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Instant;

@Service
@RequiredArgsConstructor
public class AuthEventAuditService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final AuthEventRepository authEventRepository;
    private final AppClock appClock;

    public void record(String authDomain,
                       String eventType,
                       String outcome,
                       String principalEmail,
                       Long principalUserId,
                       Long accountId,
                       String tenantSchema,
                       String detailsJson) {

        RequestMeta meta = RequestMetaContext.getOrNull();
        String resolvedTenant = StringUtils.hasText(tenantSchema) ? tenantSchema : TenantContext.getOrNull();

        publicUnitOfWork.requiresNew(() -> {
            AuthEvent ev = new AuthEvent();

            // ✅ Fonte única de tempo: AppClock
            Instant occurredAt = appClock.instant();
            ev.setOccurredAt(occurredAt);

            if (meta != null) {
                ev.setRequestId(meta.requestId());
                ev.setMethod(meta.method());
                ev.setUri(meta.uri());
                ev.setIp(meta.ip());
                ev.setUserAgent(meta.userAgent());
            }

            ev.setAuthDomain(authDomain);
            ev.setEventType(eventType);
            ev.setOutcome(outcome);

            ev.setPrincipalEmail(principalEmail);
            ev.setPrincipalUserId(principalUserId);

            ev.setAccountId(accountId);
            ev.setTenantSchema(resolvedTenant);

            ev.setDetailsJson(detailsJson);

            authEventRepository.save(ev);
        });
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/audit/SecurityAuditService.java
============================================================
package brito.com.multitenancy001.shared.audit;

import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditEvent;
import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditEventRepository;
import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Instant;

@Service
@RequiredArgsConstructor
public class SecurityAuditService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final SecurityAuditEventRepository securityAuditEventRepository;
    private final AppClock appClock;

    public void record(String actionType,
                       String outcome,
                       String actorEmail,
                       Long actorUserId,
                       String targetEmail,
                       Long targetUserId,
                       Long accountId,
                       String tenantSchema,
                       String detailsJson) {

        RequestMeta meta = RequestMetaContext.getOrNull();
        String resolvedTenant = StringUtils.hasText(tenantSchema) ? tenantSchema : TenantContext.getOrNull();

        publicUnitOfWork.requiresNew(() -> {
            SecurityAuditEvent ev = new SecurityAuditEvent();

            // ✅ Fonte única de tempo: AppClock
            Instant occurredAt = appClock.instant();
            ev.setOccurredAt(occurredAt);

            if (meta != null) {
                ev.setRequestId(meta.requestId());
                ev.setMethod(meta.method());
                ev.setUri(meta.uri());
                ev.setIp(meta.ip());
                ev.setUserAgent(meta.userAgent());
            }

            ev.setActionType(actionType);
            ev.setOutcome(outcome);

            ev.setActorEmail(actorEmail);
            ev.setActorUserId(actorUserId);

            ev.setTargetEmail(targetEmail);
            ev.setTargetUserId(targetUserId);

            ev.setAccountId(accountId);
            ev.setTenantSchema(resolvedTenant);

            ev.setDetailsJson(detailsJson);

            securityAuditEventRepository.save(ev);
        });
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/auth/app/dto/JwtResult.java
============================================================
package brito.com.multitenancy001.shared.auth.app.dto;

import brito.com.multitenancy001.shared.security.SystemRoleName;

public record JwtResult(
        String accessToken,
        String refreshToken,
        String tokenType,
        Long userId,
        String email,
        SystemRoleName role,
        Long accountId,
        String tenantSchema
) {
    public JwtResult {
        if (tokenType == null || tokenType.isBlank()) tokenType = "Bearer";
    }

    public JwtResult(
            String accessToken,
            String refreshToken,
            Long userId,
            String email,
            SystemRoleName role,
            Long accountId,
            String tenantSchema
    ) {
        this(accessToken, refreshToken, "Bearer", userId, email, role, accountId, tenantSchema);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/billing/PaymentQueryFacade.java
============================================================
package brito.com.multitenancy001.shared.billing;

import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

/**
 * Facade de leitura de pagamentos (origem: Control Plane / schema público).
 *
 * Objetivo: permitir que o contexto TENANT consulte pagamentos
 * sem depender diretamente de classes do pacote controlplane.*.
 *
 * Implementação padrão: ControlPlanePaymentQueryService.
 */
public interface PaymentQueryFacade {

    List<PaymentResponse> findByStatus(PaymentStatus status);

    BigDecimal getTotalPaidInPeriod(Long accountId, Instant startDate, Instant endDate);

    long countCompletedPayments(Long accountId);

    List<PaymentResponse> listByAccount(Long accountId);

    PaymentResponse getByAccount(Long accountId, Long paymentId);

    boolean hasActivePayment(Long accountId);
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/context/RequestMeta.java
============================================================
package brito.com.multitenancy001.shared.context;

import java.util.UUID;

public record RequestMeta(
        UUID requestId,
        String method,
        String uri,
        String ip,
        String userAgent
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/context/RequestMetaContext.java
============================================================
package brito.com.multitenancy001.shared.context;

import org.slf4j.MDC;

import java.util.UUID;

public final class RequestMetaContext {

    private static final ThreadLocal<RequestMeta> HOLDER = new ThreadLocal<>();

    private RequestMetaContext() { }

    public static void set(RequestMeta meta) {
        HOLDER.set(meta);
        if (meta != null && meta.requestId() != null) {
            MDC.put("requestId", meta.requestId().toString());
        }
    }

    public static RequestMeta getOrNull() {
        return HOLDER.get();
    }

    public static UUID requestIdOrNull() {
        RequestMeta meta = HOLDER.get();
        return meta == null ? null : meta.requestId();
    }

    public static void clear() {
        try { HOLDER.remove(); } catch (Exception ignore) {}
        try { MDC.remove("requestId"); } catch (Exception ignore) {}
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/context/TenantContext.java
============================================================
package brito.com.multitenancy001.shared.context;

import brito.com.multitenancy001.shared.db.Schemas;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StringUtils;

@Slf4j
public class TenantContext {

    public static final String PUBLIC_SCHEMA = Schemas.CONTROL_PLANE;

    private static final ThreadLocal<String> TENANT_THREAD_LOCAL = new ThreadLocal<>();

    /**
     * ✅ Retorna o tenantSchema REALMENTE bindado (ou null).
     * public = null
     */
    public static String getOrNull() {
        String t = TENANT_THREAD_LOCAL.get();
        return StringUtils.hasText(t) ? t : null;
    }

    /**
     * ✅ Quando você quer um fallback explícito para public.
     */
    public static String getOrDefaultPublic() {
        String t = getOrNull();
        return (t != null ? t : PUBLIC_SCHEMA);
    }

    public static boolean isPublic() {
        return getOrNull() == null;
    }

    /**
     * ✅ Regra:
     * - NÃO pode mudar tenantSchema dentro de transação.
     * - MAS pode chamar bindTenantSchema() de forma idempotente (sem mudança) dentro de transação.
     */
    public static void bindTenantSchema(String tenantSchema) {

        String normalized = (tenantSchema != null ? tenantSchema.trim() : null);
        String target = StringUtils.hasText(normalized) ? normalized : null; // public = null
        String previous = getOrNull(); // já normalizado (public = null)

        // ✅ Sem mudança: não re-binda e evita log repetido
        // Lembre: isso pode ocorrer dentro de transação (ex.: reentrância / nested public scopes)
        if ((previous == null && target == null) || (previous != null && previous.equals(target))) {
            if (log.isDebugEnabled()) {
                log.debug("🔄 TenantContext.bindTenantSchema sem mudança | thread={} | tenantSchema={}",
                        Thread.currentThread().threadId(),
                        (target != null ? target : "PUBLIC(null)"));
            }
            return;
        }

        // 🚫 A partir daqui, há mudança REAL -> não permitir dentro de transação
        if (TransactionSynchronizationManager.isActualTransactionActive()) {
            throw new IllegalStateException("🔥 TenantContext.bindTenantSchema chamado DENTRO de transação! tenantSchema=" + tenantSchema);
        }

        // aplica mudança
        if (target == null) {
            TENANT_THREAD_LOCAL.remove();
            log.info("🔄 Tenant bindado para PUBLIC (null) | anterior={} | thread={}",
                    previous, Thread.currentThread().threadId());
        } else {
            TENANT_THREAD_LOCAL.set(target);
            log.info("🔄 Tenant bindado | thread={} | {} -> {}",
                    Thread.currentThread().threadId(), previous, target);
        }
    }

    

    /**
     * Remove qualquer tenantSchema (equivalente a PUBLIC).
     * Prefira usar publicScope()/scope() com try-with-resources.
     */
    public static void clear() {
        String previous = getOrNull();
        if (previous == null) {
            if (log.isDebugEnabled()) {
                log.debug("🧹 TenantContext.clear sem mudança (já estava PUBLIC) | thread={}",
                        Thread.currentThread().threadId());
            }
            return;
        }

        TENANT_THREAD_LOCAL.remove();
        log.info("🧹 Tenant desbindado | thread={} | anterior={}",
                Thread.currentThread().threadId(), previous);
    }

    // ✅ escopo seguro (restaura o tenantSchema anterior ao sair)
    public static Scope scope(String tenantSchema) {
        String previous = getOrNull();
        bindTenantSchema(tenantSchema);
        return new Scope(previous);
    }

    // ✅ escopo PUBLIC explícito (restaura o tenantSchema anterior ao sair)
    public static Scope publicScope() {
        String previous = getOrNull();
        bindTenantSchema(null); // explícito: public = sem tenantSchema
        return new Scope(previous);
    }

    public static final class Scope implements AutoCloseable {
        private final String previous;
        private boolean closed = false;

        private Scope(String previous) {
            this.previous = previous;
        }

        @Override
        public void close() {
            if (!closed) {
                TenantContext.bindTenantSchema(previous); // restaura exatamente o anterior
                closed = true;
            }
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/contracts/AccountRef.java
============================================================
package brito.com.multitenancy001.shared.contracts;

public record AccountRef(
        Long id,
        String schemaName,
        String timezone,
        String locale
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/contracts/AccountSnapshot.java
============================================================
package brito.com.multitenancy001.shared.contracts;

public record AccountSnapshot(Long id, String schemaName, String slug) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/contracts/UserSummaryData.java
============================================================
package brito.com.multitenancy001.shared.contracts;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Snapshot compartilhado (contrato) para representar um usuário do Tenant
 * sem expor a entidade do Tenant (bounded context).
 */
public record UserSummaryData(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRoleName role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/db/Schemas.java
============================================================
package brito.com.multitenancy001.shared.db;

public final class Schemas {

    /**
     * Schema do Control Plane (tabelas globais).
     * É o schema fallback (root) quando não há tenant bindado.
     */
    public static final String CONTROL_PLANE = "public";

    private Schemas() {}
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/DomainException.java
============================================================
package brito.com.multitenancy001.shared.domain;

public class DomainException extends RuntimeException {
    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public DomainException(String message) {
        super(message);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/EmailNormalizer.java
============================================================
package brito.com.multitenancy001.shared.domain;

public final class EmailNormalizer {

    private EmailNormalizer() { }

    public static String normalizeOrNull(String email) {
        if (email == null) return null;
        String e = email.trim();
        if (e.isEmpty()) return null;
        return e.toLowerCase();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditActor.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public record AuditActor(Long userId, String email) {

    public static AuditActor system() {
        return new AuditActor(null, "system");
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditInfo.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.Objects;

/**
 * AuditInfo é a fonte única de auditoria do projeto.
 *
 * Regras:
 * - Instantes reais => Instant (TIMESTAMPTZ).
 * - Ator vem de AuditActorProviders (via listener).
 * - AppClock deve ser a única fonte de tempo (now nunca pode ser null).
 */
@Embeddable
@Getter
@Setter
public class AuditInfo {

    @Column(name = "created_at", nullable = false, columnDefinition = "timestamptz")
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false, columnDefinition = "timestamptz")
    private Instant updatedAt;

    @Column(name = "deleted_at", columnDefinition = "timestamptz")
    private Instant deletedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @Column(name = "deleted_by")
    private Long deletedBy;

    @Column(name = "created_by_email")
    private String createdByEmail;

    @Column(name = "updated_by_email")
    private String updatedByEmail;

    @Column(name = "deleted_by_email")
    private String deletedByEmail;

    // =========================
    // API SEMÂNTICA (usada pelo AuditEntityListener)
    // =========================

    public void onCreate(AuditActor actor, Instant now) {
        Objects.requireNonNull(now, "AuditInfo.onCreate: now não pode ser null (AppClock é obrigatório)");

        if (this.createdAt == null) {
            this.createdAt = now;
        }
        this.updatedAt = now;

        if (actor != null) {
            if (this.createdBy == null) {
                this.createdBy = actor.userId();
                this.createdByEmail = actor.email();
            }
            this.updatedBy = actor.userId();
            this.updatedByEmail = actor.email();
        }
    }

    public void onUpdate(AuditActor actor, Instant now) {
        Objects.requireNonNull(now, "AuditInfo.onUpdate: now não pode ser null (AppClock é obrigatório)");

        this.updatedAt = now;

        if (actor != null) {
            this.updatedBy = actor.userId();
            this.updatedByEmail = actor.email();
        }
    }

    public void onDelete(AuditActor actor, Instant now) {
        Objects.requireNonNull(now, "AuditInfo.onDelete: now não pode ser null (AppClock é obrigatório)");

        markDeleted(now);

        if (actor != null) {
            this.deletedBy = actor.userId();
            this.deletedByEmail = actor.email();
        }
    }

    // =========================
    // API SEMÂNTICA (compat/domínio)
    // =========================

    /** Marca a entidade como deletada no instante informado (sem mexer em deletedBy). */
    public void markDeleted(Instant now) {
        Objects.requireNonNull(now, "AuditInfo.markDeleted: now não pode ser null");
        this.deletedAt = now;
    }

    /** Limpa estado de deleção (restore). */
    public void clearDeleted() {
        this.deletedAt = null;
        this.deletedBy = null;
        this.deletedByEmail = null;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/Auditable.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public interface Auditable {
    AuditInfo getAudit();
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/SoftDeletable.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public interface SoftDeletable {
    boolean isDeleted();
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditActorProvider.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;
import brito.com.multitenancy001.shared.security.AuthenticatedPrincipal;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

@Component
public class AuditActorProvider {

    @PostConstruct
    void register() {
        AuditActorProviders.setProvider(this);
    }

    @PreDestroy
    void unregister() {
        AuditActorProviders.clear();
    }

    public AuditActor current() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        if (auth == null || !(auth.getPrincipal() instanceof AuthenticatedPrincipal p)) {
            return AuditActor.system();
        }

        return new AuditActor(p.getUserId(), p.getEmail());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditActorProviders.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;

/**
 * Holder estático para permitir que EntityListeners (instanciados pelo JPA)
 * acessem o AuditActorProvider (bean Spring) sem injeção direta.
 *
 * Nota: "SYSTEM" é válido quando não existe usuário autenticado.
 * Mas provider ausente é erro de wiring -> fail-fast quando necessário.
 */
public final class AuditActorProviders {

    private static volatile AuditActorProvider provider;

    private AuditActorProviders() {}

    static void setProvider(AuditActorProvider provider) {
        AuditActorProviders.provider = provider;
    }

    static void clear() {
        AuditActorProviders.provider = null;
    }

    /** Usado por wiring verifier / health-checks internos. */
    public static void requireRegistered() {
        if (provider == null) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditActorProvider NÃO está registrado no AuditActorProviders. " +
                "A auditoria pode registrar tudo como SYSTEM sem você perceber. " +
                "Verifique o bean AuditActorProvider e o @PostConstruct register()."
            );
        }
    }

    /** Fail-fast se provider não estiver registrado (wiring quebrado). */
    public static AuditActor currentOrFail() {
        AuditActorProvider p = provider;
        if (p == null) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditActorProvider ausente (AuditActorProviders.provider == null)."
            );
        }
        return p.current(); // aqui sim pode retornar SYSTEM legitimamente (sem auth)
    }

    /**
     * Mantido por compatibilidade: se provider estiver ausente, retorna SYSTEM.
     * Útil só como "último recurso".
     */
    public static AuditActor currentOrSystem() {
        AuditActorProvider p = provider;
        if (p == null) return AuditActor.system();
        return p.current();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditClockProvider.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import java.time.Instant;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.time.AppClock;

/**
 * Bean Spring que "liga" AppClock no mundo JPA EntityListener via holder estático.
 */
@Component
public class AuditClockProvider {

    private final AppClock appClock;

    public AuditClockProvider(AppClock appClock) {
        this.appClock = appClock;
    }

    @PostConstruct
    void register() {
        AuditClockProviders.setProvider(this);
    }

    @PreDestroy
    void unregister() {
        AuditClockProviders.clear();
    }

    public Instant now() {
        return appClock.instant();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditClockProviders.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import java.time.Instant;

/**
 * Holder estático para permitir que EntityListeners (instanciados pelo JPA)
 * acessem o tempo via AppClock (bean Spring) sem injeção direta.
 *
 * Regra: em PRODUÇÃO o ideal é FAIL-FAST se o provider não estiver registrado,
 * porque senão você perde determinismo sem perceber.
 *
 * Se você quiser permitir fallback apenas em DEV/TEST, rode a JVM com:
 *   -Daudit.clock.systemFallback=true
 */
public final class AuditClockProviders {

    private static volatile AuditClockProvider provider;

    /**
     * Default: FAIL-FAST.
     * DEV/TEST: pode habilitar fallback com -Daudit.clock.systemFallback=true
     */
    private static final boolean SYSTEM_FALLBACK_ENABLED =
            Boolean.getBoolean("audit.clock.systemFallback");

    private AuditClockProviders() {}

    static void setProvider(AuditClockProvider provider) {
        AuditClockProviders.provider = provider;
    }

    static void clear() {
        AuditClockProviders.provider = null;
    }

    /** Usado por wiring verifier / health-checks internos. */
    public static void requireRegistered() {
        if (provider == null) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditClockProvider NÃO está registrado no AuditClockProviders. " +
                "Sem isso, a auditoria pode ficar não-determinística. " +
                "Verifique o bean AuditClockProvider e o @PostConstruct register()."
            );
        }
    }

    /** Regra padrão: tempo SEMPRE vem do AppClock (fail-fast se wiring quebrou). */
    public static Instant nowOrFail() {
        AuditClockProvider p = provider;
        if (p == null) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditClockProvider ausente (AuditClockProviders.provider == null). " +
                "Isso indica que o @PostConstruct do AuditClockProvider não executou ou o bean não foi criado."
            );
        }
        return p.now();
    }

    /**
     * Mantido por compatibilidade.
     * Em geral, prefira nowOrFail() no domínio.
     */
    public static Instant nowOrSystem() {
        AuditClockProvider p = provider;
        if (p == null) {
            if (SYSTEM_FALLBACK_ENABLED) return Instant.now();
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditClockProvider ausente e fallback desabilitado. " +
                "Para habilitar fallback apenas em DEV/TEST use: -Daudit.clock.systemFallback=true"
            );
        }
        return p.now();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditEntityListener.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import java.time.Instant;

import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;

public class AuditEntityListener {

    @PrePersist
    public void prePersist(Object entity) {
        if (!(entity instanceof Auditable auditable)) return;

        // FAIL-FAST se wiring quebrou (provider ausente)
        AuditActor actor = AuditActorProviders.currentOrFail();
        Instant now = AuditClockProviders.nowOrFail();

        auditable.getAudit().onCreate(actor, now);

        if (entity instanceof SoftDeletable softDeletable
                && softDeletable.isDeleted()
                && auditable.getAudit().getDeletedAt() == null) {
            auditable.getAudit().onDelete(actor, now);
        }
    }

    @PreUpdate
    public void preUpdate(Object entity) {
        if (!(entity instanceof Auditable auditable)) return;

        AuditActor actor = AuditActorProviders.currentOrFail();
        Instant now = AuditClockProviders.nowOrFail();

        auditable.getAudit().onUpdate(actor, now);

        if (entity instanceof SoftDeletable softDeletable
                && softDeletable.isDeleted()
                && auditable.getAudit().getDeletedAt() == null) {
            auditable.getAudit().onDelete(actor, now);
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditWiringVerifier.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Component;

@Component
public class AuditWiringVerifier {

    @PostConstruct
    public void verifyAuditWiring() {
        // FAIL-FAST no startup se o wiring quebrou
        AuditActorProviders.requireRegistered();
        AuditClockProviders.requireRegistered();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentGateway.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentGateway {
    MERCADOPAGO, STRIPE, PAGSEGURO, MANUAL
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentMethod.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentMethod {
    PIX, BOLETO, CREDIT_CARD, DEBIT_CARD, TRANSFER, CASH
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentStatus.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentStatus {
    PENDING("Pendente"),
    COMPLETED("Concluído"),
    FAILED("Falhou"),
    REFUNDED("Reembolsado"),
    CANCELLED("Cancelado"),
    EXPIRED("Expirado");

    private final String description;

    PaymentStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    public boolean isSuccessful() {
        return this == COMPLETED;
    }

    public boolean isFinal() {
        return this != PENDING;
    }

    public static PaymentStatus fromString(String status) {
        if (status == null) return PENDING;
        try {
            return PaymentStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            return PENDING;
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/common/EntityOrigin.java
============================================================
package brito.com.multitenancy001.shared.domain.common;

/**
 * Origem de criação de entidades administrativas (seed, painel, integrações).
 *
 * Mantida em shared para evitar duplicação e vazamento de boundary
 * (controlplane <-> tenant).
 */
public enum EntityOrigin {
    BUILT_IN,
    ADMIN,
    API
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/executor/PublicExecutor.java
============================================================
package brito.com.multitenancy001.shared.executor;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Component
public class PublicExecutor {

    // ---------------------------------------------------------------------
    // ✅ NOVO PADRÃO (semântico)
    // ---------------------------------------------------------------------

    public <T> T runInPublicSchema(Supplier<T> supplier) {
        return run(supplier);
    }

    public void runInPublicSchema(Runnable runnable) {
        run(runnable);
    }

    public TenantContext.Scope publicSchemaScope() {
        return TenantContext.publicScope();
    }

    // ---------------------------------------------------------------------
    // ✅ API ATUAL (mantida)
    // ---------------------------------------------------------------------

    public <T> T run(Supplier<T> supplier) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            return supplier.get();
        }
    }

    public void run(Runnable runnable) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            runnable.run();
        }
    }

    // aliases semânticos (opcional, mas ajuda muito leitura)
    public <T> T inPublic(Supplier<T> supplier) { return runInPublicSchema(supplier); }
    public void inPublic(Runnable runnable) { runInPublicSchema(runnable); }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/executor/PublicUnitOfWork.java
============================================================
package brito.com.multitenancy001.shared.executor;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.infrastructure.persistence.TransactionExecutor;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class PublicUnitOfWork {

    private final PublicExecutor publicExecutor;
    private final TransactionExecutor transactionExecutor;

    // REQUIRED
    public <T> T tx(Supplier<T> fn) {
        return publicExecutor.run(() -> transactionExecutor.inPublicTx(fn));
    }

    public void tx(Runnable fn) {
        publicExecutor.run(() -> transactionExecutor.inPublicTx(fn));
    }

    // REQUIRES_NEW
    public <T> T requiresNew(Supplier<T> fn) {
        return publicExecutor.run(() -> transactionExecutor.inPublicRequiresNew(fn));
    }

    public void requiresNew(Runnable fn) {
        publicExecutor.run(() -> transactionExecutor.inPublicRequiresNew(fn));
    }

    // READ ONLY
    public <T> T readOnly(Supplier<T> fn) {
        return publicExecutor.run(() -> transactionExecutor.inPublicReadOnlyTx(fn));
    }

    public void readOnly(Runnable fn) {
        publicExecutor.run(() -> transactionExecutor.inPublicReadOnlyTx(fn));
    }

    // REQUIRES_NEW READ ONLY
    public <T> T requiresNewReadOnly(Supplier<T> fn) {
        return publicExecutor.run(() -> transactionExecutor.inPublicRequiresNewReadOnly(fn));
    }

    public void requiresNewReadOnly(Runnable fn) {
        publicExecutor.run(() -> transactionExecutor.inPublicRequiresNewReadOnly(fn));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/kernel/error/ApiException.java
============================================================
package brito.com.multitenancy001.shared.kernel.error;

import lombok.Getter;

import java.util.List;

@Getter
public class ApiException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final String error;
    private final int status;

    // ✅ extras padronizados (opcionais)
    private final String field;
    private final String invalidValue;
    private final List<String> allowedValues;
    private final Object details;

    public ApiException(String error, String message, int status) {
        this(error, message, status, null, null, null, null);
    }

    public ApiException(String error, String message, int status, Object details) {
        this(error, message, status, null, null, null, details);
    }

    public ApiException(
            String error,
            String message,
            int status,
            String field,
            String invalidValue,
            List<String> allowedValues,
            Object details
    ) {
        super(message);
        this.error = error;
        this.status = status;
        this.field = field;
        this.invalidValue = invalidValue;
        this.allowedValues = allowedValues;
        this.details = details;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsGuard.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsGuard {

    private final AccountRepository accountRepository;
    private final AccountEntitlementsService accountEntitlementsService;
    private final PublicUnitOfWork publicUnitOfWork;

    public void assertCanCreateUser(Long accountId, long currentUsers) {
        if (accountId == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);
        }

        // ✅ PRECISA ser TX normal, porque pode provisionar entitlements
        publicUnitOfWork.tx(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            accountEntitlementsService.assertCanCreateUser(account, currentUsers);
        });
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsService.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.controlplane.accounts.app.AccountEntitlementsProvisioningService;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountEntitlements;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountEntitlementsRepository;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsService {

    private final AccountEntitlementsRepository accountEntitlementsRepository;
    private final AccountEntitlementsProvisioningService provisioningService;
    private final AccountRepository accountRepository;
    private final PublicUnitOfWork publicUnitOfWork;

    /**
     * Resolve entitlements efetivos da conta.
     * ✅ TX normal porque pode provisionar default entitlements.
     */
    public AccountEntitlementsSnapshot resolveEffective(Account account) {
        return publicUnitOfWork.tx(() -> resolveEffectiveInternal(account));
    }

    /**
     * ✅ NOVO: usado na camada TENANT para expor entitlements (apenas para TENANT_OWNER)
     * Resolve entitlements efetivos por accountId.
     * ✅ TX normal porque pode provisionar default entitlements.
     */
    public AccountEntitlementsSnapshot resolveEffectiveByAccountId(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);

        return publicUnitOfWork.tx(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            return resolveEffectiveInternal(account);
        });
    }

    // =========================================================
    // QUOTAS / ASSERTS (compatível com AccountEntitlementsGuard)
    // =========================================================

    public boolean canCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        return currentUsers < eff.maxUsers();
    }

    public void assertCanCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        if (currentUsers >= eff.maxUsers()) {
            throw new ApiException("QUOTA_MAX_USERS_REACHED", "Limite de usuários atingido para este plano", 403);
        }
    }

    public boolean canCreateProduct(Account account, long currentProducts) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        return currentProducts < eff.maxProducts();
    }

    public void assertCanCreateProduct(Account account, long currentProducts) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        if (currentProducts >= eff.maxProducts()) {
            throw new ApiException("QUOTA_MAX_PRODUCTS_REACHED", "Limite de produtos atingido para este plano", 403);
        }
    }

    public void assertCanConsumeStorage(Account account, long currentStorageMb, long deltaMb) {
        if (deltaMb < 0) {
            throw new ApiException("INVALID_STORAGE_DELTA", "deltaMb não pode ser negativo", 400);
        }

        AccountEntitlementsSnapshot eff = resolveEffective(account);
        long after = currentStorageMb + deltaMb;

        if (after > eff.maxStorageMb()) {
            throw new ApiException("QUOTA_MAX_STORAGE_REACHED", "Limite de armazenamento atingido para este plano", 403);
        }
    }

    // =========================================================
    // INTERNALS (sem tx aqui)
    // =========================================================

    private AccountEntitlementsSnapshot resolveEffectiveInternal(Account account) {
        if (account == null || account.getId() == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "Conta é obrigatória", 400);
        }

        // BUILT_IN/PLATFORM => ilimitado
        if (account.isBuiltInAccount()) {
            return AccountEntitlementsSnapshot.ofUnlimited();
        }

        AccountEntitlements ent = accountEntitlementsRepository
                .findByAccount_Id(account.getId())
                .orElse(null);

        if (ent == null) {
            // provisiona default (idempotente / race-safe)
            ent = provisioningService.ensureDefaultEntitlementsForTenant(account);
        }

        if (ent == null) {
            throw new ApiException("ENTITLEMENTS_UNEXPECTED_NULL", "Entitlements inesperadamente nulos", 500);
        }

        Integer maxUsers = safePositive(ent.getMaxUsers(), "maxUsers");
        Integer maxProducts = safePositive(ent.getMaxProducts(), "maxProducts");
        Integer maxStorageMb = safePositive(ent.getMaxStorageMb(), "maxStorageMb");

        return AccountEntitlementsSnapshot.ofLimited(maxUsers, maxProducts, maxStorageMb);
    }

    private Integer safePositive(Integer value, String field) {
        if (value == null || value <= 0) {
            throw new ApiException("INVALID_ENTITLEMENT", "Entitlement inválido: " + field, 500);
        }
        return value;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsSnapshot.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

public record AccountEntitlementsSnapshot(
        int maxUsers,
        int maxProducts,
        int maxStorageMb,
        boolean unlimited
) {

    public static AccountEntitlementsSnapshot ofUnlimited() {
        return new AccountEntitlementsSnapshot(
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                true
        );
    }

    public static AccountEntitlementsSnapshot ofLimited(int maxUsers, int maxProducts, int maxStorageMb) {
        return new AccountEntitlementsSnapshot(maxUsers, maxProducts, maxStorageMb, false);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountResolver.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import java.time.Instant;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountResolverProjection;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountResolver {

    private final AccountRepository accountRepository;
    private final AppClock appClock;
    private final PublicExecutor publicExecutor;

    public AccountSnapshot resolveActiveAccountBySlug(String slug) {
        return publicExecutor.run(() -> {
            Instant now = appClock.instant();

            AccountResolverProjection p = accountRepository.findProjectionBySlugAndDeletedFalseIgnoreCase(slug)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            if (!isOperational(p, now)) {
                throw new ApiException("ACCOUNT_INACTIVE", "Conta inativa", 403);
            }

            return new AccountSnapshot(p.getId(), p.getSchemaName(), p.getSlug(), p.getDisplayName());
        });
    }

    public AccountSnapshot resolveActiveAccountById(Long accountId) {
        if (accountId == null) throw new ApiException("INVALID_ACCOUNT", "accountId inválido", 400);
        return resolveActiveAccountByIdInternal(accountId);
    }

    private AccountSnapshot resolveActiveAccountByIdInternal(Long accountId) {
        return publicExecutor.run(() -> {
            Instant now = appClock.instant();

            AccountResolverProjection p = accountRepository.findProjectionByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            if (!isOperational(p, now)) {
                throw new ApiException("ACCOUNT_INACTIVE", "Conta inativa", 403);
            }

            return new AccountSnapshot(p.getId(), p.getSchemaName(), p.getSlug(), p.getDisplayName());
        });
    }

    private boolean isOperational(AccountResolverProjection p, Instant now) {
        if (p == null) return false;

        if ("BUILT_IN".equalsIgnoreCase(p.getOrigin())) return true;

        String status = p.getStatus();
        if ("ACTIVE".equalsIgnoreCase(status)) return true;

        if ("FREE_TRIAL".equalsIgnoreCase(status)) {
            return p.getTrialEndAt() != null && now != null && p.getTrialEndAt().isAfter(now);
        }

        return false;
    }

}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountSnapshot.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

public record AccountSnapshot(
        Long id,
        String schemaName,
        String slug,
        String displayName
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityProvisioningService.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class LoginIdentityProvisioningService {

    private final JdbcTemplate jdbcTemplate;

    public void ensureTenantIdentity(String email, Long accountId) {
        if (accountId == null) return;

        String emailNorm = EmailNormalizer.normalizeOrNull(email);
        if (emailNorm == null) return;

        jdbcTemplate.update("""
            INSERT INTO public.login_identities (email, user_type, account_id)
            VALUES (?, 'TENANT', ?)
            ON CONFLICT DO NOTHING
        """, emailNorm, accountId);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityResolver.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
@RequiredArgsConstructor
public class LoginIdentityResolver {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    public List<LoginIdentityRow> findTenantAccountsByEmail(String email) {
        String normalized = EmailNormalizer.normalizeOrNull(email);
        if (normalized == null) return List.of();

        // email é CITEXT em public.login_identities => comparação pode ser direta
        String sql = """
            select li.account_id,
                   a.display_name,
                   a.slug
              from public.login_identities li
              join public.accounts a on a.id = li.account_id
             where li.email = :email
               and li.user_type = 'TENANT'
               and a.deleted = false
        """;

        var params = new MapSqlParameterSource("email", normalized);

        return jdbcTemplate.query(sql, params, (rs, rowNum) -> new LoginIdentityRow(
                rs.getLong("account_id"),
                rs.getString("display_name"),
                rs.getString("slug")
        ));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityRow.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;





public record LoginIdentityRow(
        Long accountId,
        String displayName,
        String slug
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/AuthenticatedPrincipal.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Contrato mínimo para Principal autenticado.
 *
 * Evita acoplamento do shared/persistence com classes de infraestrutura.
 */
public interface AuthenticatedPrincipal {
    Long getUserId();
    String getEmail();
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/PermissionAuthority.java
============================================================
package brito.com.multitenancy001.shared.security;

public interface PermissionAuthority {
    String asAuthority(); // ex: "CP_USER_READ" ou "TEN_USER_READ"
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/PermissionCode.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Contrato "shared" para permissões.
 *
 * - O shared pode depender deste contrato.
 * - ControlPlane e Tenant podem implementar este contrato nos seus enums.
 * - O shared NÃO deve importar classes/enums dos bounded contexts.
 *
 * Observação:
 * - Mantemos compatibilidade com o seu modelo atual (PermissionAuthority),
 *   já que o resto do projeto usa "asAuthority()" para gerar GrantedAuthority/JWT claims.
 */
public interface PermissionCode extends PermissionAuthority {
    // marker + compatibilidade (herda asAuthority())
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/PermissionScopeValidator.java
============================================================
package brito.com.multitenancy001.shared.security;

import brito.com.multitenancy001.shared.domain.DomainException;

import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * Validador de escopo de permissões (shared).
 *
 * Objetivo:
 * - Evitar "vazamento" de permissions entre bounded contexts (TEN_ vs CP_)
 * - FAIL-FAST: nunca aceitar permission sem prefixo
 * - DDD/layered: shared não conhece enums concretos (somente contratos via PermissionCode)
 *
 * Regras:
 * - Tenant: somente "TEN_*" é aceito (nunca CP_ e nunca sem prefixo)
 * - ControlPlane: somente "CP_*" é aceito (nunca TEN_ e nunca sem prefixo)
 */
public final class PermissionScopeValidator {

    private PermissionScopeValidator() {}

    // =========================================================
    // STRICT (String): exige prefixo correto SEMPRE
    // =========================================================

    public static LinkedHashSet<String> normalizeTenantStrict(Collection<String> perms) {
        return normalizeStringStrict(perms, "TEN_", "CP_", "Tenant", "Control Plane");
    }

    public static LinkedHashSet<String> normalizeControlPlaneStrict(Collection<String> perms) {
        return normalizeStringStrict(perms, "CP_", "TEN_", "Control Plane", "Tenant");
    }

    /** Aliases (continua STRICT). */
    public static LinkedHashSet<String> normalizeTenant(Collection<String> perms) {
        return normalizeTenantStrict(perms);
    }

    public static LinkedHashSet<String> normalizeControlPlane(Collection<String> perms) {
        return normalizeControlPlaneStrict(perms);
    }

    private static LinkedHashSet<String> normalizeStringStrict(
            Collection<String> perms,
            String expectedPrefix,
            String forbiddenPrefix,
            String expectedContextLabel,
            String forbiddenContextLabel
    ) {
        LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (String p : perms) {
            if (p == null) continue;

            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith(forbiddenPrefix)) {
                throw new DomainException("Permission de " + forbiddenContextLabel
                        + " não é permitida no " + expectedContextLabel + ": " + x);
            }

            // ✅ NUNCA aceita permissão sem prefixo
            if (!x.startsWith(expectedPrefix)) {
                throw new DomainException("Permission inválida (esperado prefixo " + expectedPrefix
                        + ") no " + expectedContextLabel + ": " + x);
            }

            out.add(x);
        }

        return out;
    }

    // =========================================================
    // STRICT (Tipado): enums implementando PermissionCode
    // =========================================================

    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> normalizeTenantPermissions(Collection<T> perms) {
        return normalizeTypedStrict(perms, "TEN_", "CP_", "Tenant", "Control Plane");
    }

    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> normalizeControlPlanePermissions(Collection<T> perms) {
        return normalizeTypedStrict(perms, "CP_", "TEN_", "Control Plane", "Tenant");
    }

    private static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> normalizeTypedStrict(
            Collection<T> perms,
            String expectedPrefix,
            String forbiddenPrefix,
            String expectedContextLabel,
            String forbiddenContextLabel
    ) {
        LinkedHashSet<T> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (T p : perms) {
            if (p == null) continue;

            String code = p.asAuthority(); // contrato shared
            if (code == null) continue;

            String x = code.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith(forbiddenPrefix)) {
                throw new DomainException("Permission de " + forbiddenContextLabel
                        + " não é permitida no " + expectedContextLabel + ": " + x);
            }

            // ✅ NUNCA aceita permissão sem prefixo
            if (!x.startsWith(expectedPrefix)) {
                throw new DomainException("Permission inválida (esperado prefixo " + expectedPrefix
                        + ") no " + expectedContextLabel + ": " + x);
            }

            out.add(p);
        }

        return out;
    }

    // =========================================================
    // COMPAT (métodos antigos) - agora STRICT (sem auto-prefix)
    // =========================================================

    /** Compat: valida lista string no contexto CP. */
    public static void assertNoTenantPermissionLeak(List<String> permissions) {
        if (permissions == null) return;

        for (String p : permissions) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("TEN_")) {
                throw new DomainException("Permission de Tenant não é permitida no Control Plane: " + x);
            }

            // ✅ também falha se vier sem prefixo
            if (!x.startsWith("CP_")) {
                throw new DomainException("Permission inválida no Control Plane (esperado prefixo CP_): " + x);
            }
        }
    }

    /** Compat: valida lista string no contexto Tenant. */
    public static void assertNoControlPlanePermissionLeak(List<String> permissions) {
        if (permissions == null) return;

        for (String p : permissions) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("CP_")) {
                throw new DomainException("Permission de Control Plane não é permitida no Tenant: " + x);
            }

            // ✅ também falha se vier sem prefixo
            if (!x.startsWith("TEN_")) {
                throw new DomainException("Permission inválida no Tenant (esperado prefixo TEN_): " + x);
            }
        }
    }

    public static void assertAllTenantScoped(Collection<String> permissions) {
        assertNoControlPlanePermissionLeak(toList(permissions));
    }

    public static void assertAllControlPlaneScoped(Collection<String> permissions) {
        assertNoTenantPermissionLeak(toList(permissions));
    }

    // =========================================================
    // COMPAT: validate*Strict(Set<EnumPermission>)
    //
    // Seu TenantUserService chama validateTenantPermissionsStrict(Set<TenantPermission>)
    // então mantemos o nome para não sair editando call-sites.
    // =========================================================

    /**
     * Valida permissões tipadas do Tenant (TEN_*), estritamente.
     * - Não aceita CP_*
     * - Não aceita sem prefixo
     */
    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> validateTenantPermissionsStrict(Set<T> perms) {
        return normalizeTenantPermissions(perms);
    }

    /**
     * Valida permissões tipadas do ControlPlane (CP_*), estritamente.
     * - Não aceita TEN_*
     * - Não aceita sem prefixo
     */
    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> validateControlPlanePermissionsStrict(Set<T> perms) {
        return normalizeControlPlanePermissions(perms);
    }

    private static List<String> toList(Collection<String> c) {
        if (c == null) return List.of();
        return c.stream().filter(Objects::nonNull).toList();
    }
    
    
 // =========================================================
 // REQUIRE (fail-fast) - helpers para domínio tipado
 // =========================================================

 /**
  * Fail-fast: exige permissão TEN_*
  * (shared não importa enum do Tenant; usa PermissionCode/Enum/String)
  */
 public static void requireTenantPermission(Object permission) {
     requireScopedPermission(permission, "TEN_", "CP_", "Tenant", "Control Plane");
 }

 /**
  * Fail-fast: exige permissão CP_*
  * (shared não importa enum do ControlPlane; usa PermissionCode/Enum/String)
  */
 public static void requireControlPlanePermission(Object permission) {
     requireScopedPermission(permission, "CP_", "TEN_", "Control Plane", "Tenant");
 }

 private static void requireScopedPermission(
         Object permission,
         String expectedPrefix,
         String forbiddenPrefix,
         String expectedContextLabel,
         String forbiddenContextLabel
 ) {
     if (permission == null) {
         throw new DomainException("Permission é obrigatória no contexto " + expectedContextLabel);
     }

     final String code;
     if (permission instanceof PermissionCode pc) {
         code = pc.asAuthority(); // contrato shared
     } else if (permission instanceof Enum<?> e) {
         code = e.name(); // fallback (nome do enum)
     } else if (permission instanceof String s) {
         code = s;
     } else {
         throw new DomainException("Tipo inválido de permission (" + permission.getClass().getName()
                 + ") no contexto " + expectedContextLabel);
     }

     if (code == null || code.trim().isEmpty()) {
         throw new DomainException("Permission inválida/vazia no contexto " + expectedContextLabel);
     }

     String x = code.trim();

     if (x.startsWith(forbiddenPrefix)) {
         throw new DomainException("Permission de " + forbiddenContextLabel
                 + " não é permitida no " + expectedContextLabel + ": " + x);
     }

     if (!x.startsWith(expectedPrefix)) {
         throw new DomainException("Permission inválida (esperado prefixo " + expectedPrefix
                 + ") no " + expectedContextLabel + ": " + x);
     }
 }

}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/RoleAuthority.java
============================================================
package brito.com.multitenancy001.shared.security;

import java.io.Serializable;

public interface RoleAuthority extends Serializable {
    String asAuthority();
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/SystemRoleName.java
============================================================
package brito.com.multitenancy001.shared.security;

public enum SystemRoleName {

    // CONTROL PLANE
    CONTROLPLANE_OWNER,
    CONTROLPLANE_ADMIN,
    CONTROLPLANE_BILLING_MANAGER,
    CONTROLPLANE_SUPPORT,
    CONTROLPLANE_VIEWER,
    CONTROLPLANE_OPERATOR,

    // TENANT
    TENANT_OWNER,
    TENANT_ADMIN,
    TENANT_SUPPORT,
    TENANT_USER,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    public boolean isControlPlane() { return name().startsWith("CONTROLPLANE_"); }
    public boolean isTenant() { return name().startsWith("TENANT_"); }

    public static SystemRoleName fromString(String value) {
        if (value == null || value.isBlank()) return null;
        return SystemRoleName.valueOf(value.trim().toUpperCase());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/TenantRoleName.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Role do contexto Tenant exposta como "contrato" compartilhado.
 *
 * Motivo: permitir tipagem no ControlPlane (DTOs, contratos, integrações)
 * sem depender de tenant.security.TenantRole (bounded context Tenant).
 *
 * Regra: este enum não deve conter comportamento de segurança, apenas nomes.
 */
public enum TenantRoleName {

	TENANT_OWNER,
    TENANT_ADMIN,
    TENANT_SUPPORT,
    TENANT_USER,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    public static TenantRoleName fromString(String value) {
        if (value == null || value.isBlank()) return null;
        return TenantRoleName.valueOf(value.trim().toUpperCase());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/TenantSystemRoleMapper.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Mapper do contrato TenantRoleName -> SystemRoleName
 * (fica em shared porque TenantRoleName já está em shared).
 */
public final class TenantSystemRoleMapper {

    private TenantSystemRoleMapper() {}

    public static SystemRoleName toSystemRole(TenantRoleName role) {
        if (role == null) return null;
        // nomes são iguais
        return SystemRoleName.valueOf(role.name());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/time/AppClock.java
============================================================
package brito.com.multitenancy001.shared.time;

import java.time.Clock;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;

/**
 * Regra do projeto:
 * - "Instante real" => Instant (UTC) via AppClock.instant()
 * - "Data civil"    => LocalDate via AppClock.today()
 *
 * Não expor Instant para evitar "meio termo perigoso" que vaza pro domínio.
 */
public interface AppClock {

    Clock clock();

    default Instant instant() {
        return Instant.now(clock());
    }

    default ZoneId zone() {
        return clock().getZone();
    }

    /**
     * Data civil no fuso do clock (normalmente UTC, mas pode ser ZoneId do tenant
     * em cenários específicos de UX).
     */
    default LocalDate today() {
        return LocalDate.now(clock());
    }

    default long epochMillis() {
        return instant().toEpochMilli();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/time/SystemAppClock.java
============================================================
package brito.com.multitenancy001.shared.time;

import java.time.Clock;

import org.springframework.stereotype.Component;

@Component
public class SystemAppClock implements AppClock {

    private final Clock clock;

    public SystemAppClock(Clock clock) {
        this.clock = clock;
    }

    @Override
    public Clock clock() {
        return clock;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/validation/ValidationPatterns.java
============================================================
package brito.com.multitenancy001.shared.validation;

/**
 * Padrões de validação reutilizáveis em todo o sistema
 */
public final class ValidationPatterns {

    // ⚠️ APENAS PARA TESTE/DEV - NUNCA EM PRODUÇÃO!
    // Password: mínimo 3 caracteres, letras/números
    public static final String PASSWORD_PATTERN = "^[a-zA-Z0-9]{3,}$";

    // Email
    public static final String EMAIL_PATTERN = "^[A-Za-z0-9+_.-]+@(.+)$";

    // Nome
    public static final String NAME_PATTERN = "^[a-zA-ZÀ-ÿ\\s'-]{2,100}$";

    // Telefone
    public static final String PHONE_PATTERN = "^(\\(?\\d{2}\\)?)?\\s?\\d{4,5}-?\\d{4}$";

    public static final String CNPJ_PATTERN = "^\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}$";
    public static final String CPF_PATTERN  = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$";
    public static final String CEP_PATTERN  = "^\\d{5}-\\d{3}$";

    public static final String URL_PATTERN = "^(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?$";

    public static final String TIMEZONE_PATTERN = "^[A-Za-z_]+/[A-Za-z_]+$";
    public static final String LOCALE_PATTERN   = "^[a-z]{2}_[A-Z]{2}$";
    public static final String CURRENCY_PATTERN = "^[A-Z]{3}$";
    public static final String COLOR_PATTERN    = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
    public static final String IP_PATTERN       = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
    public static final String UUID_PATTERN     = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";

    public static final String PERMISSION_PATTERN = "^[A-Z_]+$";

    private ValidationPatterns() {
        throw new UnsupportedOperationException("Classe utilitária - não instanciável");
    }

    public static boolean isValid(String value, String pattern) {
        return value != null && value.matches(pattern);
    }

    public static void validatePassword(String password) {
        if (password == null || !password.matches(PASSWORD_PATTERN)) {
            throw new IllegalArgumentException("Senha inválida");
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantAuthController.java
============================================================
package brito.com.multitenancy001.tenant.auth.api;

import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.tenant.auth.api.dto.AccountSelectionOption;
import brito.com.multitenancy001.tenant.auth.api.dto.AccountSelectionRequiredResponse;
import brito.com.multitenancy001.tenant.auth.api.dto.TenantLoginConfirmRequest;
import brito.com.multitenancy001.tenant.auth.api.dto.TenantLoginInitRequest;
import brito.com.multitenancy001.tenant.auth.api.dto.TenantRefreshRequest;
import brito.com.multitenancy001.tenant.auth.app.TenantAuthService;
import brito.com.multitenancy001.tenant.auth.app.command.TenantLoginConfirmCommand;
import brito.com.multitenancy001.tenant.auth.app.command.TenantLoginInitCommand;
import brito.com.multitenancy001.tenant.auth.app.dto.TenantLoginResult;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantAuthController {

    private final TenantAuthService tenantAuthService;

    private static JwtResponse toHttp(JwtResult r) {
        if (r == null) return null;
        return new JwtResponse(
                r.accessToken(),
                r.refreshToken(),
                r.tokenType(),
                r.userId(),
                r.email(),
                r.role(),
                r.accountId(),
                r.tenantSchema()
        );
    }

    /**
     * 1) email + password
     * - se 1 conta: retorna JWT (200)
     * - se >1 conta: retorna ACCOUNT_SELECTION_REQUIRED com candidates (409)
     */
    @PostMapping("/login")
    public ResponseEntity<?> loginTenant(@Valid @RequestBody TenantLoginInitRequest req) {

        TenantLoginInitCommand cmd = new TenantLoginInitCommand(req.email(), req.password());
        TenantLoginResult result = tenantAuthService.loginInit(cmd);

        if (result instanceof TenantLoginResult.LoginSuccess ok) {
            return ResponseEntity.ok(toHttp(ok.jwt()));
        }

        if (result instanceof TenantLoginResult.AccountSelectionRequired sel) {
            List<AccountSelectionOption> candidates = sel.candidates().stream()
                    .map(o -> new AccountSelectionOption(o.accountId(), o.displayName(), o.slug()))
                    .toList();

            AccountSelectionRequiredResponse body = new AccountSelectionRequiredResponse(
                    "ACCOUNT_SELECTION_REQUIRED",
                    "Selecione a conta/empresa",
                    sel.challengeId(),
                    candidates
            );

            return ResponseEntity.status(409).body(body);
        }

        return ResponseEntity.internalServerError().body(
                new AccountSelectionRequiredResponse(
                        "INTERNAL_ERROR",
                        "Resposta inesperada do servidor",
                        null,
                        null
                )
        );
    }

    /**
     * 2) challengeId + (accountId OU slug)
     * - retorna JWT (200)
     */
    @PostMapping("/login/confirm")
    public ResponseEntity<JwtResponse> confirmTenantLogin(@Valid @RequestBody TenantLoginConfirmRequest req) {

        // ✅ AJUSTE: UUID -> String, para bater com TenantLoginConfirmCommand(String, Long, String)
        TenantLoginConfirmCommand cmd = new TenantLoginConfirmCommand(
                req.challengeId().toString(),
                req.accountId(),
                req.slug()
        );

        JwtResult jwt = tenantAuthService.loginConfirm(cmd);
        return ResponseEntity.ok(toHttp(jwt));
    }

    /**
     * 3) refresh token
     * - retorna novo accessToken (200)
     */
    @PostMapping("/refresh")
    public ResponseEntity<JwtResponse> refresh(@Valid @RequestBody TenantRefreshRequest req) {
        JwtResult jwt = tenantAuthService.refresh(req.refreshToken());
        return ResponseEntity.ok(toHttp(jwt));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantPasswordController.java
============================================================
package brito.com.multitenancy001.tenant.auth.api;

import brito.com.multitenancy001.tenant.auth.api.dto.ForgotPasswordRequest;
import brito.com.multitenancy001.tenant.auth.api.dto.ResetPasswordRequest;
import brito.com.multitenancy001.tenant.users.app.TenantUserFacade;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/password")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantPasswordController {

    private final TenantUserFacade tenantUserFacade;

    // Gera token de reset de senha para usuário tenant (por slug + email).
    @PostMapping("/forgot")
    public ResponseEntity<String> forgotPassword(@Valid @RequestBody ForgotPasswordRequest forgotPasswordRequest) {
        tenantUserFacade.generatePasswordResetToken(forgotPasswordRequest.slug(), forgotPasswordRequest.email());
        return ResponseEntity.ok("Token gerado");
    }

    // Redefine a senha do usuário tenant validando o token de reset.
    @PostMapping("/reset")
    public ResponseEntity<String> resetPassword(@Valid @RequestBody ResetPasswordRequest resetPasswordRequest) {
        tenantUserFacade.resetPasswordWithToken(resetPasswordRequest.token(), resetPasswordRequest.newPassword());
        return ResponseEntity.ok("Senha redefinida com sucesso");
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/AccountSelectionOption.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

public record AccountSelectionOption(
        Long accountId,
        String displayName,
        String slug
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/AccountSelectionRequiredResponse.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import java.util.List;

public record AccountSelectionRequiredResponse(
        String code,
        String message,
        String challengeId,
        List<AccountSelectionOption> candidates
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/ForgotPasswordRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ForgotPasswordRequest(
        @NotBlank String slug,
        @NotBlank @Email String email
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/ResetPasswordRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record ResetPasswordRequest(
        @NotBlank String token,
        @NotBlank
        @Pattern(
          regexp = ValidationPatterns.PASSWORD_PATTERN,
          message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais"
        )
        String newPassword
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantLoginConfirmRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.NotNull;

import java.util.UUID;

public record TenantLoginConfirmRequest(
        @NotNull(message = "challengeId é obrigatório")
        UUID challengeId,

        // Preferencial: usar slug
        String slug,

        // Compat opcional (se você quiser confirmar por id)
        Long accountId
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantLoginInitRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record TenantLoginInitRequest(
        @NotBlank(message = "email é obrigatório")
        @Email(message = "email inválido")
        String email,

        @NotBlank(message = "password é obrigatório")
        String password
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantRefreshRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.NotBlank;

public record TenantRefreshRequest(
        @NotBlank(message = "refreshToken é obrigatório")
        String refreshToken
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantSelectionOption.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

public record TenantSelectionOption(
        Long accountId,
        String displayName,
        String slug
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantAuthService.java
============================================================
package brito.com.multitenancy001.tenant.auth.app;

import brito.com.multitenancy001.infrastructure.publicschema.auth.TenantLoginChallenge;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.SecurityConstants;
import brito.com.multitenancy001.infrastructure.security.authorities.AuthoritiesFactory;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.audit.AuthEventAuditService;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountResolver;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountSnapshot;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityResolver;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityRow;
import brito.com.multitenancy001.shared.security.SystemRoleName;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.auth.app.command.TenantLoginConfirmCommand;
import brito.com.multitenancy001.tenant.auth.app.command.TenantLoginInitCommand;
import brito.com.multitenancy001.tenant.auth.app.dto.AccountSelectionOptionData;
import brito.com.multitenancy001.tenant.auth.app.dto.TenantLoginResult;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TenantAuthService {

    private static final String INVALID_USER_MSG = "usuario ou senha invalidos";

    private final org.springframework.security.authentication.AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;

    private final AccountResolver accountResolver;
    private final LoginIdentityResolver loginIdentityResolver;

    private final TenantUserRepository tenantUserRepository;
    private final PublicExecutor publicExecutor;
    private final TenantExecutor tenantExecutor;

    private final TenantLoginChallengeService tenantLoginChallengeService;
    private final AppClock appClock;

    // append-only auth_events
    private final AuthEventAuditService authEventAuditService;

    private static String normalizeEmailRequired(String raw) {
        String email = EmailNormalizer.normalizeOrNull(raw);
        if (!StringUtils.hasText(email)) {
            throw new ApiException("INVALID_LOGIN", "email é obrigatório", 400);
        }
        return email;
    }

    private static SystemRoleName toSystemRoleOrNull(Object tenantRoleEnum) {
        if (tenantRoleEnum == null) return null;
        return SystemRoleName.fromString(tenantRoleEnum.toString());
    }

    /**
     * 1) INIT LOGIN
     * email + password
     * - se 1 conta (e senha ok): JWT
     * - se >1 conta:
     *      - valida senha tentando autenticar em cada tenant candidato
     *      - se validar em 0: BadCredentials
     *      - se validar em 1: JWT direto
     *      - se validar em >1: ACCOUNT_SELECTION_REQUIRED (challenge contém SOMENTE allowedAccountIds)
     */
    public TenantLoginResult loginInit(TenantLoginInitCommand cmd) {

        if (cmd == null) throw new ApiException("INVALID_REQUEST", "Requisição inválida", 400);
        if (!StringUtils.hasText(cmd.email())) throw new ApiException("INVALID_LOGIN", "email é obrigatório", 400);
        if (!StringUtils.hasText(cmd.password())) throw new ApiException("INVALID_LOGIN", "password é obrigatório", 400);

        final String email = normalizeEmailRequired(cmd.email());
        final String password = cmd.password();

        authEventAuditService.record(
                "tenant",
                "LOGIN_INIT",
                "ATTEMPT",
                email,
                null,
                null,
                null,
                "{\"stage\":\"init\"}"
        );

        try {
            // PUBLIC — descobre quais contas (tenants) têm esse email cadastrado
            List<LoginIdentityRow> identities = publicExecutor.run(() ->
                    loginIdentityResolver.findTenantAccountsByEmail(email)
            );

            if (identities == null || identities.isEmpty()) {
                authEventAuditService.record("tenant", "LOGIN_INIT", "FAILURE", email, null, null, null,
                        "{\"reason\":\"no_candidates\"}");
                throw new BadCredentialsException(INVALID_USER_MSG);
            }

            // ids candidatos (distinct + preserva ordem)
            LinkedHashSet<Long> candidateAccountIds = identities.stream()
                    .map(LoginIdentityRow::accountId)
                    .filter(Objects::nonNull)
                    .collect(Collectors.toCollection(LinkedHashSet::new));

            if (candidateAccountIds.isEmpty()) {
                authEventAuditService.record("tenant", "LOGIN_INIT", "FAILURE", email, null, null, null,
                        "{\"reason\":\"empty_candidate_ids\"}");
                throw new BadCredentialsException(INVALID_USER_MSG);
            }

            // Se só tem 1 conta, autentica direto (senha validada aqui mesmo)
            if (candidateAccountIds.size() == 1) {
                Long accountId = candidateAccountIds.iterator().next();
                AccountSnapshot account = accountResolver.resolveActiveAccountById(accountId);

                TenantLoginResult result = doTenantAuthentication(account, email, password);

                authEventAuditService.record("tenant", "LOGIN_INIT", "SUCCESS", email, null, accountId, account.schemaName(),
                        "{\"mode\":\"single_account\"}");

                return result;
            }

            // ✅ MULTI-CONTA: validar password em cada tenant candidato
            LinkedHashSet<Long> allowedAccountIds = new LinkedHashSet<>();

            for (Long accountId : candidateAccountIds) {
                AccountSnapshot account;
                try {
                    account = accountResolver.resolveActiveAccountById(accountId);
                } catch (Exception ex) {
                    continue;
                }

                boolean ok = verifyPasswordInTenant(account, email, password);
                if (ok) {
                    allowedAccountIds.add(accountId);
                }
            }

            if (allowedAccountIds.isEmpty()) {
                authEventAuditService.record("tenant", "LOGIN_INIT", "FAILURE", email, null, null, null,
                        "{\"reason\":\"bad_credentials_multi_account\"}");
                throw new BadCredentialsException(INVALID_USER_MSG);
            }

            // Se só 1 conta validou senha, entra direto nela
            if (allowedAccountIds.size() == 1) {
                Long accountId = allowedAccountIds.iterator().next();
                AccountSnapshot account = accountResolver.resolveActiveAccountById(accountId);

                TenantLoginResult result = doTenantAuthentication(account, email, password);

                authEventAuditService.record("tenant", "LOGIN_INIT", "SUCCESS", email, null, accountId, account.schemaName(),
                        "{\"mode\":\"multi_account_but_single_match\"}");

                return result;
            }

            // Se mais de 1 conta validou, cria challenge SOMENTE com allowedAccountIds
            UUID challengeId = tenantLoginChallengeService.createChallenge(email, allowedAccountIds);

            List<AccountSelectionOptionData> selection = new ArrayList<>();
            for (Long id : allowedAccountIds) {
                selection.add(tryResolveOption(id));
            }

            authEventAuditService.record("tenant", "ACCOUNT_SELECTION_REQUIRED", "SUCCESS", email, null, null, null,
                    "{\"challengeId\":\"" + challengeId + "\",\"candidates\":" + allowedAccountIds.size() + "}");

            return new TenantLoginResult.AccountSelectionRequired(
                    challengeId.toString(),
                    selection
            );

        } catch (BadCredentialsException e) {
            authEventAuditService.record("tenant", "LOGIN_INIT", "FAILURE", email, null, null, null,
                    "{\"reason\":\"bad_credentials\"}");
            throw e;
        } catch (ApiException e) {
            authEventAuditService.record("tenant", "LOGIN_INIT", "FAILURE", email, null, null, null,
                    "{\"reason\":\"api_exception\",\"code\":\"" + e.getError() + "\"}");
            throw e;
        } catch (Exception e) {
            authEventAuditService.record("tenant", "LOGIN_INIT", "FAILURE", email, null, null, null,
                    "{\"reason\":\"unexpected\"}");
            throw e;
        }
    }

    /**
     * 2) CONFIRM LOGIN
     * challengeId + (accountId OU slug) => JWT
     *
     * ✅ Seguro porque:
     * - o challenge foi criado somente após validar password
     * - e contém apenas accountIds onde password foi OK
     */
    public JwtResult loginConfirm(TenantLoginConfirmCommand cmd) {

        if (cmd == null) throw new ApiException("INVALID_REQUEST", "Requisição inválida", 400);
        if (!StringUtils.hasText(cmd.challengeId())) throw new ApiException("INVALID_CHALLENGE", "challengeId é obrigatório", 400);

        UUID challengeId;
        try {
            challengeId = UUID.fromString(cmd.challengeId());
        } catch (Exception e) {
            throw new ApiException("INVALID_CHALLENGE", "challengeId inválido", 400);
        }

        TenantLoginChallenge challenge = tenantLoginChallengeService.requireValid(challengeId);
        final String email = challenge.getEmail();

        authEventAuditService.record("tenant", "LOGIN_CONFIRM", "ATTEMPT", email, null, null, null,
                "{\"challengeId\":\"" + challengeId + "\"}");

        Long accountId = cmd.accountId();
        String slug = StringUtils.hasText(cmd.slug()) ? cmd.slug().trim() : null;

        if (accountId == null && slug == null) {
            authEventAuditService.record("tenant", "LOGIN_CONFIRM", "FAILURE", email, null, null, null,
                    "{\"reason\":\"missing_selection\"}");
            throw new ApiException("INVALID_SELECTION", "Informe accountId ou slug", 400);
        }

        AccountSnapshot account;
        if (accountId != null) {
            account = accountResolver.resolveActiveAccountById(accountId);
        } else {
            account = accountResolver.resolveActiveAccountBySlug(slug);
        }

        if (account == null || account.id() == null) {
            authEventAuditService.record("tenant", "LOGIN_CONFIRM", "FAILURE", email, null, null, null,
                    "{\"reason\":\"account_not_found\"}");
            throw new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404);
        }

        Set<Long> allowedAccountIds = challenge.candidateAccountIds();
        if (allowedAccountIds == null || !allowedAccountIds.contains(account.id())) {
            authEventAuditService.record("tenant", "LOGIN_CONFIRM", "FAILURE", email, null, account.id(), account.schemaName(),
                    "{\"reason\":\"account_not_in_challenge\"}");
            throw new ApiException("INVALID_SELECTION", "Conta não pertence ao challenge", 400);
        }

        tenantLoginChallengeService.markUsed(challenge);

        JwtResult jwt = issueJwtForAccountAndEmail(account, email);

        authEventAuditService.record("tenant", "LOGIN_SUCCESS", "SUCCESS", email, jwt.userId(), account.id(), account.schemaName(),
                "{\"mode\":\"challenge_confirm\"}");

        return jwt;
    }

    /**
     * 3) REFRESH — retorna novo accessToken, reutilizando refreshToken
     */
    public JwtResult refresh(String refreshToken) {

        if (!StringUtils.hasText(refreshToken)) {
            throw new ApiException("INVALID_REFRESH", "refreshToken é obrigatório", 400);
        }

        authEventAuditService.record("tenant", "TOKEN_REFRESH", "ATTEMPT", null, null, null, null,
                "{\"stage\":\"start\"}");

        if (!jwtTokenProvider.validateToken(refreshToken)) {
            authEventAuditService.record("tenant", "TOKEN_REFRESH", "FAILURE", null, null, null, null,
                    "{\"reason\":\"invalid_token\"}");
            throw new ApiException("INVALID_REFRESH", "refreshToken inválido", 401);
        }

        String authDomain = jwtTokenProvider.getAuthDomain(refreshToken);
        if (!SecurityConstants.AuthDomains.REFRESH.equals(authDomain)) {
            authEventAuditService.record("tenant", "TOKEN_REFRESH", "FAILURE", null, null, null, null,
                    "{\"reason\":\"invalid_auth_domain\"}");
            throw new ApiException("INVALID_REFRESH", "refreshToken inválido", 401);
        }

        String tenantSchema = jwtTokenProvider.getTenantSchemaFromToken(refreshToken);
        if (!StringUtils.hasText(tenantSchema)) {
            authEventAuditService.record("tenant", "TOKEN_REFRESH", "FAILURE", null, null, null, null,
                    "{\"reason\":\"missing_tenant_schema\"}");
            throw new ApiException("INVALID_REFRESH", "refreshToken inválido", 401);
        }

        String email = EmailNormalizer.normalizeOrNull(jwtTokenProvider.getEmailFromToken(refreshToken));
        if (!StringUtils.hasText(email)) {
            authEventAuditService.record("tenant", "TOKEN_REFRESH", "FAILURE", null, null, null, tenantSchema,
                    "{\"reason\":\"missing_email\"}");
            throw new ApiException("INVALID_REFRESH", "refreshToken inválido", 401);
        }

        Long accountId = jwtTokenProvider.getAccountIdFromToken(refreshToken);
        if (accountId == null) {
            authEventAuditService.record("tenant", "TOKEN_REFRESH", "FAILURE", email, null, null, tenantSchema,
                    "{\"reason\":\"missing_account_id\"}");
            throw new ApiException("INVALID_REFRESH", "refreshToken inválido (accountId ausente)", 401);
        }

        return tenantExecutor.run(tenantSchema, () -> {

            TenantUser user = tenantUserRepository
                    .findByEmailAndAccountIdAndDeletedFalse(email, accountId)
                    .orElseThrow(() -> new ApiException("INVALID_REFRESH", "refreshToken inválido", 401));

            if (user.isSuspendedByAccount() || user.isSuspendedByAdmin() || user.isDeleted()) {
                throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
            }

            tenantUserRepository.updateLastLogin(user.getId(), appClock.instant());

            var authorities = AuthoritiesFactory.forTenant(user);

            AuthenticatedUserContext principal = AuthenticatedUserContext.fromTenantUser(
                    user,
                    tenantSchema,
                    appClock.instant(),
                    authorities
            );

            Authentication authentication = new UsernamePasswordAuthenticationToken(
                    principal,
                    null,
                    authorities
            );

            String newAccessToken = jwtTokenProvider.generateTenantToken(
                    authentication,
                    accountId,
                    tenantSchema
            );

            SystemRoleName role = toSystemRoleOrNull(user.getRole());

            // ✅ usa seu construtor curto (tokenType default Bearer)
            JwtResult result = new JwtResult(
                    newAccessToken,
                    refreshToken,
                    user.getId(),
                    user.getEmail(),
                    role,
                    accountId,
                    tenantSchema
            );

            authEventAuditService.record("tenant", "TOKEN_REFRESH", "SUCCESS", result.email(), result.userId(), result.accountId(), result.tenantSchema(),
                    "{\"stage\":\"completed\"}");

            return result;
        });
    }

    // =========================================================
    // Helpers
    // =========================================================

    private boolean verifyPasswordInTenant(AccountSnapshot account, String email, String password) {
        if (account == null || account.id() == null) return false;

        String tenantSchema = account.schemaName();
        if (!StringUtils.hasText(tenantSchema)) return false;

        try {
            return tenantExecutor.run(tenantSchema, () -> {
                Authentication authRequest = new UsernamePasswordAuthenticationToken(email, password);
                authenticationManager.authenticate(authRequest);

                tenantUserRepository
                        .findByEmailAndAccountIdAndDeletedFalse(email, account.id())
                        .orElseThrow(() -> new UsernameNotFoundException("Usuário não encontrado"));

                return true;
            });
        } catch (BadCredentialsException e) {
            return false;
        } catch (UsernameNotFoundException e) {
            return false;
        } catch (InternalAuthenticationServiceException e) {
            return false;
        } catch (Exception e) {
            return false;
        }
    }

    private AccountSelectionOptionData tryResolveOption(Long accountId) {
        if (accountId == null) {
            return new AccountSelectionOptionData(null, "Conta", null);
        }

        try {
            AccountSnapshot a = accountResolver.resolveActiveAccountById(accountId);
            if (a == null) {
                return new AccountSelectionOptionData(accountId, "Conta " + accountId, null);
            }
            return new AccountSelectionOptionData(a.id(), a.displayName(), a.slug());
        } catch (ApiException ex) {
            return new AccountSelectionOptionData(accountId, "Conta " + accountId, null);
        } catch (Exception ex) {
            return new AccountSelectionOptionData(accountId, "Conta " + accountId, null);
        }
    }

    private TenantLoginResult doTenantAuthentication(AccountSnapshot account, String email, String password) {
        if (account == null || account.id() == null) {
            throw new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404);
        }

        String tenantSchema = account.schemaName();
        if (!StringUtils.hasText(tenantSchema)) {
            throw new ApiException("ACCOUNT_NOT_READY", "Conta sem schema", 409);
        }

        try {
            return tenantExecutor.run(tenantSchema, () -> {

                Authentication authRequest = new UsernamePasswordAuthenticationToken(email, password);
                authenticationManager.authenticate(authRequest);

                TenantUser user = tenantUserRepository
                        .findByEmailAndAccountIdAndDeletedFalse(email, account.id())
                        .orElseThrow(() -> new UsernameNotFoundException("Usuário não encontrado"));

                if (user.isSuspendedByAccount() || user.isSuspendedByAdmin() || user.isDeleted()) {
                    throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
                }

                tenantUserRepository.updateLastLogin(user.getId(), appClock.instant());

                var authorities = AuthoritiesFactory.forTenant(user);

                AuthenticatedUserContext principal = AuthenticatedUserContext.fromTenantUser(
                        user,
                        tenantSchema,
                        appClock.instant(),
                        authorities
                );

                Authentication finalAuth = new UsernamePasswordAuthenticationToken(
                        principal,
                        null,
                        authorities
                );

                String accessToken = jwtTokenProvider.generateTenantToken(finalAuth, account.id(), tenantSchema);

                String refreshToken = jwtTokenProvider.generateRefreshToken(
                        user.getEmail(),
                        tenantSchema,
                        account.id()
                );

                SystemRoleName role = toSystemRoleOrNull(user.getRole());

                JwtResult jwt = new JwtResult(
                        accessToken,
                        refreshToken,
                        user.getId(),
                        user.getEmail(),
                        role,
                        account.id(),
                        tenantSchema
                );

                authEventAuditService.record("tenant", "LOGIN_SUCCESS", "SUCCESS", user.getEmail(), user.getId(), account.id(), tenantSchema,
                        "{\"mode\":\"password\"}");

                return new TenantLoginResult.LoginSuccess(jwt);
            });
        } catch (BadCredentialsException e) {
            authEventAuditService.record("tenant", "LOGIN_FAILURE", "FAILURE", email, null, account.id(), tenantSchema,
                    "{\"reason\":\"bad_credentials\"}");
            throw e;
        } catch (UsernameNotFoundException e) {
            authEventAuditService.record("tenant", "LOGIN_FAILURE", "FAILURE", email, null, account.id(), tenantSchema,
                    "{\"reason\":\"user_not_found\"}");
            throw new BadCredentialsException(INVALID_USER_MSG);
        } catch (InternalAuthenticationServiceException e) {
            authEventAuditService.record("tenant", "LOGIN_FAILURE", "FAILURE", email, null, account.id(), tenantSchema,
                    "{\"reason\":\"internal_auth\"}");
            throw new BadCredentialsException(INVALID_USER_MSG);
        } catch (Exception e) {
            authEventAuditService.record("tenant", "LOGIN_FAILURE", "FAILURE", email, null, account.id(), tenantSchema,
                    "{\"reason\":\"unexpected\"}");
            throw new ApiException("AUTH_ERROR", "Falha ao autenticar", 500);
        }
    }

    private JwtResult issueJwtForAccountAndEmail(AccountSnapshot account, String email) {
        if (account == null || account.id() == null) {
            throw new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404);
        }

        String tenantSchema = account.schemaName();
        if (!StringUtils.hasText(tenantSchema)) {
            throw new ApiException("ACCOUNT_NOT_READY", "Conta sem schema", 409);
        }

        return tenantExecutor.run(tenantSchema, () -> {

            TenantUser user = tenantUserRepository
                    .findByEmailAndAccountIdAndDeletedFalse(email, account.id())
                    .orElseThrow(() -> new ApiException("INVALID_LOGIN", "Usuário não encontrado", 401));

            if (user.isSuspendedByAccount() || user.isSuspendedByAdmin() || user.isDeleted()) {
                throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
            }

            tenantUserRepository.updateLastLogin(user.getId(), appClock.instant());

            var authorities = AuthoritiesFactory.forTenant(user);

            AuthenticatedUserContext principal = AuthenticatedUserContext.fromTenantUser(
                    user,
                    tenantSchema,
                    appClock.instant(),
                    authorities
            );

            Authentication authentication = new UsernamePasswordAuthenticationToken(
                    principal,
                    null,
                    authorities
            );

            String accessToken = jwtTokenProvider.generateTenantToken(authentication, account.id(), tenantSchema);

            String refreshToken = jwtTokenProvider.generateRefreshToken(
                    user.getEmail(),
                    tenantSchema,
                    account.id()
            );

            SystemRoleName role = toSystemRoleOrNull(user.getRole());

            return new JwtResult(
                    accessToken,
                    refreshToken,
                    user.getId(),
                    user.getEmail(),
                    role,
                    account.id(),
                    tenantSchema
            );
        });
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginChallengeService.java
============================================================
package brito.com.multitenancy001.tenant.auth.app;

import brito.com.multitenancy001.infrastructure.publicschema.auth.TenantLoginChallenge;
import brito.com.multitenancy001.infrastructure.publicschema.auth.TenantLoginChallengeRepository;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.Instant;
import java.util.Set;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class TenantLoginChallengeService {

    private static final Duration DEFAULT_EXPIRES_IN = Duration.ofMinutes(10);

    private final TenantLoginChallengeRepository tenantLoginChallengeRepository;
    private final AppClock appClock;

    private Instant now() {
        return appClock.instant();
    }

    public UUID createChallenge(String email, Set<Long> candidateAccountIds) {
        String emailNorm = EmailNormalizer.normalizeOrNull(email);
        if (emailNorm == null) {
            throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
        }

        if (candidateAccountIds == null || candidateAccountIds.isEmpty()) {
            throw new ApiException("INVALID_CHALLENGE", "candidateAccountIds é obrigatório", 400);
        }

        Instant createdAt = now();
        Instant expiresAt = createdAt.plus(DEFAULT_EXPIRES_IN);

        TenantLoginChallenge challenge = new TenantLoginChallenge();
        challenge.setId(UUID.randomUUID());
        challenge.setEmail(emailNorm);
        challenge.setCandidateAccountIds(candidateAccountIds);
        challenge.setCreatedAt(createdAt);
        challenge.setExpiresAt(expiresAt);
        challenge.setUsedAt(null);

        tenantLoginChallengeRepository.save(challenge);

        return challenge.getId();
    }

    /**
     * ✅ Agora usa o método do repository:
     * findByIdAndExpiresAtAfterAndUsedAtIsNull(id, now)
     */
    public TenantLoginChallenge requireValid(UUID challengeId) {
        if (challengeId == null) {
            throw new ApiException("INVALID_CHALLENGE", "challengeId é obrigatório", 400);
        }

        TenantLoginChallenge challenge = tenantLoginChallengeRepository
                .findByIdAndExpiresAtAfterAndUsedAtIsNull(challengeId, now())
                .orElseThrow(() -> new ApiException(
                        "CHALLENGE_NOT_FOUND",
                        "Challenge não encontrado, expirado ou já usado",
                        404
                ));

        return challenge;
    }

    public void markUsed(TenantLoginChallenge challenge) {
        if (challenge == null || challenge.getId() == null) return;
        if (challenge.isUsed()) return;

        challenge.setUsedAt(now());
        tenantLoginChallengeRepository.save(challenge);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/command/TenantLoginConfirmCommand.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.command;

public record TenantLoginConfirmCommand(
        String challengeId,
        Long accountId,
        String slug
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/command/TenantLoginInitCommand.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.command;

public record TenantLoginInitCommand(
        String email,
        String password
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/AccountSelectionOptionData.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.dto;

public record AccountSelectionOptionData(
        Long accountId,
        String displayName,
        String slug
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/TenantLoginResult.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.dto;

import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;

import java.util.List;

public sealed interface TenantLoginResult {

    record LoginSuccess(JwtResult jwt) implements TenantLoginResult {}

    /**
     * Quando o mesmo email existe em mais de uma conta/empresa.
     * challengeId: String (UUID em texto) para simplificar tráfego no app layer e no controller.
     */
    record AccountSelectionRequired(
            String challengeId,
            List<AccountSelectionOptionData> candidates
    ) implements TenantLoginResult {}
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/billing/api/TenantPaymentController.java
============================================================
package brito.com.multitenancy001.tenant.billing.api;

import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.tenant.billing.app.TenantBillingService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/billing/payments")
@RequiredArgsConstructor
public class TenantPaymentController {

    private final TenantBillingService tenantBillingService;

    @GetMapping("/account/{accountId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_BILLING_READ.name())")
    public ResponseEntity<List<PaymentResponse>> listPayments(@PathVariable Long accountId) {
        return ResponseEntity.ok(tenantBillingService.listPaymentsForAccount(accountId));
    }

    @GetMapping("/account/{accountId}/{paymentId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_BILLING_READ.name())")
    public ResponseEntity<PaymentResponse> getPayment(@PathVariable Long accountId, @PathVariable Long paymentId) {
        return ResponseEntity.ok(tenantBillingService.getPaymentForAccount(accountId, paymentId));
    }

    @GetMapping("/account/{accountId}/has-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_BILLING_READ.name())")
    public ResponseEntity<Boolean> hasActive(@PathVariable Long accountId) {
        return ResponseEntity.ok(tenantBillingService.hasActivePayment(accountId));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/billing/app/TenantBillingService.java
============================================================
package brito.com.multitenancy001.tenant.billing.app;

import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.billing.PaymentQueryFacade;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantBillingService {

    private final PaymentQueryFacade paymentQueryFacade;

    @Transactional(readOnly = true)
    public List<PaymentResponse> listPaymentsForAccount(Long accountId) {
        return paymentQueryFacade.listByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentForAccount(Long accountId, Long paymentId) {
        return paymentQueryFacade.getByAccount(accountId, paymentId);
    }

    @Transactional(readOnly = true)
    public boolean hasActivePayment(Long accountId) {
        return paymentQueryFacade.hasActivePayment(accountId);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/TenantCategoryController.java
============================================================
package brito.com.multitenancy001.tenant.categories.api;

import brito.com.multitenancy001.tenant.categories.app.TenantCategoryService;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/categories")
@RequiredArgsConstructor
public class TenantCategoryController {

    private final TenantCategoryService tenantCategoryService;

    // Lista categorias (não-deletadas) do tenant.
    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Category>> listAll() {
        return ResponseEntity.ok(tenantCategoryService.findAll());
    }

    // Lista categorias ativas (não-deletadas) do tenant.
    @GetMapping("/active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Category>> listActive() {
        return ResponseEntity.ok(tenantCategoryService.findActive());
    }

    // Busca categoria por id (escopo: tenant).
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<Category> getById(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.findById(id));
    }

    // Pesquisa categorias por nome (escopo: tenant).
    @GetMapping("/search")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Category>> search(@RequestParam("name") String name) {
        return ResponseEntity.ok(tenantCategoryService.searchByName(name));
    }

    // Lista categorias com flags administrativas (incluir deletadas/inativas).
    @GetMapping("/admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Category>> listAdmin(
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        return ResponseEntity.ok(tenantCategoryService.findWithFlags(includeDeleted, includeInactive));
    }

    // Cria categoria no tenant.
    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Category> create(@Valid @RequestBody Category category) {
        Category saved = tenantCategoryService.create(category);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    // Atualiza categoria do tenant (substituição completa).
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Category> update(@PathVariable Long id, @RequestBody Category category) {
        return ResponseEntity.ok(tenantCategoryService.update(id, category));
    }

    // Alterna status ativo/inativo da categoria.
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Category> toggleActive(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.toggleActive(id));
    }

    // Soft-delete de categoria no tenant.
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Void> softDelete(@PathVariable Long id) {
        tenantCategoryService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    // Restaura categoria previamente deletada (soft-delete).
    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Category> restore(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.restore(id));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/TenantSubcategoryController.java
============================================================
package brito.com.multitenancy001.tenant.categories.api;

import brito.com.multitenancy001.tenant.categories.app.TenantSubcategoryService;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/subcategories")
@RequiredArgsConstructor
public class TenantSubcategoryController {

    private final TenantSubcategoryService tenantSubcategoryService;

    // Lista subcategorias (não-deletadas) do tenant.
    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Subcategory>> listAll() {
        return ResponseEntity.ok(tenantSubcategoryService.findAll());
    }

    // Lista subcategorias ativas (não-deletadas) do tenant.
    @GetMapping("/active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Subcategory>> listActive() {
        return ResponseEntity.ok(tenantSubcategoryService.findActive());
    }

    // Busca subcategoria por id (escopo: tenant).
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<Subcategory> getById(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.findById(id));
    }

    // Lista subcategorias por categoria (default: apenas ativas e não-deletadas).
    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Subcategory>> listByCategory(@PathVariable Long categoryId) {
        return ResponseEntity.ok(tenantSubcategoryService.findByCategoryId(categoryId));
    }

    // Lista subcategorias por categoria com flags administrativas (incluir deletadas/inativas).
    @GetMapping("/category/{categoryId}/admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Subcategory>> listByCategoryAdmin(
            @PathVariable Long categoryId,
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        return ResponseEntity.ok(
                tenantSubcategoryService.findByCategoryIdAdmin(categoryId, includeDeleted, includeInactive)
        );
    }

    // Cria subcategoria dentro de uma categoria.
    @PostMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Subcategory> create(
            @PathVariable Long categoryId,
            @Valid @RequestBody Subcategory subcategory
    ) {
        Subcategory saved = tenantSubcategoryService.create(categoryId, subcategory);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    // Atualiza subcategoria do tenant (substituição completa).
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Subcategory> update(@PathVariable Long id, @RequestBody Subcategory subcategory) {
        return ResponseEntity.ok(tenantSubcategoryService.update(id, subcategory));
    }

    // Alterna status ativo/inativo da subcategoria.
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Subcategory> toggleActive(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.toggleActive(id));
    }

    // Soft-delete de subcategoria no tenant.
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Void> softDelete(@PathVariable Long id) {
        tenantSubcategoryService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    // Restaura subcategoria previamente deletada (soft-delete).
    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.name())")
    public ResponseEntity<Subcategory> restore(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.restore(id));
    }

    // Lista subcategorias por categoria (NOT DELETED, inclui inativas).
    @GetMapping("/category/{categoryId}/not-deleted")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.name())")
    public ResponseEntity<List<Subcategory>> listByCategoryNotDeleted(@PathVariable Long categoryId) {
        return ResponseEntity.ok(tenantSubcategoryService.findByCategoryIdNotDeleted(categoryId));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/app/TenantCategoryService.java
============================================================
package brito.com.multitenancy001.tenant.categories.app;

import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.persistence.TenantCategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantCategoryService {

    private final TenantCategoryRepository tenantCategoryRepository;

    // =========================================================
    // READ
    // =========================================================

    @Transactional(readOnly = true)
    public Category findById(Long id) {
        if (id == null) throw new ApiException("CATEGORY_ID_REQUIRED", "id é obrigatório", 400);

        Category c = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (c.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Categoria deletada não pode ser consultada", 404);
        }

        return c;
    }

    @Transactional(readOnly = true)
    public List<Category> findAll() {
        return tenantCategoryRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Category> findActive() {
        return tenantCategoryRepository.findNotDeletedActive();
    }

    @Transactional(readOnly = true)
    public List<Category> searchByName(String name) {
        if (!StringUtils.hasText(name)) {
            throw new ApiException("CATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }
        return tenantCategoryRepository.findNotDeletedByNameContainingIgnoreCase(name.trim());
    }

    @Transactional(readOnly = true)
    public List<Category> findWithFlags(boolean includeDeleted, boolean includeInactive) {
        return tenantCategoryRepository.findWithFlags(includeDeleted, includeInactive);
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Category create(Category category) {
        if (category == null) throw new ApiException("CATEGORY_REQUIRED", "payload é obrigatório", 400);
        if (!StringUtils.hasText(category.getName())) {
            throw new ApiException("CATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }

        String name = category.getName().trim();

        tenantCategoryRepository.findNotDeletedByNameIgnoreCase(name)
                .ifPresent(existing -> {
                    throw new ApiException("CATEGORY_NAME_ALREADY_EXISTS", "Categoria já existe: " + name, 409);
                });

        category.setName(name);
        category.setDeleted(false);
        category.setActive(true);

        return tenantCategoryRepository.save(category);
    }

    @Transactional
    public Category update(Long id, Category req) {
        if (id == null) throw new ApiException("CATEGORY_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("CATEGORY_REQUIRED", "payload é obrigatório", 400);

        Category existing = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido alterar categoria deletada", 409);
        }

        if (StringUtils.hasText(req.getName())) {
            String newName = req.getName().trim();

            tenantCategoryRepository.findNotDeletedByNameIgnoreCase(newName)
                    .ifPresent(other -> {
                        if (!other.getId().equals(id)) {
                            throw new ApiException("CATEGORY_NAME_ALREADY_EXISTS", "Categoria já existe: " + newName, 409);
                        }
                    });

            existing.setName(newName);
        }

        return tenantCategoryRepository.save(existing);
    }

    @Transactional
    public Category toggleActive(Long id) {
        Category category = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (category.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido alterar categoria deletada", 409);
        }

        category.setActive(!category.isActive());
        return tenantCategoryRepository.save(category);
    }

    @Transactional
    public void softDelete(Long id) {
        Category category = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        // ✅ domínio não recebe Instant: auditoria é feita pelo AuditEntityListener + AppClock
        category.softDelete();
        tenantCategoryRepository.save(category);
    }

    @Transactional
    public Category restore(Long id) {
        Category category = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        category.restore();
        return tenantCategoryRepository.save(category);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/app/TenantSubcategoryService.java
============================================================
package brito.com.multitenancy001.tenant.categories.app;

import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import brito.com.multitenancy001.tenant.categories.persistence.TenantCategoryRepository;
import brito.com.multitenancy001.tenant.categories.persistence.TenantSubcategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantSubcategoryService {

    private final TenantSubcategoryRepository tenantSubcategoryRepository;
    private final TenantCategoryRepository tenantCategoryRepository;
 

    // =========================================================
    // READ
    // =========================================================

    @Transactional(readOnly = true)
    public Subcategory findById(Long id) {
        if (id == null) throw new ApiException("SUBCATEGORY_ID_REQUIRED", "id é obrigatório", 400);

        Subcategory s = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (s.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Subcategoria deletada não pode ser consultada", 404);
        }

        return s;
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findAll() {
        return tenantSubcategoryRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findActive() {
        return tenantSubcategoryRepository.findActiveNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findByCategoryId(Long categoryId) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findActiveNotDeletedByCategoryId(categoryId);
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findByCategoryIdAdmin(Long categoryId, boolean includeDeleted, boolean includeInactive) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findByCategoryWithFlags(categoryId, includeDeleted, includeInactive);
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Subcategory create(Long categoryId, Subcategory req) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        if (req == null) throw new ApiException("SUBCATEGORY_REQUIRED", "payload é obrigatório", 400);
        if (!StringUtils.hasText(req.getName())) {
            throw new ApiException("SUBCATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }

        Category category = tenantCategoryRepository.findById(categoryId)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + categoryId, 404));

        if (category.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido criar subcategoria em categoria deletada", 409);
        }

        String name = req.getName().trim();

        // uk_subcategories_name_category (category_id, name)
        tenantSubcategoryRepository.findNotDeletedByCategoryIdAndNameIgnoreCase(categoryId, name)
                .ifPresent(existing -> {
                    throw new ApiException("SUBCATEGORY_ALREADY_EXISTS",
                            "Subcategoria já existe na categoria " + categoryId + ": " + name, 409);
                });

        Subcategory sub = new Subcategory();
        sub.setCategory(category);
        sub.setName(name);
        sub.setDeleted(false);
        sub.setActive(true);

        return tenantSubcategoryRepository.save(sub);
    }

    @Transactional
    public Subcategory update(Long id, Subcategory req) {
        if (id == null) throw new ApiException("SUBCATEGORY_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("SUBCATEGORY_REQUIRED", "payload é obrigatório", 400);

        Subcategory existing = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Não é permitido alterar subcategoria deletada", 409);
        }

        if (StringUtils.hasText(req.getName())) {
            String newName = req.getName().trim();
            Long categoryId = existing.getCategory().getId();

            tenantSubcategoryRepository.findNotDeletedByCategoryIdAndNameIgnoreCase(categoryId, newName)
                    .ifPresent(other -> {
                        if (!other.getId().equals(id)) {
                            throw new ApiException("SUBCATEGORY_ALREADY_EXISTS",
                                    "Subcategoria já existe na categoria " + categoryId + ": " + newName, 409);
                        }
                    });

            existing.setName(newName);
        }

        return tenantSubcategoryRepository.save(existing);
    }

    @Transactional
    public Subcategory toggleActive(Long id) {
        Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (sub.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Não é permitido alterar subcategoria deletada", 409);
        }

        sub.setActive(!sub.isActive());
        return tenantSubcategoryRepository.save(sub);
    }

    @Transactional
    public void softDelete(Long id) {
        Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        sub.softDelete();

        tenantSubcategoryRepository.save(sub);
    }

    @Transactional
    public Subcategory restore(Long id) {
        Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        sub.restore();
        return tenantSubcategoryRepository.save(sub);
    }
    
    @Transactional(readOnly = true)
    public List<Subcategory> findByCategoryIdNotDeleted(Long categoryId) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findNotDeletedByCategoryId(categoryId);
    }

}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/domain/Category.java
============================================================
package brito.com.multitenancy001.tenant.categories.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
        name = "categories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_categories_name",
                columnNames = "name"
        )
)
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
public class Category implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Embedded
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        this.active = false;
        // deletedAt será setado pelo AuditEntityListener (audit.deletedAt)
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        this.active = true;
        // deletedAt será limpo pelo AuditEntityListener se você quiser (opcional).
        // Se sua política for manter histórico, NÃO limpe. Se for "restore limpa", ajuste listener.
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/domain/Subcategory.java
============================================================
package brito.com.multitenancy001.tenant.categories.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
        name = "subcategories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_subcategories_name_category",
                columnNames = {"category_id", "name"}
        )
)
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
public class Subcategory implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_subcategories_category")
    )
    private Category category;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Embedded
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        this.active = true;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/persistence/TenantCategoryRepository.java
============================================================
package brito.com.multitenancy001.tenant.categories.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.categories.domain.Category;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantCategoryRepository extends JpaRepository<Category, Long> {

    // =========
    // Normal (default): NÃO retorna deletados
    // =========

    @Query("select c from Category c where c.deleted = false order by c.name asc")
    List<Category> findNotDeleted();

    @Query("select c from Category c where c.deleted = false and c.active = true order by c.name asc")
    List<Category> findNotDeletedActive();

    @Query("select c from Category c where c.deleted = false and lower(c.name) = lower(:name)")
    Optional<Category> findNotDeletedByNameIgnoreCase(@Param("name") String name);

    @Query("select c from Category c where c.deleted = false and lower(c.name) like lower(concat('%', :name, '%')) order by c.name asc")
    List<Category> findNotDeletedByNameContainingIgnoreCase(@Param("name") String name);

    // =========
    // Admin: flags (includeDeleted / includeInactive)
    // =========

    @Query("""
           select c from Category c
           where (:includeDeleted = true or c.deleted = false)
             and (:includeInactive = true or c.active = true)
           order by c.name asc
           """)
    List<Category> findWithFlags(@Param("includeDeleted") boolean includeDeleted,
                                 @Param("includeInactive") boolean includeInactive);
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/persistence/TenantSubcategoryRepository.java
============================================================
package brito.com.multitenancy001.tenant.categories.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.categories.domain.Subcategory;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantSubcategoryRepository extends JpaRepository<Subcategory, Long> {

    @Query("select s from Subcategory s join fetch s.category where s.id = :id")
    Optional<Subcategory> findByIdWithCategory(@Param("id") Long id);

    // =========
    // Default: NÃO retorna deletados
    // =========

    @Query("""
           select s from Subcategory s
           where s.deleted = false
           order by s.name asc
           """)
    List<Subcategory> findNotDeleted();

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.active = true
           order by s.name asc
           """)
    List<Subcategory> findActiveNotDeleted();

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.category.id = :categoryId
           order by s.name asc
           """)
    List<Subcategory> findNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.active = true and s.category.id = :categoryId
           order by s.name asc
           """)
    List<Subcategory> findActiveNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
           select s from Subcategory s
           where s.deleted = false
             and s.category.id = :categoryId
             and lower(s.name) = lower(:name)
           """)
    Optional<Subcategory> findNotDeletedByCategoryIdAndNameIgnoreCase(@Param("categoryId") Long categoryId,
                                                                      @Param("name") String name);

    // =========
    // Admin: flags (includeDeleted / includeInactive)
    // =========

    @Query("""
           select s from Subcategory s
           where s.category.id = :categoryId
             and (:includeDeleted = true or s.deleted = false)
             and (:includeInactive = true or s.active = true)
           order by s.name asc
           """)
    List<Subcategory> findByCategoryWithFlags(@Param("categoryId") Long categoryId,
                                              @Param("includeDeleted") boolean includeDeleted,
                                              @Param("includeInactive") boolean includeInactive);
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/debug/api/TenantDebugController.java
============================================================
package brito.com.multitenancy001.tenant.debug.api;

import brito.com.multitenancy001.shared.context.TenantContext;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
@RequiredArgsConstructor
public class TenantDebugController {

    private final JdbcTemplate jdbcTemplate;

    /**
     * DEBUG/DEV:
     * Força o tenant via header X-Tenant para validar o multi-tenant SEM depender de JWT.
     *
     * Exemplo:
     * GET /api/tenant/_debug/schema
     * Header: X-Tenant: t_foton_devices_6d79df
     */
    @GetMapping("/api/tenant/_debug/schema")
    public Map<String, Object> schema(
            @RequestHeader(name = "X-Tenant", required = false) String tenantHeaderRaw
    ) {
        String tenantHeader = (tenantHeaderRaw == null ? null : tenantHeaderRaw.trim());
        String tenantNormalized = StringUtils.hasText(tenantHeader) ? tenantHeader : null;

        // valida formato de schema (mesma ideia do provider/resolver)
        boolean valid = (tenantNormalized == null) || tenantNormalized.matches("^[a-zA-Z_][a-zA-Z0-9_]*$");

        // se inválido, fica PUBLIC (null)
        String tenantToBind = valid ? tenantNormalized : null;

        try (TenantContext.Scope ignored = TenantContext.scope(tenantToBind)) {

            String currentSchema = jdbcTemplate.queryForObject("select current_schema()", String.class);
            String searchPath = jdbcTemplate.queryForObject("show search_path", String.class);

            return Map.of(
                    "tenant_header", tenantNormalized, // null se não veio / veio vazio
                    "current_schema", currentSchema,
                    "search_path", searchPath,
                    "header_valid", valid
            );
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/api/TenantMeController.java
============================================================
package brito.com.multitenancy001.tenant.me.api;

import brito.com.multitenancy001.tenant.me.api.dto.TenantMeResponse;
import brito.com.multitenancy001.tenant.me.api.dto.UpdateMyProfileRequest;
import brito.com.multitenancy001.tenant.users.app.TenantUserFacade;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/tenant/me")
public class TenantMeController {

    private final TenantUserFacade tenantUserFacade;

    // ✅ Perfil do usuário logado
    @GetMapping
    public ResponseEntity<TenantMeResponse> me() {
        return ResponseEntity.ok(tenantUserFacade.getMyProfile());
    }

    // ✅ Atualiza perfil do usuário logado (SAFE whitelist)
    @PutMapping
    public ResponseEntity<TenantMeResponse> update(@Valid @RequestBody UpdateMyProfileRequest req) {
        return ResponseEntity.ok(tenantUserFacade.updateMyProfile(req));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/api/dto/TenantMeResponse.java
============================================================
package brito.com.multitenancy001.tenant.me.api.dto;

import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.security.SystemRoleName;

public record TenantMeResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        SystemRoleName role,
        String phone,
        String avatarUrl,
        String timezone,
        String locale,
        boolean mustChangePassword,
        EntityOrigin origin,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/api/dto/UpdateMyProfileRequest.java
============================================================
package brito.com.multitenancy001.tenant.me.api.dto;

import jakarta.validation.constraints.Size;
import org.hibernate.validator.constraints.URL;

public record UpdateMyProfileRequest(
        @Size(min = 2, max = 100, message = "name deve ter entre 2 e 100 caracteres")
        String name,

        @Size(max = 20, message = "phone deve ter no máximo 20 caracteres")
        String phone,

        @Size(max = 500, message = "avatarUrl deve ter no máximo 500 caracteres")
        @URL(protocol = "https", message = "avatarUrl deve ser uma URL https válida")
        String avatarUrl,

        @Size(max = 20, message = "locale deve ter no máximo 20 caracteres")
        String locale,

        @Size(max = 60, message = "timezone deve ter no máximo 60 caracteres")
        String timezone
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/TenantProductController.java
============================================================
package brito.com.multitenancy001.tenant.products.api;

import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import brito.com.multitenancy001.tenant.products.api.dto.ProductResponse;
import brito.com.multitenancy001.tenant.products.api.dto.ProductUpsertRequest;
import brito.com.multitenancy001.tenant.products.api.dto.SupplierProductCountResponse;
import brito.com.multitenancy001.tenant.products.api.mapper.ProductApiMapper;
import brito.com.multitenancy001.tenant.products.app.TenantProductService;
import brito.com.multitenancy001.tenant.products.domain.Product;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/tenant/products")
@RequiredArgsConstructor
public class TenantProductController {

    private final ProductApiMapper productApiMapper;
    private final TenantProductService tenantProductService;

    // Busca produto por id (escopo: tenant).
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<ProductResponse> getById(@PathVariable UUID id) {
        Product product = tenantProductService.findById(id);
        return ResponseEntity.ok(productApiMapper.toResponse(product));
    }

    // Lista produtos por categoria (default: somente não-deletados/ativos conforme service).
    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getProductsByCategory(@PathVariable Long categoryId) {
        List<Product> products = tenantProductService.findByCategoryId(categoryId);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por categoria com flags administrativas (incluir deletados/inativos).
    @GetMapping("/category/{categoryId}/admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getProductsByCategoryAdmin(
            @PathVariable Long categoryId,
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        List<Product> products = tenantProductService.findByCategoryId(categoryId, includeDeleted, includeInactive);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por categoria e subcategoria opcional.
    @GetMapping("/category/{categoryId}/optional")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getProductsByCategoryOptionalSubcategory(
            @PathVariable Long categoryId,
            @RequestParam(value = "subcategoryId", required = false) Long subcategoryId
    ) {
        List<Product> products = tenantProductService.findByCategoryAndOptionalSubcategory(categoryId, subcategoryId);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por subcategoria.
    @GetMapping("/subcategory/{subcategoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getProductsBySubcategory(@PathVariable Long subcategoryId) {
        List<Product> products = tenantProductService.findBySubcategoryId(subcategoryId);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por marca.
    @GetMapping("/brand/{brand}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getProductsByBrand(@PathVariable String brand) {
        List<Product> products = tenantProductService.findByBrand(brand);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos ativos.
    @GetMapping("/active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getActiveProducts() {
        List<Product> products = tenantProductService.findActiveProducts();
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Pesquisa produtos por nome.
    @GetMapping("/name")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getProductsByName(@RequestParam("name") String name) {
        List<Product> products = tenantProductService.findByName(name);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Pesquisa produtos por nome com paginação.
    @GetMapping("/name/paged")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<Page<ProductResponse>> getProductsByNamePaged(
            @RequestParam("name") String name,
            Pageable pageable
    ) {
        Page<Product> page = tenantProductService.findByNamePaged(name, pageable);
        return ResponseEntity.ok(page.map(productApiMapper::toResponse));
    }

    // Lista produtos por faixa de preço.
    @GetMapping("/price-between")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getProductsByPriceBetween(
            @RequestParam("minPrice") BigDecimal minPrice,
            @RequestParam("maxPrice") BigDecimal maxPrice
    ) {
        List<Product> products = tenantProductService.findByPriceBetween(minPrice, maxPrice);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por fornecedor.
    @GetMapping("/supplier/{supplierId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> getProductsBySupplier(@PathVariable UUID supplierId) {
        List<Product> products = tenantProductService.findBySupplierId(supplierId);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Filtra produtos por múltiplos critérios (nome/preço/estoque).
    @GetMapping("/filter")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> filterProducts(
            @RequestParam("name") String name,
            @RequestParam("minPrice") BigDecimal minPrice,
            @RequestParam("maxPrice") BigDecimal maxPrice,
            @RequestParam("minStock") Integer minStock,
            @RequestParam("maxStock") Integer maxStock
    ) {
        List<Product> products =
                tenantProductService.findByNameAndPriceAndStock(name, minPrice, maxPrice, minStock, maxStock);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Retorna contagem de produtos agrupada por fornecedor.
    @GetMapping("/stats/count-by-supplier")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<SupplierProductCountResponse>> countBySupplier() {
        return ResponseEntity.ok(tenantProductService.countProductsBySupplier());
    }

    // Retorna o valor total do inventário (estoque * custo) do tenant.
    @GetMapping("/inventory-value")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_INVENTORY_READ.name())")
    public ResponseEntity<BigDecimal> getTotalInventoryValue() {
        BigDecimal value = tenantProductService.calculateTotalInventoryValue();
        return ResponseEntity.ok(value != null ? value : BigDecimal.ZERO);
    }

    // Retorna a contagem de produtos com estoque baixo.
    @GetMapping("/low-stock/count")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_INVENTORY_READ.name())")
    public ResponseEntity<Long> countLowStockProducts(@RequestParam(defaultValue = "10") Integer threshold) {
        Long count = tenantProductService.countLowStockProducts(threshold);
        return ResponseEntity.ok(count != null ? count : 0L);
    }

    // Alterna status ativo/inativo do produto.
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_WRITE.name())")
    public ResponseEntity<ProductResponse> toggleActive(@PathVariable UUID id) {
        Product updated = tenantProductService.toggleActive(id);
        return ResponseEntity.ok(productApiMapper.toResponse(updated));
    }

    // Atualiza o custo do produto (costPrice).
    @PatchMapping("/{id}/cost-price")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_WRITE.name())")
    public ResponseEntity<ProductResponse> updateCostPrice(
            @PathVariable UUID id,
            @RequestParam BigDecimal costPrice
    ) {
        Product updatedProduct = tenantProductService.updateCostPrice(id, costPrice);
        return ResponseEntity.ok(productApiMapper.toResponse(updatedProduct));
    }

    // Cria produto detalhado a partir de um request DTO (upsert).
    @PostMapping("/detailed")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_WRITE.name())")
    public ResponseEntity<ProductResponse> createDetailedProduct(@Valid @RequestBody ProductUpsertRequest req) {

        Product product = new Product();
        product.setName(req.name());
        product.setDescription(req.description());
        product.setSku(req.sku());
        product.setPrice(req.price());
        product.setStockQuantity(req.stockQuantity());
        product.setMinStock(req.minStock());
        product.setMaxStock(req.maxStock());
        product.setCostPrice(req.costPrice());
        product.setBrand(req.brand());
        product.setWeightKg(req.weightKg());
        product.setDimensions(req.dimensions());
        product.setBarcode(req.barcode());
        product.setActive(req.active());

        Category category = new Category();
        category.setId(req.categoryId());
        product.setCategory(category);

        if (req.subcategoryId() != null) {
            Subcategory sub = new Subcategory();
            sub.setId(req.subcategoryId());
            product.setSubcategory(sub);
        }

        if (req.supplierId() != null) {
            Supplier supplier = new Supplier();
            supplier.setId(req.supplierId());
            product.setSupplier(supplier);
        }

        Product savedProduct = tenantProductService.create(product);
        return ResponseEntity.status(HttpStatus.CREATED).body(productApiMapper.toResponse(savedProduct));
    }

    // "Any" (pode incluir deleted/inactive) - útil para telas/admin/relatórios internos
    @GetMapping("/category/{categoryId}/any")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> listAnyByCategory(@PathVariable Long categoryId) {
        return ResponseEntity.ok(
                tenantProductService.findAnyByCategoryId(categoryId)
                        .stream()
                        .map(productApiMapper::toResponse)
                        .toList()
        );
    }

    @GetMapping("/subcategory/{subcategoryId}/any")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> listAnyBySubcategory(@PathVariable Long subcategoryId) {
        return ResponseEntity.ok(
                tenantProductService.findAnyBySubcategoryId(subcategoryId)
                        .stream()
                        .map(productApiMapper::toResponse)
                        .toList()
        );
    }

    @GetMapping("/brand/{brand}/any")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.name())")
    public ResponseEntity<List<ProductResponse>> listAnyByBrand(@PathVariable String brand) {
        return ResponseEntity.ok(
                tenantProductService.findAnyByBrandIgnoreCase(brand)
                        .stream()
                        .map(productApiMapper::toResponse)
                        .toList()
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/dto/ProductResponse.java
============================================================
package brito.com.multitenancy001.tenant.products.api.dto;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.UUID;

public record ProductResponse(
        UUID id,
        String name,
        String description,
        String sku,
        BigDecimal price,
        Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        BigDecimal profitMargin,

        Long categoryId,
        String categoryName,
        Long subcategoryId,
        String subcategoryName,

        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,

        UUID supplierId,
        String supplierName,

        // ✅ Instantes reais na borda HTTP (JSON com "Z")
        Instant createdAt,
        Instant updatedAt
) {
    public ProductResponse {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/dto/ProductUpsertRequest.java
============================================================
package brito.com.multitenancy001.tenant.products.api.dto;

import java.math.BigDecimal;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

// Record para criação/atualização expandido (com Category/Subcategory por ID)
public record ProductUpsertRequest(
     @NotBlank String name,
     String description,
     String sku,
     @NotNull @PositiveOrZero BigDecimal price,
     @PositiveOrZero Integer stockQuantity,
     Integer minStock,
     Integer maxStock,
     BigDecimal costPrice,

     @NotNull Long categoryId,     // ✅ obrigatório
     Long subcategoryId,           // ✅ opcional

     String brand,
     BigDecimal weightKg,
     String dimensions,
     String barcode,
     Boolean active,
     UUID supplierId
) {
    public ProductUpsertRequest {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/dto/SupplierProductCountResponse.java
============================================================
package brito.com.multitenancy001.tenant.products.api.dto;

import java.util.UUID;

public record SupplierProductCountResponse(UUID supplierId, long count) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/mapper/ProductApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.products.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.products.api.dto.ProductResponse;
import brito.com.multitenancy001.tenant.products.domain.Product;

@Component
public class ProductApiMapper {

    public ProductResponse toResponse(Product product) {
        return new ProductResponse(
                product.getId(),
                product.getName(),
                product.getDescription(),
                product.getSku(),
                product.getPrice(),
                product.getStockQuantity(),
                product.getMinStock(),
                product.getMaxStock(),
                product.getCostPrice(),
                product.getProfitMargin(),

                product.getCategory() != null ? product.getCategory().getId() : null,
                product.getCategory() != null ? product.getCategory().getName() : null,
                product.getSubcategory() != null ? product.getSubcategory().getId() : null,
                product.getSubcategory() != null ? product.getSubcategory().getName() : null,

                product.getBrand(),
                product.getWeightKg(),
                product.getDimensions(),
                product.getBarcode(),
                product.getActive(),

                product.getSupplier() != null ? product.getSupplier().getId() : null,
                product.getSupplier() != null ? product.getSupplier().getName() : null,

                // ✅ Auditoria única: vem do AuditInfo (Instant)
                product.getAudit() != null ? product.getAudit().getCreatedAt() : null,
                product.getAudit() != null ? product.getAudit().getUpdatedAt() : null
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/app/TenantProductService.java
============================================================
// ===============================
// ProductService.java
// (corrigido: resolveCategoryAndSubcategory sem duplicação,
//  update limpando subcategory quando vier null,
//  usando findByIdWithCategory pra validar)
// ===============================
package brito.com.multitenancy001.tenant.products.app;

import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import brito.com.multitenancy001.tenant.categories.persistence.TenantCategoryRepository;
import brito.com.multitenancy001.tenant.categories.persistence.TenantSubcategoryRepository;
import brito.com.multitenancy001.tenant.products.api.dto.SupplierProductCountResponse;
import brito.com.multitenancy001.tenant.products.domain.Product;
import brito.com.multitenancy001.tenant.products.persistence.TenantProductRepository;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import brito.com.multitenancy001.tenant.suppliers.persistence.TenantSupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProductService {

    private final TenantProductRepository tenantProductRepository;
    private final TenantSupplierRepository tenantSupplierRepository;
    private final TenantCategoryRepository tenantCategoryRepository;
    private final TenantSubcategoryRepository tenantSubcategoryRepository;
    private final AppClock appClock;

    @Transactional(readOnly = true)
    public Page<Product> findAll(Pageable pageable) {
        return tenantProductRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    public Product findById(UUID id) {
        return tenantProductRepository.findById(id)
            .orElseThrow(() -> new ApiException("PRODUCT_NOT_FOUND",
                "Produto não encontrado com ID: " + id, 404));
    }

    @Transactional
    public Product create(Product product) {
        validateProduct(product);

        resolveCategoryAndSubcategory(product);
        resolveSupplier(product);
        validateSubcategoryBelongsToCategory(product);

        return tenantProductRepository.save(product);
    }

    @Transactional
    public Product update(UUID id, Product productDetails) {
        Product existingProduct = findById(id);

        if (StringUtils.hasText(productDetails.getName())) {
            existingProduct.setName(productDetails.getName());
        }

        if (productDetails.getDescription() != null) {
            existingProduct.setDescription(productDetails.getDescription());
        }

        if (StringUtils.hasText(productDetails.getSku())) {
            Optional<Product> productWithSku = tenantProductRepository.findBySku(productDetails.getSku());
            if (productWithSku.isPresent() && !productWithSku.get().getId().equals(id)) {
                throw new ApiException("SKU_ALREADY_EXISTS",
                    "SKU já cadastrado: " + productDetails.getSku(), 409);
            }
            existingProduct.setSku(productDetails.getSku());
        }

        if (productDetails.getPrice() != null) {
            validatePrice(productDetails.getPrice());
            existingProduct.setPrice(productDetails.getPrice());
        }

        if (productDetails.getStockQuantity() != null) {
            existingProduct.setStockQuantity(productDetails.getStockQuantity());
        }

        // ✅ category
        if (productDetails.getCategory() != null && productDetails.getCategory().getId() != null) {
            Category category = tenantCategoryRepository.findById(productDetails.getCategory().getId())
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada", 404));
            existingProduct.setCategory(category);
        }

     // ✅ subcategory: só mexe se veio no payload
        if (productDetails.getSubcategory() != null) {
            if (productDetails.getSubcategory().getId() != null) {
                Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(productDetails.getSubcategory().getId())
                        .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada", 404));
                existingProduct.setSubcategory(sub);
            } else {
                // veio "subcategory": {} (ou sem id) => limpa
                existingProduct.setSubcategory(null);
            }
        }



        // ✅ supplier
        if (productDetails.getSupplier() != null && productDetails.getSupplier().getId() != null) {
            Supplier supplier = tenantSupplierRepository.findById(productDetails.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND", "Fornecedor não encontrado", 404));
            existingProduct.setSupplier(supplier);
        }

        validateSubcategoryBelongsToCategory(existingProduct);

        return tenantProductRepository.save(existingProduct);
    }

    private void resolveSupplier(Product product) {
        if (product.getSupplier() != null && product.getSupplier().getId() != null) {
            UUID supplierId = product.getSupplier().getId();
            Supplier supplier = tenantSupplierRepository.findById(product.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                    "Fornecedor não encontrado com ID: " + supplierId, 404));
            product.setSupplier(supplier);
        }
    }


    private void resolveCategoryAndSubcategory(Product product) {
        // ✅ category obrigatória
        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria é obrigatória", 400);
        }

        Category category = tenantCategoryRepository.findById(product.getCategory().getId())
            .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada", 404));
        product.setCategory(category);

        // ✅ subcategory opcional
        if (product.getSubcategory() != null && product.getSubcategory().getId() != null) {
            Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(product.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada", 404));
            product.setSubcategory(sub);
        } else {
            product.setSubcategory(null);
        }
    }

    private void validateSubcategoryBelongsToCategory(Product product) {
        if (product.getSubcategory() == null) return;

        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria é obrigatória", 400);
        }

        if (product.getSubcategory().getCategory() == null
            || product.getSubcategory().getCategory().getId() == null) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria sem categoria associada (cadastro inconsistente)", 409);
        }

        Long subCatCategoryId = product.getSubcategory().getCategory().getId();
        Long productCategoryId = product.getCategory().getId();

        if (!subCatCategoryId.equals(productCategoryId)) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria não pertence à categoria informada", 409);
        }
    }

    // ======= outros métodos =======

    @Transactional(readOnly = true)
    public List<Product> searchProducts(String name, BigDecimal minPrice,
                                        BigDecimal maxPrice, Integer minStock, Integer maxStock) {
        return tenantProductRepository.searchProducts(name, minPrice, maxPrice, minStock, maxStock);
    }


    @Transactional(readOnly = true)
    public List<Product> findLowStock(Integer threshold) {
        return tenantProductRepository.findByStockQuantityLessThan(threshold);
    }

    @Transactional
    public Product updateStock(UUID id, Integer quantityChange) {
        Product product = findById(id);
        if (quantityChange > 0) product.addToStock(quantityChange);
        else if (quantityChange < 0) product.removeFromStock(Math.abs(quantityChange));
        return tenantProductRepository.save(product);
    }

    @Transactional
    public Product updatePrice(UUID id, BigDecimal newPrice) {
        validatePrice(newPrice);
        Product product = findById(id);
        product.updatePrice(newPrice);
        return tenantProductRepository.save(product);
    }

    @Transactional
    public void delete(UUID id) {
        Product product = findById(id);
        product.softDelete(appClock.instant());
        tenantProductRepository.save(product);
    }

    private void validateProduct(Product product) {
        if (!StringUtils.hasText(product.getName())) {
            throw new ApiException("PRODUCT_NAME_REQUIRED", "Nome do produto é obrigatório", 400);
        }
        if (product.getPrice() == null) {
            throw new ApiException("PRODUCT_PRICE_REQUIRED", "Preço do produto é obrigatório", 400);
        }
        validatePrice(product.getPrice());

        if (product.getStockQuantity() == null) product.setStockQuantity(0);
        if (product.getStockQuantity() < 0) {
            throw new ApiException("INVALID_STOCK", "Quantidade em estoque não pode ser negativa", 400);
        }
    }

    private void validatePrice(BigDecimal price) {
        if (price == null) throw new ApiException("INVALID_PRICE", "Preço não pode ser nulo", 400);
        if (price.compareTo(BigDecimal.ZERO) < 0) throw new ApiException("INVALID_PRICE", "Preço não pode ser negativo", 400);
        if (price.compareTo(BigDecimal.valueOf(1_000_000)) > 0) {
            throw new ApiException("PRICE_TOO_HIGH", "Preço muito alto. Valor máximo permitido: 1.000.000", 400);
        }
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryId(Long categoryId) {
        if (categoryId == null) {
            throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByCategoryId(categoryId);
    }


    @Transactional(readOnly = true)
    public List<Product> findByBrand(String brand) {
        if (!StringUtils.hasText(brand)) {
            throw new ApiException("INVALID_BRAND", "brand é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByBrandIgnoreCase(brand.trim());
    }



    @Transactional(readOnly = true)
    public List<Product> findActiveProducts() {
        return tenantProductRepository.findByActiveTrueAndDeletedFalse();
    }


    @Transactional
    public Product updateCostPrice(UUID id, BigDecimal costPrice) {
        Product product = findById(id);
        product.updateCostPrice(costPrice);
        return tenantProductRepository.save(product);
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateTotalInventoryValue() {
        return tenantProductRepository.calculateTotalInventoryValue();
    }

    @Transactional(readOnly = true)
    public Long countLowStockProducts(Integer threshold) {
        return tenantProductRepository.countLowStock(threshold);
    }
    
 // =========================================================
 // ✅ QUERIES PARA "DAR USO" AOS MÉTODOS DO ProductRepository
 // =========================================================

    @Transactional(readOnly = true)
    public List<Product> findBySubcategoryId(Long subcategoryId) {
        if (subcategoryId == null) {
            throw new ApiException("SUBCATEGORY_REQUIRED", "subcategoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedBySubcategoryId(subcategoryId);
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryAndOptionalSubcategory(Long categoryId, Long subcategoryId) {
        if (categoryId == null) {
            throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByCategoryAndOptionalSubcategory(categoryId, subcategoryId);
    }


 @Transactional(readOnly = true)
 public List<Product> findByName(String name) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     return tenantProductRepository.findByNameContainingIgnoreCase(name.trim());
 }

 @Transactional(readOnly = true)
 public Page<Product> findByNamePaged(String name, Pageable pageable) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     return tenantProductRepository.findByNameContainingIgnoreCase(name.trim(), pageable);
 }

 @Transactional(readOnly = true)
 public List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice) {
     if (minPrice == null || maxPrice == null) {
         throw new ApiException("INVALID_PRICE_RANGE", "minPrice e maxPrice são obrigatórios", 400);
     }
     if (maxPrice.compareTo(minPrice) < 0) {
         throw new ApiException("INVALID_PRICE_RANGE", "maxPrice deve ser >= minPrice", 400);
     }
     return tenantProductRepository.findByPriceBetween(minPrice, maxPrice);
 }

 @Transactional(readOnly = true)
 public List<Product> findBySupplierId(UUID supplierId) {
     if (supplierId == null) {
         throw new ApiException("SUPPLIER_REQUIRED", "supplierId é obrigatório", 400);
     }
     return tenantProductRepository.findBySupplier_Id(supplierId);
 }

 @Transactional(readOnly = true)
 public List<Product> findByNameAndPriceAndStock(
         String name,
         BigDecimal minPrice,
         BigDecimal maxPrice,
         Integer minStock,
         Integer maxStock
 ) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     if (minPrice == null || maxPrice == null) {
         throw new ApiException("INVALID_PRICE_RANGE", "minPrice e maxPrice são obrigatórios", 400);
     }
     if (maxPrice.compareTo(minPrice) < 0) {
         throw new ApiException("INVALID_PRICE_RANGE", "maxPrice deve ser >= minPrice", 400);
     }
     if (minStock == null || maxStock == null) {
         throw new ApiException("INVALID_STOCK_RANGE", "minStock e maxStock são obrigatórios", 400);
     }
     if (maxStock < minStock) {
         throw new ApiException("INVALID_STOCK_RANGE", "maxStock deve ser >= minStock", 400);
     }

     return tenantProductRepository.findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(
             name.trim(), minPrice, maxPrice, minStock, maxStock
     );
 }

 /**
  * Usa o @Query:
  * SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id
  */
 @Transactional(readOnly = true)
 public List<SupplierProductCountResponse> countProductsBySupplier() {
     List<Object[]> rows = tenantProductRepository.countProductsBySupplier();

     return rows.stream()
             .map(row -> new SupplierProductCountResponse(
                     (UUID) row[0],
                     ((Number) row[1]).longValue()
             ))
             .toList();
 }

 
 @Transactional
 public Product toggleActive(UUID id) {
     Product product = findById(id);

     if (Boolean.TRUE.equals(product.getDeleted())) {
         throw new ApiException("PRODUCT_DELETED", "Não é permitido alterar produto deletado", 409);
     }

     boolean next = !Boolean.TRUE.equals(product.getActive());
     product.setActive(next);

     return tenantProductRepository.save(product);
 }
 
 @Transactional(readOnly = true)
 public List<Product> findByCategoryId(Long categoryId, boolean includeDeleted, boolean includeInactive) {
     if (categoryId == null) {
         throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
     }
     return tenantProductRepository.findByCategoryWithFlags(categoryId, includeDeleted, includeInactive);
 }

 @Transactional(readOnly = true)
 public List<Product> findAnyByCategoryId(Long categoryId) {
     if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
     return tenantProductRepository.findByCategory_Id(categoryId);
 }

 @Transactional(readOnly = true)
 public List<Product> findAnyBySubcategoryId(Long subcategoryId) {
     if (subcategoryId == null) throw new ApiException("SUBCATEGORY_ID_REQUIRED", "subcategoryId é obrigatório", 400);
     return tenantProductRepository.findBySubcategory_Id(subcategoryId);
 }

 @Transactional(readOnly = true)
 public List<Product> findAnyByBrandIgnoreCase(String brand) {
     if (!StringUtils.hasText(brand)) throw new ApiException("BRAND_REQUIRED", "brand é obrigatório", 400);
     return tenantProductRepository.findAnyByBrandIgnoreCase(brand);
 }

 
    
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/domain/Product.java
============================================================
package brito.com.multitenancy001.tenant.products.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "products")
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"supplier", "category", "subcategory"})
public class Product implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(length = 100, nullable = false)
    private String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    @Builder.Default
    private Integer stockQuantity = 0;

    @Column(name = "min_stock")
    private Integer minStock;

    @Column(name = "max_stock")
    private Integer maxStock;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    /**
     * Percentual (0..100) armazenado, calculado por regra.
     * Ex.: 25.00 significa 25%
     */
    @Column(name = "profit_margin", precision = 10, scale = 2)
    private BigDecimal profitMargin;

    @Column(length = 100)
    private String brand;

    @Column(name = "weight_kg", precision = 10, scale = 3)
    private BigDecimal weightKg;

    @Column(length = 100)
    private String dimensions;

    @Column(length = 100)
    private String barcode;

    @Column(nullable = false)
    @Builder.Default
    private Boolean active = true;

    // =========================
    // SOFT DELETE + AUDIT ÚNICO
    // =========================

    @Column(nullable = false)
    @Builder.Default
    private Boolean deleted = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    // =========================
    // RELACIONAMENTOS
    // =========================

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
            name = "supplier_id",
            foreignKey = @ForeignKey(name = "fk_products_supplier")
    )
    private Supplier supplier;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_products_category")
    )
    private Category category;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
            name = "subcategory_id",
            foreignKey = @ForeignKey(name = "fk_products_subcategory")
    )
    private Subcategory subcategory;

    // =========================
    // CONTRACTS
    // =========================

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return Boolean.TRUE.equals(deleted);
    }

    // =========================
    // DOMAIN METHODS (estoque/preço/delete)
    // =========================

    public void addToStock(Integer qty) {
        if (qty == null) return;
        if (qty <= 0) return;

        if (this.stockQuantity == null) this.stockQuantity = 0;
        this.stockQuantity = this.stockQuantity + qty;
    }

    public void removeFromStock(int qty) {
        if (qty <= 0) return;

        if (this.stockQuantity == null) this.stockQuantity = 0;

        int next = this.stockQuantity - qty;
        if (next < 0) {
            throw new IllegalStateException("Stock cannot be negative");
        }
        this.stockQuantity = next;
    }

    public void updatePrice(BigDecimal newPrice) {
        if (newPrice == null) throw new IllegalArgumentException("newPrice is required");
        if (newPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("newPrice cannot be negative");
        }
        this.price = newPrice;
        recomputeProfitMargin();
    }

    public void updateCostPrice(BigDecimal newCostPrice) {
        // custo pode ser null (sem custo informado)
        if (newCostPrice != null && newCostPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("costPrice cannot be negative");
        }
        this.costPrice = newCostPrice;
        recomputeProfitMargin();
    }

    /**
     * Compat: chamado por código que usa softDelete() sem now.
     * Auditoria de deletedAt/deletedBy fica com o AuditEntityListener.
     */
    public void softDelete() {
        if (Boolean.TRUE.equals(this.deleted)) return;
        this.deleted = true;
        this.active = false;
    }

    /**
     * ✅ Novo: compat com seu service atual: product.softDelete(appClock.instant()).
     * - Mantém deleted=true e active=false
     * - Se quiser registrar deletedAt imediatamente, usa audit.markDeleted(now)
     *   (seu AuditInfo já tem markDeleted(Instant)).
     */
    public void softDelete(Instant now) {
        if (Boolean.TRUE.equals(this.deleted)) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.active = false;

        if (this.audit != null) {
            this.audit.markDeleted(now);
        }
    }

    public void restore() {
        if (!Boolean.TRUE.equals(this.deleted)) return;
        this.deleted = false;
        this.active = true;

        if (this.audit != null) {
            this.audit.clearDeleted();
        }
    }

    /**
     * Regra de margem:
     * - Se costPrice e price existirem, calcula a margem (0..100).
     * - Se não, deixa null.
     */
    public void recomputeProfitMargin() {
        if (costPrice == null || price == null) {
            this.profitMargin = null;
            return;
        }
        if (costPrice.compareTo(BigDecimal.ZERO) <= 0) {
            this.profitMargin = null;
            return;
        }

        BigDecimal diff = price.subtract(costPrice);
        BigDecimal pct = diff
                .divide(costPrice, 6, RoundingMode.HALF_UP)
                .multiply(BigDecimal.valueOf(100))
                .setScale(2, RoundingMode.HALF_UP);

        this.profitMargin = pct;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/persistence/TenantProductRepository.java
============================================================
package brito.com.multitenancy001.tenant.products.persistence;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.products.domain.Product;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface TenantProductRepository extends JpaRepository<Product, UUID> {

    // =========================================================
    // ✅ "CATÁLOGO": SOMENTE ATIVOS E NÃO DELETADOS
    // =========================================================

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND LOWER(p.brand) = LOWER(:brand)
        """)
    List<Product> findActiveNotDeletedByBrandIgnoreCase(@Param("brand") String brand);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.category.id = :categoryId
        """)
    List<Product> findActiveNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.subcategory.id = :subcategoryId
        """)
    List<Product> findActiveNotDeletedBySubcategoryId(@Param("subcategoryId") Long subcategoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.category.id = :categoryId
          AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
        """)
    List<Product> findActiveNotDeletedByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
                                                                      @Param("subcategoryId") Long subcategoryId);

    // ✅ seu endpoint /active
    List<Product> findByActiveTrueAndDeletedFalse();

    // =========================================================
    // EXISTENTES (mantidos)
    // =========================================================

   
    List<Product> findByCategory_Id(Long categoryId);

    List<Product> findBySubcategory_Id(Long subcategoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.category.id = :categoryId
          AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
        """)
    List<Product> findByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
                                                      @Param("subcategoryId") Long subcategoryId);

    List<Product> findByNameContainingIgnoreCase(String name);

    Optional<Product> findBySku(String sku);

    List<Product> findByStockQuantityLessThan(Integer quantity);

    List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

    List<Product> findBySupplier_Id(UUID supplierId);

    Page<Product> findByNameContainingIgnoreCase(String name, Pageable pageable);

    @Query("""
        SELECT p FROM Product p WHERE
            (:name IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :name, '%'))) AND
            (:minPrice IS NULL OR p.price >= :minPrice) AND
            (:maxPrice IS NULL OR p.price <= :maxPrice) AND
            (:minStock IS NULL OR p.stockQuantity >= :minStock) AND
            (:maxStock IS NULL OR p.stockQuantity <= :maxStock)
        """)
    List<Product> searchProducts(@Param("name") String name,
                                 @Param("minPrice") BigDecimal minPrice,
                                 @Param("maxPrice") BigDecimal maxPrice,
                                 @Param("minStock") Integer minStock,
                                 @Param("maxStock") Integer maxStock);

    List<Product> findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(
            String name,
            BigDecimal minPrice,
            BigDecimal maxPrice,
            Integer minStock,
            Integer maxStock
    );

    @Query("SELECT COUNT(p) FROM Product p WHERE p.stockQuantity <= :threshold")
    Long countLowStock(@Param("threshold") Integer threshold);

    @Query("SELECT SUM(p.stockQuantity * p.price) FROM Product p")
    BigDecimal calculateTotalInventoryValue();

    @Query("SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id")
    List<Object[]> countProductsBySupplier();
    
    @Query("""
    	    SELECT p FROM Product p
    	    WHERE (:includeDeleted = true OR p.deleted = false)
    	      AND (:includeInactive = true OR p.active = true)
    	      AND p.category.id = :categoryId
    	    """)
    	List<Product> findByCategoryWithFlags(@Param("categoryId") Long categoryId,
    	                                     @Param("includeDeleted") boolean includeDeleted,
    	                                     @Param("includeInactive") boolean includeInactive);
   
    
    // =========================================================
    // ANY (admin/relatórios internos) ⚠️ pode incluir deleted/inactive
    // =========================================================

    /**
     * ⚠️ Pode incluir deleted/inactive.
     * Use apenas para telas/admin/relatórios internos.
     * Para catálogo público use findActiveNotDeleted*.
     */
    List<Product> findAnyByBrandIgnoreCase(String brand);


    
    

}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/provisioning/infra/TenantFlywayMigrator.java
============================================================
package brito.com.multitenancy001.tenant.provisioning.infra;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;

/**
 * Flyway para TENANT schemas.
 *
 * ✅ NÃO se chama "flyway" -> não roda no bootstrap
 * ✅ você chama migrate(schema) quando provisionar o tenant
 * ✅ cada tenant tem seu schema history dentro do schema do tenant
 *
 * BLINDAGEM EXTRA (recomendado):
 * - table("tenant_flyway_schema_history") separa o histórico do PUBLIC
 */
@Component
@RequiredArgsConstructor
public class TenantFlywayMigrator {

    private static final String TENANT_HISTORY_TABLE = "tenant_flyway_schema_history";

    private final DataSource dataSource;

    public void migrate(String schemaName) {
        migrate(this.dataSource, schemaName);
    }

    public void migrate(DataSource customDataSource, String schemaName) {
        Flyway.configure()
                .dataSource(customDataSource)
                .schemas(schemaName)
                .defaultSchema(schemaName)

                // ✅ sua pasta real (pela sua lista)
                .locations("classpath:db/migration/tenants")

                // ✅ blindagem (opcional mas recomendado)
                .table(TENANT_HISTORY_TABLE)

                .baselineOnMigrate(false)
                .validateOnMigrate(true)
                .cleanDisabled(true)
                .load()
                .migrate();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/sales/domain/Sale.java
============================================================
package brito.com.multitenancy001.tenant.sales.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "sales", indexes = {
        @Index(name = "idx_sales_sale_date", columnList = "sale_date"),
        @Index(name = "idx_sales_status", columnList = "status")
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "items")
public class Sale implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    /**
     * Instante real: quando a venda ocorreu.
     * (DB: TIMESTAMPTZ)
     */
    @Column(name = "sale_date", nullable = false, columnDefinition = "timestamptz")
    private Instant saleDate;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    @Builder.Default
    private BigDecimal totalAmount = BigDecimal.ZERO;

    @Column(name = "customer_name", length = 200)
    private String customerName;

    @Column(name = "customer_document", length = 20)
    private String customerDocument;

    @Column(name = "customer_email", length = 150)
    private String customerEmail;

    @Column(name = "customer_phone", length = 20)
    private String customerPhone;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private SaleStatus status;

    @OneToMany(
            mappedBy = "sale",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            orphanRemoval = true,
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<SaleItem> items = new ArrayList<>();

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // =========================
    // Soft delete (padrão do projeto)
    // - NÃO passa Instant para domínio
    // - AuditEntityListener seta audit.deletedAt com AppClock
    // =========================
    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        // deletedAt/deletedBy serão setados pelo AuditEntityListener ao atualizar
    }

    /**
     * Compat com código antigo que chamava softDelete(Instant).
     * A auditoria é responsabilidade do listener, então o parâmetro é ignorado.
     */
    public void softDelete(Instant ignoredNow) {
        softDelete();
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;

        // política: restore limpa deletedAt/deletedBy
        // (se você preferir manter histórico de deleção, remova essa linha)
        this.audit.clearDeleted();
    }

    // =========================
    // Itens / total
    // =========================
    public void addItem(SaleItem item) {
        if (item == null) return;
        item.setSale(this);
        this.items.add(item);
        recalcTotal();
    }

    public void removeItem(SaleItem item) {
        if (item == null) return;
        this.items.remove(item);
        item.setSale(null);
        recalcTotal();
    }

    public void recalcTotal() {
        BigDecimal sum = BigDecimal.ZERO;
        if (items != null) {
            for (SaleItem it : items) {
                if (it != null && it.getTotalPrice() != null) {
                    sum = sum.add(it.getTotalPrice());
                }
            }
        }
        this.totalAmount = sum;
    }

    public void cancel() {
        this.status = SaleStatus.CANCELLED;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/sales/domain/SaleItem.java
============================================================
package brito.com.multitenancy001.tenant.sales.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "sale_items", indexes = {
        @Index(name = "idx_sale_items_sale_id", columnList = "sale_id"),
        @Index(name = "idx_sale_items_product_id", columnList = "product_id")
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "sale")
public class SaleItem implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "sale_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_sale_items_sale")
    )
    private Sale sale;

    // Sem FK para products. Referência fraca (histórico)
    @Column(name = "product_id")
    private UUID productId;

    // Snapshot obrigatório do produto no momento da venda
    @Column(name = "product_name", nullable = false, length = 255)
    private String productName;

    @Column(name = "quantity", nullable = false, precision = 12, scale = 3)
    private BigDecimal quantity;

    @Column(name = "unit_price", nullable = false, precision = 12, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_price", nullable = false, precision = 12, scale = 2)
    @Builder.Default
    private BigDecimal totalPrice = BigDecimal.ZERO;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // =========================
    // Soft delete (padrão do projeto)
    // =========================
    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        // audit.deletedAt será setado pelo listener
    }

    /** Compat com código antigo que chamava softDelete(Instant). */
    public void softDelete(Instant ignoredNow) {
        softDelete();
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        this.audit.clearDeleted();
    }

    public void recalcTotal() {
        if (quantity == null || unitPrice == null) {
            this.totalPrice = BigDecimal.ZERO;
            return;
        }
        this.totalPrice = unitPrice.multiply(quantity);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/sales/domain/SaleStatus.java
============================================================
package brito.com.multitenancy001.tenant.sales.domain;


public enum SaleStatus {
    DRAFT,
    OPEN,
    CONFIRMED,
    PAID,
    CANCELLED
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantPermission.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.PermissionCode;

/**
 * Padrão: TODA permissão de tenant deve iniciar com TEN_
 */
public enum TenantPermission implements PermissionCode {

    TEN_USER_READ,
    TEN_USER_CREATE,
    TEN_USER_UPDATE,
    TEN_USER_SUSPEND,
    TEN_USER_RESTORE,
    TEN_USER_DELETE,

    TEN_ROLE_TRANSFER,

    TEN_PRODUCT_READ,
    TEN_PRODUCT_WRITE,

    TEN_CATEGORY_READ,
    TEN_CATEGORY_WRITE,

    TEN_SUPPLIER_READ,
    TEN_SUPPLIER_WRITE,

    TEN_SALE_READ,
    TEN_SALE_WRITE,
    TEN_SALE_ISSUES_READ,
    TEN_SALE_ISSUES_WRITE,

    TEN_REPORT_SALES_READ,

    TEN_BILLING_READ,
    TEN_BILLING_WRITE,

    TEN_SETTINGS_READ,
    TEN_SETTINGS_WRITE,

    TEN_INVENTORY_READ,
    TEN_INVENTORY_WRITE;

    @Override
    public String asAuthority() {
        return name();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantRole.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum TenantRole implements RoleAuthority {

    TENANT_OWNER,
    TENANT_ADMIN,
    TENANT_USER,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isTenantOwner() {
        return this == TENANT_OWNER;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantRoleMapper.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Mapper local do contexto Tenant.
 * Aqui o Tenant conhece o shared contract, mas o shared não conhece o Tenant.
 */
public final class TenantRoleMapper {

    private TenantRoleMapper() {}

    public static TenantRole toTenantRole(TenantRoleName roleName) {
        if (roleName == null) return null;
        return TenantRole.valueOf(roleName.name());
    }

    public static TenantRoleName toRoleName(TenantRole role) {
        if (role == null) return null;
        return TenantRoleName.valueOf(role.name());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantRolePermissions.java
============================================================
package brito.com.multitenancy001.tenant.security;

import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Set;

import static brito.com.multitenancy001.tenant.security.TenantPermission.*;

/**
 * Centraliza a matriz Role -> Permissions do Tenant.
 *
 * Regras:
 * - sempre devolve Set imutável
 * - toda role deve estar mapeada explicitamente
 * - FAIL-FAST: role sem mapeamento explode na inicialização e/ou no uso
 */
public final class TenantRolePermissions {

    private static final EnumMap<TenantRole, Set<TenantPermission>> MAP = new EnumMap<>(TenantRole.class);

    static {
        // OWNER = tudo
        MAP.put(TenantRole.TENANT_OWNER, unmodifiable(EnumSet.allOf(TenantPermission.class)));

        // ADMIN = administra tudo do tenant (conforme seu set de TenantPermission)
        MAP.put(TenantRole.TENANT_ADMIN, unmodifiable(EnumSet.of(
                // Users
                TEN_USER_READ,
                TEN_USER_CREATE,
                TEN_USER_UPDATE,
                TEN_USER_SUSPEND,
                TEN_USER_RESTORE,
                TEN_USER_DELETE,

                // Transfer ownership/admin
                TEN_ROLE_TRANSFER,

                // Products + Inventory
                TEN_PRODUCT_READ,
                TEN_PRODUCT_WRITE,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE,

                // Catalog
                TEN_CATEGORY_READ,
                TEN_CATEGORY_WRITE,
                TEN_SUPPLIER_READ,
                TEN_SUPPLIER_WRITE,

                // Sales + Issues + Reports
                TEN_SALE_READ,
                TEN_SALE_WRITE,
                TEN_SALE_ISSUES_READ,
                TEN_SALE_ISSUES_WRITE,
                TEN_REPORT_SALES_READ,

                // Billing + Settings
                TEN_BILLING_READ,
                TEN_BILLING_WRITE,
                TEN_SETTINGS_READ,
                TEN_SETTINGS_WRITE
        )));

        MAP.put(TenantRole.TENANT_PRODUCT_MANAGER, unmodifiable(EnumSet.of(
                TEN_PRODUCT_READ,
                TEN_PRODUCT_WRITE,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE
        )));

        MAP.put(TenantRole.TENANT_SALES_MANAGER, unmodifiable(EnumSet.of(
                TEN_SALE_READ,
                TEN_SALE_WRITE,
                TEN_SALE_ISSUES_READ,
                TEN_SALE_ISSUES_WRITE,
                TEN_REPORT_SALES_READ
        )));

        MAP.put(TenantRole.TENANT_BILLING_MANAGER, unmodifiable(EnumSet.of(
                TEN_BILLING_READ,
                TEN_BILLING_WRITE
        )));

        MAP.put(TenantRole.TENANT_READ_ONLY, unmodifiable(EnumSet.of(
                TEN_PRODUCT_READ,
                TEN_INVENTORY_READ,
                TEN_USER_READ
        )));

        // OPERATOR operacional (não administra usuários/config/billing)
        MAP.put(TenantRole.TENANT_OPERATOR, unmodifiable(EnumSet.of(
                TEN_PRODUCT_READ,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE,
                TEN_SALE_READ
        )));

        // TENANT_USER existe no enum. Se você quiser que ele seja diferente do READ_ONLY, mapeie aqui.
        // (Se for igual ao READ_ONLY, pode apontar para o mesmo set, mantendo imutável.)
        MAP.put(TenantRole.TENANT_USER, MAP.get(TenantRole.TENANT_READ_ONLY));

        // FAIL-FAST: garante que todas as roles do enum estão mapeadas.
        assertAllRolesMapped();
    }

    private TenantRolePermissions() {}

    /**
     * Mantém o mesmo nome do seu método atual.
     * Retorna Set imutável (consistente com CP).
     */
    public static Set<TenantPermission> permissionsFor(TenantRole role) {
        if (role == null) return Set.of();

        Set<TenantPermission> perms = MAP.get(role);
        if (perms == null) {
            throw new IllegalStateException("TENANT_ROLE_NOT_MAPPED: " + role);
        }
        return perms;
    }

    private static void assertAllRolesMapped() {
        for (TenantRole r : TenantRole.values()) {
            if (!MAP.containsKey(r)) {
                throw new IllegalStateException("TENANT_ROLE_NOT_MAPPED_IN_MATRIX: " + r);
            }
        }
    }

    private static Set<TenantPermission> unmodifiable(EnumSet<TenantPermission> set) {
        return Collections.unmodifiableSet(set);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/api/TenantSupplierController.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.api;

import brito.com.multitenancy001.tenant.suppliers.app.TenantSupplierService;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/tenant/suppliers")
@RequiredArgsConstructor
public class TenantSupplierController {

    private final TenantSupplierService tenantSupplierService;

    // Lista fornecedores (não-deletados) do tenant.
    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.name())")
    public ResponseEntity<List<Supplier>> listAll() {
        return ResponseEntity.ok(tenantSupplierService.findAll());
    }

    // Lista fornecedores ativos (não-deletados) do tenant.
    @GetMapping("/active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.name())")
    public ResponseEntity<List<Supplier>> listActive() {
        return ResponseEntity.ok(tenantSupplierService.findActive());
    }

    // Busca fornecedor por id (escopo: tenant).
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.name())")
    public ResponseEntity<Supplier> getById(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.findById(id));
    }

    // Busca fornecedor por documento (CPF/CNPJ) no tenant.
    @GetMapping("/document/{document}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.name())")
    public ResponseEntity<Supplier> getByDocument(@PathVariable String document) {
        return ResponseEntity.ok(tenantSupplierService.findByDocument(document));
    }

    // Pesquisa fornecedores por nome.
    @GetMapping("/search")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.name())")
    public ResponseEntity<List<Supplier>> searchByName(@RequestParam("name") String name) {
        return ResponseEntity.ok(tenantSupplierService.searchByName(name));
    }

    // Lista fornecedores por email.
    @GetMapping("/email")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.name())")
    public ResponseEntity<List<Supplier>> getByEmail(@RequestParam("email") String email) {
        return ResponseEntity.ok(tenantSupplierService.findByEmail(email));
    }

    // Cria fornecedor no tenant.
    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.name())")
    public ResponseEntity<Supplier> create(@Valid @RequestBody Supplier supplier) {
        Supplier saved = tenantSupplierService.create(supplier);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    // Atualiza fornecedor do tenant (substituição completa).
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.name())")
    public ResponseEntity<Supplier> update(@PathVariable UUID id, @RequestBody Supplier supplier) {
        Supplier updated = tenantSupplierService.update(id, supplier);
        return ResponseEntity.ok(updated);
    }

    // Alterna status ativo/inativo do fornecedor.
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.name())")
    public ResponseEntity<Supplier> toggleActive(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.toggleActive(id));
    }

    // Soft-delete de fornecedor no tenant.
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.name())")
    public ResponseEntity<Void> softDelete(@PathVariable UUID id) {
        tenantSupplierService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    // Restaura fornecedor previamente deletado (soft-delete).
    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.name())")
    public ResponseEntity<Supplier> restore(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.restore(id));
    }

    // "Any" (pode incluir deleted/inactive) - útil para admin/auditoria
    @GetMapping("/email/any")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.name())")
    public ResponseEntity<List<Supplier>> findAnyByEmail(@RequestParam String email) {
        return ResponseEntity.ok(tenantSupplierService.findAnyByEmail(email));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/app/TenantSupplierService.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.app;

import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import brito.com.multitenancy001.tenant.suppliers.persistence.TenantSupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantSupplierService {

    private final TenantSupplierRepository tenantSupplierRepository;
    private final AppClock appClock;

    // =========================================================
    // READ (por padrão: NÃO retorna deletados)
    // =========================================================

    @Transactional(readOnly = true)
    public Supplier findById(UUID id) {
        if (id == null) throw new ApiException("SUPPLIER_ID_REQUIRED", "id é obrigatório", 400);

        Supplier s = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (s.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Fornecedor deletado não pode ser consultado", 404);
        }

        return s;
    }

    @Transactional(readOnly = true)
    public List<Supplier> findAll() {
        return tenantSupplierRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Supplier> findActive() {
        return tenantSupplierRepository.findActiveNotDeleted();
    }

    @Transactional(readOnly = true)
    public Supplier findByDocument(String document) {
        if (!StringUtils.hasText(document)) {
            throw new ApiException("SUPPLIER_DOCUMENT_REQUIRED", "document é obrigatório", 400);
        }

        String doc = document.trim();

        return tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(doc)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com document: " + doc, 404));
    }

    @Transactional(readOnly = true)
    public List<Supplier> searchByName(String name) {
        if (!StringUtils.hasText(name)) {
            throw new ApiException("SUPPLIER_NAME_REQUIRED", "name é obrigatório", 400);
        }
        return tenantSupplierRepository.findNotDeletedByNameContainingIgnoreCase(name.trim());
    }

    @Transactional(readOnly = true)
    public List<Supplier> findByEmail(String email) {
        if (!StringUtils.hasText(email)) {
            throw new ApiException("SUPPLIER_EMAIL_REQUIRED", "email é obrigatório", 400);
        }
        return tenantSupplierRepository.findNotDeletedByEmail(email.trim());
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Supplier create(Supplier supplier) {
        validateForCreate(supplier);

        // Regra do seu DB: document único quando NOT NULL e deleted=false.
        // Então: se vier document, garantimos unicidade entre não-deletados.
        if (StringUtils.hasText(supplier.getDocument())) {
            String doc = supplier.getDocument().trim();
            Optional<Supplier> existing = tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(doc);
            if (existing.isPresent()) {
                throw new ApiException("SUPPLIER_DOCUMENT_ALREADY_EXISTS",
                        "Já existe fornecedor com document: " + doc, 409);
            }
            supplier.setDocument(doc);
        } else {
            supplier.setDocument(null);
        }

        // defaults
        // (em Supplier você usa boolean primitivo, então já vem false/true; aqui só garantimos coerência)
        supplier.setDeleted(false);
        supplier.setActive(true);

        return tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public Supplier update(UUID id, Supplier req) {
        if (id == null) throw new ApiException("SUPPLIER_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("SUPPLIER_REQUIRED", "payload é obrigatório", 400);

        Supplier existing = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Não é permitido alterar fornecedor deletado", 409);
        }

        // name
        if (StringUtils.hasText(req.getName())) {
            existing.setName(req.getName().trim());
        }

        // contactPerson
        if (req.getContactPerson() != null) {
            existing.setContactPerson(StringUtils.hasText(req.getContactPerson()) ? req.getContactPerson().trim() : null);
        }

        // email
        if (req.getEmail() != null) {
            existing.setEmail(StringUtils.hasText(req.getEmail()) ? req.getEmail().trim() : null);
        }

        // phone
        if (req.getPhone() != null) {
            existing.setPhone(StringUtils.hasText(req.getPhone()) ? req.getPhone().trim() : null);
        }

        // address
        if (req.getAddress() != null) {
            existing.setAddress(StringUtils.hasText(req.getAddress()) ? req.getAddress().trim() : null);
        }

        // document + documentType
        if (req.getDocument() != null) {
            String newDoc = req.getDocument();
            if (StringUtils.hasText(newDoc)) {
                newDoc = newDoc.trim();

                Optional<Supplier> other = tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(newDoc);
                if (other.isPresent() && !other.get().getId().equals(id)) {
                    throw new ApiException("SUPPLIER_DOCUMENT_ALREADY_EXISTS",
                            "Já existe fornecedor com document: " + newDoc, 409);
                }

                existing.setDocument(newDoc);
            } else {
                existing.setDocument(null);
            }
        }

        if (req.getDocumentType() != null) {
            existing.setDocumentType(StringUtils.hasText(req.getDocumentType()) ? req.getDocumentType().trim() : null);
        }

        // website
        if (req.getWebsite() != null) {
            existing.setWebsite(StringUtils.hasText(req.getWebsite()) ? req.getWebsite().trim() : null);
        }

        // paymentTerms
        if (req.getPaymentTerms() != null) {
            existing.setPaymentTerms(StringUtils.hasText(req.getPaymentTerms()) ? req.getPaymentTerms().trim() : null);
        }

        // leadTimeDays
        if (req.getLeadTimeDays() != null) {
            if (req.getLeadTimeDays() < 0) {
                throw new ApiException("INVALID_LEAD_TIME", "leadTimeDays não pode ser negativo", 400);
            }
            existing.setLeadTimeDays(req.getLeadTimeDays());
        }

        // rating
        if (req.getRating() != null) {
            validateRating(req.getRating());
            existing.setRating(req.getRating());
        }

        // notes
        if (req.getNotes() != null) {
            existing.setNotes(StringUtils.hasText(req.getNotes()) ? req.getNotes().trim() : null);
        }

        // active (permitimos atualizar, mas não pode ativar se estiver deletado - já barramos acima)
        // Aqui: só atualiza se o payload tiver sido enviado em algum formato.
        // Como é boolean primitivo, não dá pra saber se "veio" ou não. Então mantemos SEM alterar.
        // Se você quiser controlar ativo via endpoint específico, faça um PATCH /{id}/toggle-active (igual product).

        return tenantSupplierRepository.save(existing);
    }

    @Transactional
    public Supplier toggleActive(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (supplier.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Não é permitido alterar fornecedor deletado", 409);
        }

        supplier.setActive(!supplier.isActive());
        return tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public void softDelete(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        supplier.softDelete(appClock.instant());
        tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public Supplier restore(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        supplier.restore();
        return tenantSupplierRepository.save(supplier);
    }

    // =========================================================
    // Validation
    // =========================================================

    private void validateForCreate(Supplier supplier) {
        if (supplier == null) throw new ApiException("SUPPLIER_REQUIRED", "Fornecedor é obrigatório", 400);

        if (!StringUtils.hasText(supplier.getName())) {
            throw new ApiException("SUPPLIER_NAME_REQUIRED", "name é obrigatório", 400);
        }

        supplier.setName(supplier.getName().trim());

        if (supplier.getEmail() != null) {
            supplier.setEmail(StringUtils.hasText(supplier.getEmail()) ? supplier.getEmail().trim() : null);
        }
        if (supplier.getContactPerson() != null) {
            supplier.setContactPerson(StringUtils.hasText(supplier.getContactPerson()) ? supplier.getContactPerson().trim() : null);
        }
        if (supplier.getPhone() != null) {
            supplier.setPhone(StringUtils.hasText(supplier.getPhone()) ? supplier.getPhone().trim() : null);
        }
        if (supplier.getAddress() != null) {
            supplier.setAddress(StringUtils.hasText(supplier.getAddress()) ? supplier.getAddress().trim() : null);
        }
        if (supplier.getDocumentType() != null) {
            supplier.setDocumentType(StringUtils.hasText(supplier.getDocumentType()) ? supplier.getDocumentType().trim() : null);
        }
        if (supplier.getWebsite() != null) {
            supplier.setWebsite(StringUtils.hasText(supplier.getWebsite()) ? supplier.getWebsite().trim() : null);
        }
        if (supplier.getPaymentTerms() != null) {
            supplier.setPaymentTerms(StringUtils.hasText(supplier.getPaymentTerms()) ? supplier.getPaymentTerms().trim() : null);
        }
        if (supplier.getNotes() != null) {
            supplier.setNotes(StringUtils.hasText(supplier.getNotes()) ? supplier.getNotes().trim() : null);
        }

        if (supplier.getLeadTimeDays() != null && supplier.getLeadTimeDays() < 0) {
            throw new ApiException("INVALID_LEAD_TIME", "leadTimeDays não pode ser negativo", 400);
        }

        if (supplier.getRating() != null) {
            validateRating(supplier.getRating());
        }
    }

    private void validateRating(BigDecimal rating) {
        // rating NUMERIC(3,2) -> vai até 9.99
        if (rating.compareTo(BigDecimal.ZERO) < 0) {
            throw new ApiException("INVALID_RATING", "rating não pode ser negativo", 400);
        }
        if (rating.compareTo(new BigDecimal("9.99")) > 0) {
            throw new ApiException("INVALID_RATING", "rating máximo é 9.99", 400);
        }
    }
    
    @Transactional(readOnly = true)
    public List<Supplier> findAnyByEmail(String email) {
        if (!StringUtils.hasText(email)) {
            throw new ApiException("SUPPLIER_EMAIL_REQUIRED", "email é obrigatório", 400);
        }
        return tenantSupplierRepository.findAnyByEmail(email);
    }

    
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/domain/Supplier.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.tenant.products.domain.Product;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "suppliers", indexes = {
        @Index(name = "idx_supplier_name", columnList = "name"),
        @Index(name = "idx_supplier_email", columnList = "email")
        // NÃO declare unique index de document aqui (é parcial no DB)
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"products"})
public class Supplier implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", updatable = false, nullable = false)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(name = "contact_person", length = 100)
    private String contactPerson;

    @Column(length = 150)
    private String email;

    @Column(length = 20)
    private String phone;

    @Column(columnDefinition = "TEXT")
    private String address;

    @Column(length = 20)
    private String document;

    @Column(name = "document_type", length = 10)
    private String documentType;

    @Column(name = "website", length = 200)
    private String website;

    @Column(name = "payment_terms", length = 100)
    private String paymentTerms;

    @Column(name = "lead_time_days")
    private Integer leadTimeDays;

    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating;

    @Builder.Default
    @Column(name = "active", nullable = false)
    private boolean active = true;

    @Builder.Default
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;

    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @OneToMany(
            mappedBy = "supplier",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<Product> products = new ArrayList<>();

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // =====================
    // Regras de domínio
    // =====================

    /**
     * Soft delete padrão do projeto:
     * - marca deleted=true e desativa active
     * - audit.deletedAt/deletedBy são setados pelo AuditEntityListener (AppClock)
     */
    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        this.active = false;
    }

    /**
     * Compat com código antigo que chamava softDelete(Instant).
     * O tempo é responsabilidade do AuditEntityListener, então o parâmetro é ignorado.
     */
    public void softDelete(Instant ignoredNow) {
        softDelete();
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.active = true;

        // Política: restore limpa deletedAt/deletedBy
        // (se você preferir manter histórico, remova esta linha)
        if (this.audit != null) {
            this.audit.clearDeleted();
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/persistence/TenantSupplierRepository.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface TenantSupplierRepository extends JpaRepository<Supplier, UUID> {

	// =========================
	// FINDs "crus" (podem incluir deletados) - mantenho, mas no service vamos usar
	// os "ativos/notDeleted"
	// =========================
	

	 @Query("SELECT s FROM Supplier s WHERE s.deleted = false ORDER BY s.name ASC")
	    List<Supplier> findNotDeleted();

	    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND LOWER(s.name) LIKE LOWER(CONCAT('%', :name, '%')) ORDER BY s.name ASC")
	    List<Supplier> findNotDeletedByNameContainingIgnoreCase(@Param("name") String name);

	    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND s.email = :email ORDER BY s.name ASC")
	    List<Supplier> findNotDeletedByEmail(@Param("email") String email);
	
	List<Supplier> findByNameContainingIgnoreCase(String name);

	// =========================
	// RECOMENDADO: queries usadas pelos endpoints (não-deletados)
	// =========================

	
	@Query("""
			SELECT s FROM Supplier s
			WHERE s.deleted = false
			  AND s.document IS NOT NULL
			  AND TRIM(s.document) <> ''
			  AND LOWER(TRIM(s.document)) = LOWER(TRIM(:document))
			""")
	Optional<Supplier> findNotDeletedByDocumentIgnoreCase(@Param("document") String document);

	@Query("SELECT s FROM Supplier s WHERE s.deleted = false AND s.active = true ORDER BY s.name ASC")
	List<Supplier> findActiveNotDeleted();
	
 
    
    // =========================================================
    // ANY (admin/relatórios internos) ⚠️ pode incluir deleted/inactive
    // =========================================================

    /**
     * ⚠️ Pode incluir deleted/inactive.
     * Prefira findNotDeletedByEmail / findActiveNotDeleted quando for regra normal.
     */
    List<Supplier> findAnyByEmail(String email);

   



}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/TenantUserController.java
============================================================
package brito.com.multitenancy001.tenant.users.api;

import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUsersListResponse;
import brito.com.multitenancy001.tenant.users.app.TenantUserFacade;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/users")
@RequiredArgsConstructor
public class TenantUserController {

    private final TenantUserFacade tenantUserFacade;

    // ✅ Lista usuários do tenant (visão rica para TENANT_OWNER)
    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.name())")
    public ResponseEntity<TenantUsersListResponse> listTenantUsers() {
        return ResponseEntity.ok(tenantUserFacade.listTenantUsers());
    }

    // Lista usuários ativos do tenant.
    @GetMapping("/enabled")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.name())")
    public ResponseEntity<List<TenantUserSummaryResponse>> listEnabledTenantUsers() {
        return ResponseEntity.ok(tenantUserFacade.listEnabledTenantUsers());
    }

    // Busca detalhes de um usuário do tenant por id.
    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.name())")
    public ResponseEntity<TenantUserDetailsResponse> getTenantUser(@PathVariable Long userId) {
        return ResponseEntity.ok(tenantUserFacade.getTenantUser(userId));
    }

    // Cria usuário no tenant.
    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_CREATE.name())")
    public ResponseEntity<TenantUserDetailsResponse> createTenantUser(
            @Valid @RequestBody TenantUserCreateRequest tenantUserCreateRequest
    ) {
        TenantUserDetailsResponse response = tenantUserFacade.createTenantUser(tenantUserCreateRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    // Transfere a propriedade/admin (owner) do tenant para o usuário informado.
    @PatchMapping("/{userId}/transfer-admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_ROLE_TRANSFER.name())")
    public ResponseEntity<Void> transferTenantOwner(@PathVariable Long userId) {
        tenantUserFacade.transferTenantOwner(userId);
        return ResponseEntity.noContent().build();
    }

    // Atualiza status de suspensão do usuário
    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_UPDATE.name())")
    public ResponseEntity<TenantUserSummaryResponse> updateTenantUserStatus(
            @PathVariable Long userId,
            @RequestParam(required = false) Boolean suspendedByAccount,
            @RequestParam(required = false) Boolean suspendedByAdmin
    ) {
        if (suspendedByAccount == null && suspendedByAdmin == null) {
            throw new ApiException("INVALID_STATUS", "Informe 'suspended' ou 'enabled' ", 400);
        }

        boolean finalSuspended = (suspendedByAccount != null) ? suspendedByAccount : !suspendedByAdmin;

        TenantUserSummaryResponse response =
                tenantUserFacade.setTenantUserSuspendedByAdmin(userId, finalSuspended);

        return ResponseEntity.ok(response);
    }

    // Reseta a senha do usuário do tenant para um novo valor.
    @PatchMapping("/{userId}/password")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_UPDATE.name())")
    public ResponseEntity<TenantUserSummaryResponse> resetTenantUserPassword(
            @PathVariable Long userId,
            @RequestParam
            @Pattern(
                    regexp = ValidationPatterns.PASSWORD_PATTERN,
                    message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas e números"
            )
            String newPassword
    ) {
        TenantUserSummaryResponse response = tenantUserFacade.resetTenantUserPassword(userId, newPassword);
        return ResponseEntity.ok(response);
    }

    // Soft-delete de usuário do tenant.
    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_DELETE.name())")
    public ResponseEntity<Void> deleteTenantUser(@PathVariable Long userId) {
        tenantUserFacade.softDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    // Hard-delete de usuário do tenant.
    @DeleteMapping("/{userId}/hard")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_DELETE.name())")
    public ResponseEntity<Void> hardDeleteTenantUser(@PathVariable Long userId) {
        tenantUserFacade.hardDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    // Restaura usuário previamente deletado (soft-delete).
    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_RESTORE.name())")
    public ResponseEntity<TenantUserSummaryResponse> restoreTenantUser(@PathVariable Long userId) {
        TenantUserSummaryResponse response = tenantUserFacade.restoreTenantUser(userId);
        return ResponseEntity.ok(response);
    }

    // Busca detalhes de um usuário habilitado (enabled).
    @GetMapping("/enabled/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.name())")
    public ResponseEntity<TenantUserDetailsResponse> getEnabledTenantUser(@PathVariable Long userId) {
        return ResponseEntity.ok(tenantUserFacade.getEnabledTenantUser(userId));
    }

    // Conta usuários habilitados (enabled) do tenant.
    @GetMapping("/enabled/count")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.name())")
    public ResponseEntity<Long> countEnabledTenantUsers() {
        return ResponseEntity.ok(tenantUserFacade.countEnabledTenantUsers());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/admin/TenantUserAdminController.java
============================================================
package brito.com.multitenancy001.tenant.users.api.admin;

import brito.com.multitenancy001.tenant.users.api.dto.admin.TenantUserAdminSuspendRequest;
import brito.com.multitenancy001.tenant.users.app.admin.TenantUserAdminService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/admin/users")
@RequiredArgsConstructor
public class TenantUserAdminController {

    private final TenantUserAdminService tenantUserAdminService;

    // Suspende ou reativa usuário do tenant por ação administrativa.
    @PatchMapping("/{userId}/suspend")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_SUSPEND.name())")
    public ResponseEntity<Void> suspendUser(
            @PathVariable Long userId,
            @RequestBody TenantUserAdminSuspendRequest tenantUserAdminSuspendRequest
    ) {
        tenantUserAdminService.setUserSuspendedByAdmin(userId, tenantUserAdminSuspendRequest.suspended());
        return ResponseEntity.noContent().build();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantActorRef.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

public record TenantActorRef(
        Long userId,
        String email
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserCreateRequest.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantRole;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.LinkedHashSet;

/**
 * Request para criação de usuário no Tenant.
 *
 * Login é por EMAIL
 *
 * Observações:
 * - locale/timezone são opcionais (defaults são aplicados no service).
 * - mustChangePassword é opcional (default false).
 * - permissions aqui são strings TEN_* (extras), se você quiser tipar isso com enum,
 *   podemos evoluir depois (mas hoje mantém compatibilidade).
 */
@Builder
public record TenantUserCreateRequest(

        @NotBlank(message = "Nome é obrigatório")
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @NotBlank(message = "Email é obrigatório")
        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email não pode exceder 150 caracteres")
        String email,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
                regexp = ValidationPatterns.PASSWORD_PATTERN,
                message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais"
        )
        String password,

        @NotNull(message = "Role é obrigatória")
        TenantRole role,

        LinkedHashSet<
                @Pattern(
                        regexp = "^TEN_[A-Z0-9_]+$",
                        message = "Permission must follow TEN_* pattern (e.g. TEN_USER_CREATE)"
                )
                String> permissions,

        @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, message = "Telefone inválido")
        @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
        String phone,

        @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
        String avatarUrl,

        @Size(max = 10, message = "Locale não pode exceder 10 caracteres")
        String locale,

        @Size(max = 50, message = "Timezone não pode exceder 50 caracteres")
        String timezone,

        Boolean mustChangePassword,

        EntityOrigin  origin

) {
    public TenantUserCreateRequest {
        if (name != null) name = name.trim();
        if (email != null) email = email.trim();
        if (phone != null) phone = phone.trim();
        if (avatarUrl != null) avatarUrl = avatarUrl.trim();
        if (locale != null) locale = locale.trim();
        if (timezone != null) timezone = timezone.trim();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserDetailsResponse.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.security.SystemRoleName;

public record TenantUserDetailsResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        SystemRoleName role,
        String phone,
        String avatarUrl,
        String timezone,
        String locale,
        boolean mustChangePassword,
        EntityOrigin origin,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserListItemResponse.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

import java.time.Instant;
import java.util.List;

import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.security.SystemRoleName;

public record TenantUserListItemResponse(
        Long id,
        String email,

        // RBAC (somente para TENANT_OWNER)
        SystemRoleName role,
        List<String> permissions,

        // Flags/meta
        boolean mustChangePassword,
        EntityOrigin origin,

        // Audit/meta (somente para TENANT_OWNER)
        Instant lastLoginAt,
        TenantActorRef createdBy,

        // Status
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

public record TenantUserSummaryResponse(
        Long id,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUsersListResponse.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

import java.util.List;

import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsSnapshot;

public record TenantUsersListResponse(
        AccountEntitlementsSnapshot entitlements, // somente para TENANT_OWNER
        List<TenantUserListItemResponse> users
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/admin/TenantUserAdminSuspendRequest.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto.admin;

public record TenantUserAdminSuspendRequest(boolean suspended) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/mapper/TenantUserApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.users.api.mapper;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.security.SystemRoleName;
import brito.com.multitenancy001.tenant.me.api.dto.TenantMeResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantActorRef;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserListItemResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import org.springframework.stereotype.Component;

import java.util.Comparator;
import java.util.List;
import java.util.Locale;

@Component
public class TenantUserApiMapper {

    private static SystemRoleName toSystemRoleOrNull(Object tenantRoleEnum) {
        if (tenantRoleEnum == null) return null;
        return SystemRoleName.fromString(tenantRoleEnum.toString());
    }

    public TenantUserSummaryResponse toSummary(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantUserSummaryResponse(
                tenantUser.getId(),
                tenantUser.getEmail(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                enabled
        );
    }

    public TenantMeResponse toMe(TenantUser u) {
        boolean enabled = u.isEnabled();
        SystemRoleName role = toSystemRoleOrNull(u.getRole());

        return new TenantMeResponse(
                u.getId(),
                u.getAccountId(),
                u.getName(),
                u.getEmail(),
                role,
                u.getPhone(),
                u.getAvatarUrl(),
                u.getTimezone(),
                u.getLocale(),
                u.isMustChangePassword(),
                u.getOrigin(),
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                u.isDeleted(),
                enabled
        );
    }

    /**
     * ✅ Assinatura REAL do seu DTO TenantUserDetailsResponse (sem permissions / audit extras).
     */
    public TenantUserDetailsResponse toDetails(TenantUser u) {
        boolean enabled = u.isEnabled();
        SystemRoleName role = toSystemRoleOrNull(u.getRole());

        return new TenantUserDetailsResponse(
                u.getId(),
                u.getAccountId(),
                u.getName(),
                u.getEmail(),
                role,
                u.getPhone(),
                u.getAvatarUrl(),
                u.getTimezone(),
                u.getLocale(),
                u.isMustChangePassword(),
                u.getOrigin(),
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                u.isDeleted(),
                enabled
        );
    }

    /**
     * ✅ Lista básica (não-owner): sem permissions/audit; mantém shape do DTO.
     */
    public TenantUserListItemResponse toListItemBasic(TenantUser u) {
        boolean enabled = u.isEnabled();
        SystemRoleName role = toSystemRoleOrNull(u.getRole());

        return new TenantUserListItemResponse(
                u.getId(),
                u.getEmail(),
                role,
                List.of(),
                u.isMustChangePassword(),
                u.getOrigin(),
                null,      // lastLoginAt (somente owner)
                null,      // createdBy (somente owner)
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                enabled
        );
    }

    /**
     * ✅ Lista rica (owner): inclui permissions + audit/meta.
     */
    public TenantUserListItemResponse toListItemRich(TenantUser u) {
        boolean enabled = u.isEnabled();

        List<String> perms = (u.getPermissions() == null)
                ? List.of()
                : u.getPermissions().stream()
                        .filter(s -> s != null && !s.isBlank())
                        .map(s -> s.trim().toUpperCase(Locale.ROOT))
                        .sorted(Comparator.naturalOrder())
                        .toList();

        TenantActorRef createdBy = mapCreatedBy(u.getAudit());
        SystemRoleName role = toSystemRoleOrNull(u.getRole());

        return new TenantUserListItemResponse(
                u.getId(),
                u.getEmail(),
                role,
                perms,
                u.isMustChangePassword(),
                u.getOrigin(),
                u.getLastLoginAt(),
                createdBy,
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                enabled
        );
    }

    private TenantActorRef mapCreatedBy(AuditInfo audit) {
        if (audit == null) return null;
        if (audit.getCreatedBy() == null && audit.getCreatedByEmail() == null) return null;
        return new TenantActorRef(audit.getCreatedBy(), audit.getCreatedByEmail());
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/TenantUserFacade.java
============================================================
package brito.com.multitenancy001.tenant.users.app;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.account.UserLimitPolicy;
import brito.com.multitenancy001.shared.audit.SecurityAuditService;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsGuard;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsService;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsSnapshot;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountResolver;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountSnapshot;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.me.api.dto.TenantMeResponse;
import brito.com.multitenancy001.tenant.me.api.dto.UpdateMyProfileRequest;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.api.dto.*;
import brito.com.multitenancy001.tenant.users.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Duration;
import java.util.LinkedHashSet;
import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantUserFacade {

    private final TenantUserApiMapper tenantUserApiMapper;

    private final TenantUserService tenantUserService;
    private final AccountResolver accountResolver;
    private final JwtTokenProvider jwtTokenProvider;
    private final SecurityUtils securityUtils;
    private final AppClock appClock;
    private final AccountEntitlementsGuard accountEntitlementsGuard;

    private final AccountEntitlementsService accountEntitlementsService;

    private final TenantExecutor tenantExecutor;

    private final SecurityAuditService securityAuditService;

    // =========================================================
    // CONTROLLER METHODS
    // =========================================================

    public void transferTenantOwner(Long toUserId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long fromUserId = securityUtils.getCurrentUserId();

        tenantExecutor.run(schema, (java.util.function.Supplier<Void>) () -> {
            tenantUserService.transferTenantOwnerRole(accountId, fromUserId, toUserId);
            return null;
        });
    }

    public TenantMeResponse getMyProfile() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long userId = securityUtils.getCurrentUserId();

        return tenantExecutor.run(schema, () -> {
            TenantUser user = tenantUserService.getUser(userId, accountId);
            return tenantUserApiMapper.toMe(user);
        });
    }

    public TenantUserDetailsResponse createTenantUser(TenantUserCreateRequest req) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        if (req == null) throw new ApiException("INVALID_REQUEST", "Request inválido", 400);

        String name = (req.name() == null) ? null : req.name().trim();
        String email = (req.email() == null) ? null : req.email().trim().toLowerCase();

        String locale = (req.locale() == null) ? null : req.locale().trim();
        if (locale != null && locale.isBlank()) locale = null;

        String timezone = (req.timezone() == null) ? null : req.timezone().trim();
        if (timezone != null && timezone.isBlank()) timezone = null;

        final LinkedHashSet<String> perms =
                (req.permissions() == null || req.permissions().isEmpty())
                        ? null
                        : new LinkedHashSet<>(req.permissions());

        EntityOrigin origin = (req.origin() != null) ? req.origin() : EntityOrigin.ADMIN;
        if (origin == EntityOrigin.BUILT_IN) {
            throw new ApiException("INVALID_ORIGIN", "Origin BUILT_IN não pode ser criado via API", 400);
        }

        Boolean mustChangePassword = (req.mustChangePassword() == null) ? Boolean.FALSE : req.mustChangePassword();

        long currentUsers = tenantExecutor.run(schema, () ->
                tenantUserService.countUsersForLimit(accountId, UserLimitPolicy.SEATS_IN_USE)
        );

        accountEntitlementsGuard.assertCanCreateUser(accountId, currentUsers);

        String finalLocale = locale;
        String finalTimezone = timezone;

        return tenantExecutor.run(schema, () -> {
            TenantUser created = tenantUserService.createTenantUser(
                    accountId,
                    name,
                    email,
                    req.password(),
                    req.role(),
                    req.phone(),
                    req.avatarUrl(),
                    finalLocale,
                    finalTimezone,
                    perms,
                    mustChangePassword,
                    origin
            );
            return tenantUserApiMapper.toDetails(created);
        });
    }

    /**
     * ✅ MUDOU: agora retorna wrapper com entitlements + lista.
     * - TENANT_OWNER: lista rica + entitlements
     * - outros: lista básica (compatível) e entitlements=null
     */
    public TenantUsersListResponse listTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        TenantRole currentRole = securityUtils.getCurrentTenantRole();
        boolean isOwner = currentRole != null && currentRole.isTenantOwner();

        AccountEntitlementsSnapshot entitlements = null;
        if (isOwner) {
            entitlements = accountEntitlementsService.resolveEffectiveByAccountId(accountId);
        }
        AccountEntitlementsSnapshot finalEntitlements = entitlements;

        return tenantExecutor.run(schema, () -> {
            List<TenantUser> users = tenantUserService.listUsers(accountId);

            List<TenantUserListItemResponse> mapped = users.stream()
                    .map(u -> isOwner
                            ? tenantUserApiMapper.toListItemRich(u)
                            : tenantUserApiMapper.toListItemBasic(u))
                    .toList();

            return new TenantUsersListResponse(finalEntitlements, mapped);
        });
    }

    public List<TenantUserSummaryResponse> listEnabledTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () ->
                tenantUserService.listEnabledUsers(accountId)
                        .stream()
                        .map(tenantUserApiMapper::toSummary)
                        .toList()
        );
    }

    public TenantUserDetailsResponse getTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            TenantUser user = tenantUserService.getUser(userId, accountId);
            return tenantUserApiMapper.toDetails(user);
        });
    }

    public TenantUserSummaryResponse setTenantUserSuspendedByAdmin(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            tenantUserService.setSuspendedByAdmin(accountId, userId, suspended);
            TenantUser updated = tenantUserService.getUser(userId, accountId);
            return tenantUserApiMapper.toSummary(updated);
        });
    }

    public TenantUserSummaryResponse setTenantUserSuspendedByAccount(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            tenantUserService.setSuspendedByAccount(accountId, userId, suspended);
            TenantUser updated = tenantUserService.getUser(userId, accountId);
            return tenantUserApiMapper.toSummary(updated);
        });
    }

    public void softDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        tenantExecutor.run(schema, (java.util.function.Supplier<Void>) () -> {
            tenantUserService.softDelete(userId, accountId);
            return null;
        });
    }

    public TenantUserSummaryResponse restoreTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            TenantUser restored = tenantUserService.restore(userId, accountId);
            return tenantUserApiMapper.toSummary(restored);
        });
    }

    public TenantUserSummaryResponse resetTenantUserPassword(Long userId, String newPassword) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            TenantUser updated = tenantUserService.resetPassword(userId, accountId, newPassword);
            return tenantUserApiMapper.toSummary(updated);
        });
    }

    public void hardDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        tenantExecutor.run(schema, (java.util.function.Supplier<Void>) () -> {
            tenantUserService.hardDelete(userId, accountId);
            return null;
        });
    }

    // =========================================================
    // PASSWORD RESET (PUBLIC -> TENANT) + SECURITY AUDIT
    // =========================================================

    public String generatePasswordResetToken(String slug, String email) {
        if (!StringUtils.hasText(slug)) throw new ApiException("INVALID_SLUG", "Slug é obrigatório", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_LOGIN", "Email é obrigatório", 400);

        securityAuditService.record(
                "PASSWORD_RESET_REQUESTED",
                "ATTEMPT",
                null,
                null,
                email,
                null,
                null,
                null,
                "{\"slug\":\"" + slug + "\"}"
        );

        AccountSnapshot account = accountResolver.resolveActiveAccountBySlug(slug);

        try {
            String token = tenantExecutor.run(account.schemaName(), () -> {
                TenantUser user = tenantUserService.getUserByEmail(email, account.id());

                if (user.isDeleted() || user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
                    throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
                }

                String t = jwtTokenProvider.generatePasswordResetToken(
                        user.getEmail(),
                        account.schemaName(),
                        account.id()
                );

                user.setPasswordResetToken(t);

                // ✅ Instant não tem plusHours; use Duration
                user.setPasswordResetExpires(appClock.instant().plus(Duration.ofHours(1)));

                tenantUserService.save(user);
                return t;
            });

            securityAuditService.record(
                    "PASSWORD_RESET_REQUESTED",
                    "SUCCESS",
                    null,
                    null,
                    email,
                    null,
                    account.id(),
                    account.schemaName(),
                    "{\"expiresHours\":1}"
            );

            return token;

        } catch (Exception e) {
            securityAuditService.record(
                    "PASSWORD_RESET_REQUESTED",
                    "FAILURE",
                    null,
                    null,
                    email,
                    null,
                    account.id(),
                    account.schemaName(),
                    "{\"reason\":\"error\"}"
            );
            throw e;
        }
    }

    public void resetPasswordWithToken(String token, String newPassword) {
        if (!StringUtils.hasText(token)) throw new ApiException("INVALID_TOKEN", "Token inválido", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException("INVALID_PASSWORD", "Nova senha é obrigatória", 400);

        String schema = jwtTokenProvider.getTenantSchemaFromToken(token);
        Long accountId = jwtTokenProvider.getAccountIdFromToken(token);
        String email = jwtTokenProvider.getEmailFromToken(token);

        securityAuditService.record(
                "PASSWORD_RESET_COMPLETED",
                "ATTEMPT",
                null,
                null,
                email,
                null,
                accountId,
                schema,
                "{\"stage\":\"start\"}"
        );

        try {
            tenantExecutor.run(schema, (java.util.function.Supplier<Void>) () -> {
                tenantUserService.resetPasswordWithToken(accountId, email, token, newPassword);
                return null;
            });

            securityAuditService.record(
                    "PASSWORD_RESET_COMPLETED",
                    "SUCCESS",
                    null,
                    null,
                    email,
                    null,
                    accountId,
                    schema,
                    "{\"stage\":\"done\"}"
            );
        } catch (Exception e) {
            securityAuditService.record(
                    "PASSWORD_RESET_COMPLETED",
                    "FAILURE",
                    null,
                    null,
                    email,
                    null,
                    accountId,
                    schema,
                    "{\"reason\":\"error\"}"
            );
            throw e;
        }
    }

    // =========================================================
    // MY PROFILE
    // =========================================================

    public TenantMeResponse updateMyProfile(UpdateMyProfileRequest req) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long userId = securityUtils.getCurrentUserId();

        return tenantExecutor.run(schema, () -> {
            TenantUser updated = tenantUserService.updateProfile(
                    userId,
                    accountId,
                    req.name(),
                    req.phone(),
                    req.avatarUrl(),
                    req.locale(),
                    req.timezone(),
                    appClock.instant()
            );
            return tenantUserApiMapper.toMe(updated);
        });
    }

    public TenantUserDetailsResponse getEnabledTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            TenantUser user = tenantUserService.getEnabledUser(userId, accountId);
            return tenantUserApiMapper.toDetails(user);
        });
    }

    public long countEnabledTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> tenantUserService.countEnabledUsersByAccount(accountId));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/TenantUserService.java
============================================================
package brito.com.multitenancy001.tenant.users.app;

import brito.com.multitenancy001.infrastructure.persistence.TransactionExecutor;
import brito.com.multitenancy001.shared.account.UserLimitPolicy;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Instant;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
public class TenantUserService {

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;
    private final TransactionExecutor transactionExecutor;

    // =========================================================
    // LIMITS / COUNTS
    // =========================================================

    public long countUsersForLimit(Long accountId, UserLimitPolicy policy) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() -> {
            if (policy == null) return tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);

            return switch (policy) {
                // “seats in use” normalmente ignora suspensões, mas ignora deletados
                case SEATS_IN_USE -> tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);

                // “enabled” = não deletado + não suspenso por admin/conta
                case SEATS_ENABLED -> tenantUserRepository.countEnabledUsersByAccount(accountId);

                default -> tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);
            };
        });
    }

    public long countEnabledUsersByAccount(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        return transactionExecutor.inTenantReadOnlyTx(() -> tenantUserRepository.countEnabledUsersByAccount(accountId));
    }

    // =========================================================
    // CREATE
    // =========================================================

    public TenantUser createTenantUser(
            Long accountId,
            String name,
            String email,
            String rawPassword,
            TenantRole role,
            String phone,
            String avatarUrl,
            String locale,
            String timezone,
            LinkedHashSet<String> permissionNames,
            Boolean mustChangePassword,
            EntityOrigin origin
    ) {
        return transactionExecutor.inTenantTx(() -> {

            if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
            if (!StringUtils.hasText(name)) throw new ApiException("INVALID_NAME", "Nome é obrigatório", 400);
            if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
            if (!StringUtils.hasText(rawPassword)) throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);
            if (role == null) throw new ApiException("INVALID_ROLE", "Role é obrigatória", 400);

            String normEmail = email.trim().toLowerCase();

            if (!normEmail.matches(ValidationPatterns.EMAIL_PATTERN)) {
                throw new ApiException("INVALID_EMAIL", "Email inválido", 400);
            }
            if (!rawPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
                throw new ApiException("WEAK_PASSWORD", "Senha fraca", 400);
            }

            boolean exists = tenantUserRepository.existsByEmailAndAccountId(normEmail, accountId);
            if (exists) {
                throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já cadastrado nesta conta", 409);
            }

            TenantUser user = new TenantUser();
            user.setAccountId(accountId);
            user.setName(name.trim());
            user.setEmail(normEmail);
            user.setPassword(passwordEncoder.encode(rawPassword));
            user.setRole(role);

            user.setOrigin(origin == null ? EntityOrigin.ADMIN : origin);

            // ✅ NOVO: grava mustChangePassword (default false)
            user.setMustChangePassword(Boolean.TRUE.equals(mustChangePassword));

            user.setPhone(StringUtils.hasText(phone) ? phone.trim() : null);
            user.setAvatarUrl(StringUtils.hasText(avatarUrl) ? avatarUrl.trim() : null);

            // ✅ NOVO: persiste locale/timezone recebidos (trim + vazio -> null)
            user.setLocale(StringUtils.hasText(locale) ? locale.trim() : null);
            user.setTimezone(StringUtils.hasText(timezone) ? timezone.trim() : null);

            user.setSuspendedByAccount(false);
            user.setSuspendedByAdmin(false);

            // Permissões: base da role + extras desejadas
            Set<TenantPermission> base = new LinkedHashSet<>(TenantRolePermissions.permissionsFor(role));
            Set<TenantPermission> desired = new LinkedHashSet<>();

            if (permissionNames != null && !permissionNames.isEmpty()) {
                for (String p : permissionNames) {
                    if (!StringUtils.hasText(p)) continue;
                    try {
                        desired.add(TenantPermission.valueOf(p.trim()));
                    } catch (IllegalArgumentException ex) {
                        throw new ApiException("INVALID_PERMISSION", "Permissão inválida: " + p, 400);
                    }
                }
            }

            desired = PermissionScopeValidator.validateTenantPermissionsStrict(desired);

            Set<TenantPermission> finalPerms = new LinkedHashSet<>(base);
            finalPerms.addAll(desired);

            user.setPermissions(finalPerms);

            // ✅ mantém comportamento atual: fallback só se continuar vazio/nulo
            if (!StringUtils.hasText(user.getLocale())) user.setLocale("pt_BR");
            if (!StringUtils.hasText(user.getTimezone())) user.setTimezone("America/Sao_Paulo");

            return tenantUserRepository.save(user);
        });
    }

    // =========================================================
    // READ / LIST
    // =========================================================

    public TenantUser getUser(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                        .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404))
        );
    }

    public TenantUser getEnabledUser(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findEnabledByIdAndAccountId(userId, accountId)
                        .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário habilitado não encontrado", 404))
        );
    }

    public TenantUser getUserByEmail(String email, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);

        String normEmail = email.trim().toLowerCase();

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findByEmailAndAccountIdAndDeletedFalse(normEmail, accountId)
                        .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404))
        );
    }

    public List<TenantUser> listUsers(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findByAccountIdAndDeletedFalse(accountId)
        );
    }

    public List<TenantUser> listEnabledUsers(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findEnabledUsersByAccount(accountId)
        );
    }

    // =========================================================
    // UPDATE: STATUS / PROFILE / PASSWORD
    // =========================================================

    public void setSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        transactionExecutor.inTenantTx(() -> {
            int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
            if (updated == 0) throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404);
        });
    }

    public void setSuspendedByAccount(Long accountId, Long userId, boolean suspended) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        transactionExecutor.inTenantTx(() -> {
            int updated = tenantUserRepository.setSuspendedByAccount(accountId, userId, suspended);
            if (updated == 0) throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404);
        });
    }

    public TenantUser updateProfile(
            Long userId,
            Long accountId,
            String name,
            String phone,
            String avatarUrl,
            String locale,
            String timezone,
            Instant now
    ) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        return transactionExecutor.inTenantTx(() -> {
            TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            if (StringUtils.hasText(name)) user.setName(name.trim());
            if (StringUtils.hasText(phone)) user.setPhone(phone.trim());
            if (StringUtils.hasText(locale)) user.setLocale(locale.trim());
            if (StringUtils.hasText(timezone)) user.setTimezone(timezone.trim());

            // ✅ avatarUrl: suporta atualizar OU limpar
            // - null  -> não altera
            // - ""    -> limpa (salva null)
            // - "xxx" -> salva trim()
            if (avatarUrl != null) {
                String trimmed = avatarUrl.trim();
                user.setAvatarUrl(trimmed.isEmpty() ? null : trimmed);
            }

            return tenantUserRepository.save(user);
        });
    }

    public TenantUser resetPassword(Long userId, Long accountId, String newPassword) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);

        if (!newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("WEAK_PASSWORD", "Senha fraca", 400);
        }

        return transactionExecutor.inTenantTx(() -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            Instant now = appClock.instant();

            user.setPassword(passwordEncoder.encode(newPassword));
            user.setMustChangePassword(false);
            user.setPasswordChangedAt(now);
            user.setPasswordResetToken(null);
            user.setPasswordResetExpires(null);

            return tenantUserRepository.save(user);
        });
    }

    public void resetPasswordWithToken(Long accountId, String email, String token, String newPassword) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (!StringUtils.hasText(token)) throw new ApiException("TOKEN_REQUIRED", "token é obrigatório", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);

        if (!newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("WEAK_PASSWORD", "Senha fraca", 400);
        }

        transactionExecutor.inTenantTx(() -> {
            TenantUser user = tenantUserRepository.findByPasswordResetTokenAndAccountId(token, accountId)
                    .orElseThrow(() -> new ApiException("TOKEN_INVALID", "Token inválido", 400));

            Instant now = appClock.instant();

            if (user.getPasswordResetExpires() == null || user.getPasswordResetExpires().isBefore(now)) {
                throw new ApiException("TOKEN_EXPIRED", "Token expirado", 400);
            }

            // Compat/segurança: se veio email no token, confere
            if (StringUtils.hasText(email) && user.getEmail() != null) {
                String tokenLogin = email.trim().toLowerCase();
                if (!user.getEmail().trim().equalsIgnoreCase(tokenLogin)) {
                    throw new ApiException("TOKEN_INVALID", "Token inválido", 400);
                }
            }

            user.setPassword(passwordEncoder.encode(newPassword));
            user.setMustChangePassword(false);
            user.setPasswordChangedAt(now);

            user.setPasswordResetToken(null);
            user.setPasswordResetExpires(null);

            tenantUserRepository.save(user);
        });
    }

    // =========================================================
    // DELETE / RESTORE
    // =========================================================

    public void softDelete(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        transactionExecutor.inTenantTx(() -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            if (user.isDeleted()) return;

            Instant now = appClock.instant();
            user.softDelete(now, appClock.epochMillis());
            tenantUserRepository.save(user);
        });
    }

    public TenantUser restore(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        return transactionExecutor.inTenantTx(() -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            user.restore();
            return tenantUserRepository.save(user);
        });
    }

    public void hardDelete(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        transactionExecutor.inTenantTx(() -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            tenantUserRepository.delete(user);
        });
    }

    public TenantUser save(TenantUser user) {
        if (user == null) throw new ApiException("INVALID_REQUEST", "Usuário inválido", 400);
        return transactionExecutor.inTenantTx(() -> tenantUserRepository.save(user));
    }

    // =========================================================
    // ROLE TRANSFER (OWNER)
    // =========================================================

    public void transferTenantOwnerRole(Long accountId, Long fromUserId, Long toUserId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (fromUserId == null) throw new ApiException("FROM_USER_REQUIRED", "fromUserId é obrigatório", 400);
        if (toUserId == null) throw new ApiException("TO_USER_REQUIRED", "toUserId é obrigatório", 400);
        if (fromUserId.equals(toUserId)) {
            throw new ApiException("INVALID_TRANSFER", "Não é possível transferir para si mesmo", 400);
        }

        transactionExecutor.inTenantTx(() -> {
            TenantUser from = tenantUserRepository.findEnabledByIdAndAccountId(fromUserId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário origem não encontrado/habilitado", 404));

            if (from.getRole() == null || !from.getRole().isTenantOwner()) {
                throw new ApiException("FORBIDDEN", "Apenas o TENANT_OWNER pode transferir", 403);
            }

            TenantUser to = tenantUserRepository.findEnabledByIdAndAccountId(toUserId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário destino não encontrado/habilitado", 404));

            // troca roles
            from.setRole(TenantRole.TENANT_ADMIN);
            to.setRole(TenantRole.TENANT_OWNER);

            // zera permissões custom e volta base do papel (evita “herdar” extras indevidos)
            from.setPermissions(new LinkedHashSet<>(TenantRolePermissions.permissionsFor(from.getRole())));
            to.setPermissions(new LinkedHashSet<>(TenantRolePermissions.permissionsFor(to.getRole())));

            tenantUserRepository.save(from);
            tenantUserRepository.save(to);
        });
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/admin/TenantUserAdminService.java
============================================================
package brito.com.multitenancy001.tenant.users.app.admin;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.tenant.users.app.TenantUserService;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantUserAdminService {

    private final TenantUserService tenantUserService;
    private final SecurityUtils securityUtils;
    private final TenantExecutor tenantExecutor;

    public void setUserSuspendedByAdmin(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        tenantExecutor.run(schema, () -> {
            tenantUserService.setSuspendedByAdmin(accountId, userId, suspended);
            return null;
        });
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/domain/TenantUser.java
============================================================
package brito.com.multitenancy001.tenant.users.domain;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.permission.TenantUserPermission;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.Instant;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;

@Entity
@Table(name = "tenant_users")
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TenantUser implements UserDetails, Auditable, SoftDeletable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ==========
    // IDENTITY
    // ==========
    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(nullable = false, length = 100)
    private String name;

    // ✅ Alinhado com migration: email CITEXT NOT NULL
    @Column(nullable = false, columnDefinition = "citext")
    private String email;

    // ==========
    // RBAC
    // ==========
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private TenantRole role;

    /**
     * Persistência: codes (String) via ElementCollection.
     *
     * Migration (Flyway) criou:
     * - tabela: tenant_user_permissions
     * - FK: tenant_user_id
     * - coluna: permission VARCHAR(120)
     */
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
            name = "tenant_user_permissions",
            joinColumns = @JoinColumn(name = "tenant_user_id")
    )
    @Column(name = "permission", nullable = false, length = 120)
    @Builder.Default
    private Set<String> permissionCodes = new LinkedHashSet<>();

    // ==========
    // PROFILE
    // ==========
    @Column(length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    @Column(length = 50)
    private String timezone;

    @Column(length = 10)
    private String locale;

    // ==========
    // AUTH
    // ==========
    @Column(nullable = false, length = 200)
    private String password;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private boolean mustChangePassword = true;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private EntityOrigin origin = EntityOrigin.ADMIN;

    // ==========
    // SECURITY (instantes reais => Instant)
    // ==========
    @Column(name = "last_login", columnDefinition = "TIMESTAMPTZ")
    private Instant lastLoginAt;

    @Column(name = "locked_until", columnDefinition = "TIMESTAMPTZ")
    private Instant lockedUntil;

    @Column(name = "password_changed_at", columnDefinition = "TIMESTAMPTZ")
    private Instant passwordChangedAt;

    @Column(name = "password_reset_token", length = 200)
    private String passwordResetToken;

    @Column(name = "password_reset_expires", columnDefinition = "TIMESTAMPTZ")
    private Instant passwordResetExpiresAt;

    // ==========
    // STATUS
    // ==========
    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    // ==========
    // AUDIT (fonte única)
    // ==========
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    // ==========
    // NORMALIZATION
    // ==========
    @PrePersist
    @PreUpdate
    private void normalize() {
        this.email = EmailNormalizer.normalizeOrNull(this.email);
        if (this.name != null) this.name = this.name.trim();
        if (this.phone != null) this.phone = this.phone.trim();
        if (this.avatarUrl != null) this.avatarUrl = this.avatarUrl.trim();
        if (this.timezone != null) this.timezone = this.timezone.trim();
        if (this.locale != null) this.locale = this.locale.trim();

        if (this.permissionCodes != null && !this.permissionCodes.isEmpty()) {
            LinkedHashSet<String> normalized = new LinkedHashSet<>();
            for (String c : this.permissionCodes) {
                if (c == null || c.isBlank()) continue;
                normalized.add(c.trim().toUpperCase(Locale.ROOT));
            }
            this.permissionCodes = normalized;
        }
    }

    // ==========
    // DOMAIN (status)
    // ==========
    public boolean isEnabledDomain() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    public boolean isAccountNonLocked(Instant now) {
        if (now == null) now = Instant.now();
        return lockedUntil == null || !now.isBefore(lockedUntil);
    }

    @Override
    public boolean isAccountNonLocked() {
        return isAccountNonLocked(Instant.now());
    }

    public boolean isEnabledForLogin(Instant now) {
        return isEnabledDomain() && isAccountNonLocked(now);
    }

    // ==========
    // Explicit permissions API (domínio manda)
    // ==========
    public Set<String> getPermissionCodes() {
        return permissionCodes == null ? Set.of() : Set.copyOf(permissionCodes);
    }

    /** Alias compat com código antigo (AuthoritiesFactory usa getPermissions()) */
    public Set<String> getPermissions() {
        return getPermissionCodes();
    }

    /** ✅ COMPAT: converte enum -> codes */
    public void setPermissions(Set<TenantPermission> permissions) {
        this.permissionCodes.clear();
        if (permissions == null || permissions.isEmpty()) return;
        for (TenantPermission p : permissions) {
            if (p == null) continue;
            this.permissionCodes.add(p.name());
        }
    }

    public void setPermissionsFromCodes(Set<String> codes) {
        this.permissionCodes.clear();
        if (codes == null || codes.isEmpty()) return;
        for (String c : codes) {
            if (c == null || c.isBlank()) continue;
            this.permissionCodes.add(c.trim().toUpperCase(Locale.ROOT));
        }
    }

    public Set<TenantUserPermission> getExplicitPermissions() {
        if (permissionCodes == null || permissionCodes.isEmpty()) return Set.of();
        LinkedHashSet<TenantUserPermission> out = new LinkedHashSet<>();
        for (String code : permissionCodes) {
            if (code == null || code.isBlank()) continue;
            out.add(new TenantUserPermission(code));
        }
        return out;
    }

    public void replaceExplicitPermissionsFromCodes(Set<String> newCodes) {
        this.permissionCodes.clear();
        if (newCodes == null || newCodes.isEmpty()) return;

        for (String c : newCodes) {
            if (c == null || c.isBlank()) continue;
            TenantUserPermission vo = new TenantUserPermission(c);
            this.permissionCodes.add(vo.code());
        }
    }

    public void grantExplicitPermission(TenantUserPermission p) {
        if (p == null) return;
        this.permissionCodes.add(p.code());
    }

    public void revokeExplicitPermission(String code) {
        if (code == null) return;
        this.permissionCodes.remove(code.trim().toUpperCase(Locale.ROOT));
    }

    // ==========
    // Password reset (domínio manda)
    // ==========
    public void setPasswordReset(String token, Instant expiresAt) {
        this.passwordResetToken = token;
        this.passwordResetExpiresAt = expiresAt;
    }

    public void clearPasswordResetToken() {
        this.passwordResetToken = null;
        this.passwordResetExpiresAt = null;
    }

    // ==========
    // Compat (aliases) - para código antigo não quebrar
    // ==========
    public void setPasswordResetExpires(Instant expiresAt) {
        this.passwordResetExpiresAt = expiresAt;
    }

    public Instant getPasswordResetExpires() {
        return this.passwordResetExpiresAt;
    }

    // ==========
    // Soft delete
    // ==========
    public void softDelete() {
        this.deleted = true;
    }

    public void softDelete(Instant now, long epochMillis) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        if (this.audit != null) this.audit.markDeleted(now);
    }

    public void restore() {
        this.deleted = false;
        if (this.audit != null) this.audit.clearDeleted();
    }

    public void clearSecurityLockState() {
        this.lockedUntil = null;
    }

    // ==========
    // Contracts
    // ==========
    @Override
    public boolean isDeleted() {
        return deleted;
    }

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    // ==========
    // UserDetails
    // ==========
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        Set<GrantedAuthority> out = new LinkedHashSet<>();
        if (role != null) out.add(new SimpleGrantedAuthority(role.asAuthority()));
        for (String code : getPermissionCodes()) {
            out.add(new SimpleGrantedAuthority(code));
        }
        return out;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return isEnabledDomain();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/domain/permission/TenantUserPermission.java
============================================================
package brito.com.multitenancy001.tenant.users.domain.permission;

import brito.com.multitenancy001.tenant.security.TenantPermission;

import java.util.Locale;

public record TenantUserPermission(String code) {

    public TenantUserPermission {
        if (code == null || code.isBlank()) {
            throw new IllegalArgumentException("Permission code cannot be null/blank");
        }
        String normalized = code.trim().toUpperCase(Locale.ROOT);
        if (!normalized.startsWith("TEN_")) {
            throw new IllegalArgumentException("Tenant permission must start with TEN_: " + normalized);
        }
        code = normalized;
    }

    public static TenantUserPermission from(TenantPermission permission) {
        if (permission == null) {
            throw new IllegalArgumentException("Permission cannot be null");
        }
        return new TenantUserPermission(permission.name());
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/persistence/TenantUserRepository.java
============================================================
package brito.com.multitenancy001.tenant.users.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.tenant.users.domain.TenantUser;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

@Repository
public interface TenantUserRepository extends JpaRepository<TenantUser, Long> {

    // =========================================================
    // LOGIN / IDENTIDADE (email)
    // =========================================================

    Optional<TenantUser> findByEmailAndDeletedFalse(String email);

    Optional<TenantUser> findByEmailAndAccountIdAndDeletedFalse(String email, Long accountId);

    boolean existsByEmailAndAccountId(String email, Long accountId);

    // =========================================================
    // PASSWORD RESET
    // =========================================================

    Optional<TenantUser> findByPasswordResetTokenAndAccountId(String passwordResetToken, Long accountId);

    // =========================================================
    // LISTS
    // =========================================================

    List<TenantUser> findByAccountId(Long accountId);

    List<TenantUser> findByAccountIdAndDeletedFalse(Long accountId);

    /**
     * Enabled = NOT deleted + NOT suspendedByAccount + NOT suspendedByAdmin
     */
    List<TenantUser> findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(Long accountId);

    /**
     * Alias legível (evita nome gigante espalhado no projeto).
     */
    default List<TenantUser> findEnabledUsersByAccount(Long accountId) {
        return findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId);
    }

    // =========================================================
    // COUNTS / LIMITS
    // =========================================================

    long countByAccountIdAndDeletedFalse(Long accountId);

    long countByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(Long accountId);

    default long countEnabledUsersByAccount(Long accountId) {
        return countByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId);
    }

    // =========================================================
    // SCOPED ID (READ)
    // =========================================================

    /**
     * DEFAULT (NotDeleted): leitura normal do domínio.
     */
    Optional<TenantUser> findByIdAndAccountIdAndDeletedFalse(Long id, Long accountId);

    /**
     * DEFAULT (Enabled): login/uso ativo.
     */
    @Query("""
        select u from TenantUser u
        where u.id = :id
          and u.accountId = :accountId
          and u.deleted = false
          and u.suspendedByAccount = false
          and u.suspendedByAdmin = false
    """)
    Optional<TenantUser> findEnabledByIdAndAccountId(
            @Param("id") Long id,
            @Param("accountId") Long accountId
    );

    /**
     * ⚠️ Inclui soft-deleted. Use apenas para auditoria/suporte/restore.
     */
    @Query("""
        select u from TenantUser u
        where u.id = :id
          and u.accountId = :accountId
    """)
    Optional<TenantUser> findIncludingDeletedByIdAndAccountId(
            @Param("id") Long id,
            @Param("accountId") Long accountId
    );

    /**
     * Alias (mesma coisa do findIncludingDeletedByIdAndAccountId).
     * Mantido se houver código chamando "findAny...".
     */
    default Optional<TenantUser> findAnyByIdAndAccountId(Long id, Long accountId) {
        return findIncludingDeletedByIdAndAccountId(id, accountId);
    }

    // =========================================================
    // UPDATE: SUSPENSÕES
    // =========================================================

    /**
     * Suspende/Reativa por ADMIN (1 usuário) - não mexe em suspendedByAccount.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAdmin = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAdmin(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

    /**
     * Suspende/Reativa por CONTA (1 usuário) - não mexe em suspendedByAdmin.
     * ✅ Este método é necessário porque o TenantUserService chama ele.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAccount(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

    /**
     * Suspende TODOS por CONTA (bulk) - não mexe em suspendedByAdmin.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = true
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int suspendAllByAccount(@Param("accountId") Long accountId);

    /**
     * Reativa TODOS por CONTA (bulk) - não mexe em suspendedByAdmin.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = false
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int unsuspendAllByAccount(@Param("accountId") Long accountId);

    // =========================================================
    // UPDATE: SOFT DELETE / RESTORE (bulk)
    // =========================================================

    /**
     * Soft-delete em massa por conta.
     * ✅ Necessário porque o TenantUserProvisioningFacade chama este método.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.deleted = true,
               u.audit.deletedAt = :deletedAt
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int softDeleteAllByAccount(
            @Param("accountId") Long accountId,
            @Param("deletedAt") Instant deletedAt
    );

    /**
     * Restore em massa por conta.
     * ✅ Necessário porque o TenantUserProvisioningFacade chama este método.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.deleted = false,
               u.audit.deletedAt = null
         where u.accountId = :accountId
           and u.deleted = true
    """)
    int restoreAllByAccount(@Param("accountId") Long accountId);

    // ✅ grava last_login no login
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.lastLoginAt = :lastLogin
         where u.id = :userId
           and u.deleted = false
    """)
    int updateLastLogin(
            @Param("userId") Long userId,
            @Param("lastLogin") Instant lastLogin
    );
}

============================================================
### FILE: src/main/resources/application-dev.properties
============================================================
# application-dev.properties


# =========================================================
# LOGS - DEV
# =========================================================
logging.level.org.flywaydb=DEBUG
logging.level.org.springframework.jdbc.core=TRACE
logging.level.org.springframework.jdbc.datasource.init=DEBUG

# =========================================================
# SPRINGDOC (DEV ON)
# =========================================================
springdoc.api-docs.enabled=true
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha

springdoc.swagger-ui.urls[0].name=tenant
springdoc.swagger-ui.urls[0].url=/v3/api-docs/tenant

springdoc.swagger-ui.urls[1].name=controlplane
springdoc.swagger-ui.urls[1].url=/v3/api-docs/controlplane

springdoc.swagger-ui.urls[2].name=admin
springdoc.swagger-ui.urls[2].url=/v3/api-docs/admin

springdoc.swagger-ui.urls[3].name=public
springdoc.swagger-ui.urls[3].url=/v3/api-docs/public

springdoc.swagger-ui.urlsPrimaryName=tenant

============================================================
### FILE: src/main/resources/application.properties
============================================================
# arquivo application.properties

spring.application.name=multitenancy001

# =========================================================
# JWT
# =========================================================
app.jwt.secret=AHJ8d9sj29DKs0923kslaS90sldj1029askd0asdj19203kdls0asdj19203kdas0d9s
app.jwt.expiration=3600000
app.jwt.refresh.expiration=604800000

# =========================================================
# DATABASE
# =========================================================
spring.datasource.url=jdbc:postgresql://localhost:5432/db_multitenancy
spring.datasource.username=postgres
spring.datasource.password=admin
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# IMPORTANTE: DESATIVE criacao automatica do Hibernate
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.open-in-view=false

# =========================================================
# FLYWAY
# =========================================================
# \u2705 Voc controla Flyway via @Bean (PublicFlywayConfig), ento desligue o autoconfig por properties
spring.flyway.enabled=false

# =========================================================
# LOGS (DEFAULT)
# =========================================================
logging.level.org.flywaydb=INFO
logging.level.org.springframework.jdbc.core=OFF
logging.level.org.springframework.jdbc.datasource.init=OFF

logging.level.org.hibernate.SQL=OFF
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=OFF

# =========================================================
# HIKARI
# =========================================================
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.max-lifetime=1200000

# =========================================================
# ACTUATOR
# =========================================================
management.endpoints.web.exposure.include=health
management.endpoint.health.show-details=never
management.endpoints.web.base-path=/actuator

# =========================================================
# SPRINGDOC (default OFF)
# =========================================================
springdoc.api-docs.enabled=false
springdoc.swagger-ui.enabled=false

spring.profiles.active=dev

============================================================
### FILE: src/main/resources/db/migration/accounts/V10__create_table_account_provisioning_events.sql
============================================================
-- V10__create_table_account_provisioning_events.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS public.account_provisioning_events (
    id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    failure_code VARCHAR(50),
    message TEXT,
    details_json TEXT,
    created_at TIMESTAMPTZ NOT NULL,

    CONSTRAINT fk_account_prov_events_account
        FOREIGN KEY (account_id) REFERENCES public.accounts(id)
);

CREATE INDEX IF NOT EXISTS idx_account_prov_events_account_id
    ON public.account_provisioning_events (account_id);

CREATE INDEX IF NOT EXISTS idx_account_prov_events_created_at
    ON public.account_provisioning_events (created_at);


============================================================
### FILE: src/main/resources/db/migration/accounts/V11__create_table_tenant_login_challenges.sql
============================================================
-- V11__create_table_tenant_login_challenges.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS tenant_login_challenges (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    email CITEXT NOT NULL,

    -- CSV simples de accountIds válidos (ex: "1,2,3")
    candidate_account_ids_csv TEXT NOT NULL,

    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL,
    used_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_tenant_login_challenges_email
    ON tenant_login_challenges (email);

CREATE INDEX IF NOT EXISTS idx_tenant_login_challenges_expires_at
    ON tenant_login_challenges (expires_at);

CREATE INDEX IF NOT EXISTS idx_tenant_login_challenges_used_at
    ON tenant_login_challenges (used_at);


============================================================
### FILE: src/main/resources/db/migration/accounts/V13__seed_account_entitlements_for_existing_accounts.sql
============================================================
-- V13__seed_account_entitlements_for_existing_accounts.sql
SET search_path TO public;

INSERT INTO account_entitlements (
    account_id,
    max_users,
    max_products,
    max_storage_mb,
    created_at,
    updated_at
)
SELECT
    a.id,
    5,
    100,
    100,
    now(),
    now()
FROM accounts a
WHERE a.deleted = false
  AND a.account_type = 'TENANT'
  AND a.account_origin <> 'BUILT_IN'
ON CONFLICT (account_id) DO NOTHING;


============================================================
### FILE: src/main/resources/db/migration/accounts/V14__create_table_auth_events.sql
============================================================
-- V14__create_table_auth_events.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS auth_events (
    id BIGSERIAL PRIMARY KEY,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    request_id UUID,
    method TEXT,
    uri TEXT,

    ip INET,
    user_agent TEXT,

    auth_domain TEXT,
    event_type TEXT NOT NULL,
    outcome TEXT NOT NULL,

    principal_email CITEXT,
    principal_user_id BIGINT,

    account_id BIGINT,
    tenant_schema TEXT,

    details JSONB
);

CREATE INDEX IF NOT EXISTS idx_auth_events_occurred_at ON auth_events (occurred_at);
CREATE INDEX IF NOT EXISTS idx_auth_events_request_id ON auth_events (request_id);
CREATE INDEX IF NOT EXISTS idx_auth_events_email ON auth_events (principal_email);
CREATE INDEX IF NOT EXISTS idx_auth_events_account_id ON auth_events (account_id);
CREATE INDEX IF NOT EXISTS idx_auth_events_tenant_schema ON auth_events (tenant_schema);


============================================================
### FILE: src/main/resources/db/migration/accounts/V15__create_table_security_audit_events.sql
============================================================
-- V15__create_table_security_audit_events.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS security_audit_events (
    id BIGSERIAL PRIMARY KEY,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    request_id UUID,
    method TEXT,
    uri TEXT,

    ip INET,
    user_agent TEXT,

    action_type TEXT NOT NULL,
    outcome TEXT NOT NULL,

    actor_email CITEXT,
    actor_user_id BIGINT,

    target_email CITEXT,
    target_user_id BIGINT,

    account_id BIGINT,
    tenant_schema TEXT,

    details JSONB
);

CREATE INDEX IF NOT EXISTS idx_security_audit_occurred_at ON security_audit_events (occurred_at);
CREATE INDEX IF NOT EXISTS idx_security_audit_request_id ON security_audit_events (request_id);
CREATE INDEX IF NOT EXISTS idx_security_audit_action_type ON security_audit_events (action_type);
CREATE INDEX IF NOT EXISTS idx_security_audit_account_id ON security_audit_events (account_id);


============================================================
### FILE: src/main/resources/db/migration/accounts/V16__create_table_account_job_schedules.sql
============================================================
-- V16__create_table_account_job_schedules.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS account_job_schedules (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,
    job_key VARCHAR(80) NOT NULL,

    -- horário civil
    local_time TIME NOT NULL,
    -- timezone IANA (ex: America/Sao_Paulo)
    zone_id VARCHAR(60) NOT NULL,

    enabled BOOLEAN NOT NULL DEFAULT true,

    -- rastreabilidade e controle
    last_run_at TIMESTAMPTZ,
    next_run_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_account_job_schedules_account
        FOREIGN KEY (account_id) REFERENCES public.accounts(id),

    CONSTRAINT uq_account_job_schedules UNIQUE (account_id, job_key)
);

CREATE INDEX IF NOT EXISTS idx_account_job_schedules_next_run
    ON account_job_schedules (enabled, next_run_at);

============================================================
### FILE: src/main/resources/db/migration/accounts/V17__alter_controlplane_users_email_to_citext.sql
============================================================
-- V17__alter_controlplane_users_email_to_citext.sql
SET search_path TO public;

-- CITEXT já é criado no V1 (accounts), mas manter idempotente não faz mal
CREATE EXTENSION IF NOT EXISTS citext;

-- email: VARCHAR(150) -> CITEXT (case-insensitive)
ALTER TABLE public.controlplane_users
    ALTER COLUMN email TYPE CITEXT
    USING email::citext;

-- opcional: índice já existe (idx_cp_users_email). Se quiser recriar como citext não precisa.

============================================================
### FILE: src/main/resources/db/migration/accounts/V1__create_extension.sql
============================================================
-- V1__create_extension.sql
SET search_path TO public;

CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS citext;


============================================================
### FILE: src/main/resources/db/migration/accounts/V2__create_table_accounts.sql
============================================================
-- V2__create_table_accounts.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS accounts (
    id BIGSERIAL PRIMARY KEY,

    account_type   VARCHAR(20) NOT NULL DEFAULT 'TENANT',
    account_origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    display_name VARCHAR(150) NOT NULL,
    legal_name   VARCHAR(200),
    legal_entity_type VARCHAR(20) NOT NULL DEFAULT 'COMPANY', -- INDIVIDUAL | COMPANY

    schema_name VARCHAR(100) NOT NULL,
    slug        VARCHAR(80)  NOT NULL,

    status            VARCHAR(50) NOT NULL DEFAULT 'FREE_TRIAL',
    subscription_plan VARCHAR(50) NOT NULL DEFAULT 'FREE',

    -- emails case-insensitive
    login_email   CITEXT NOT NULL,
    billing_email CITEXT,

    tax_id_type      VARCHAR(20),
    tax_id_number    VARCHAR(40),
    tax_country_code VARCHAR(2)  NOT NULL DEFAULT 'BR',

    phone   VARCHAR(20),
    address VARCHAR(500),
    city    VARCHAR(100),
    state   VARCHAR(50),
    country VARCHAR(60) NOT NULL DEFAULT 'Brasil',

    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale   VARCHAR(20) NOT NULL DEFAULT 'pt_BR',
    currency VARCHAR(3)  NOT NULL DEFAULT 'BRL',

    -- auditoria (instantes reais)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    created_by BIGINT,
    updated_by BIGINT,
    deleted_by BIGINT,

    created_by_email CITEXT,
    updated_by_email CITEXT,
    deleted_by_email CITEXT,

    -- domínio: misto (instante real x data civil)
    trial_end_date    TIMESTAMPTZ, -- instante real
    payment_due_date  DATE,        -- data civil
    next_billing_date DATE,        -- data civil

    settings_json TEXT,
    metadata_json TEXT,

    deleted    BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMPTZ
);

-- =========================
-- CHECK constraints (idempotente)
-- =========================
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'chk_accounts_account_type') THEN
        ALTER TABLE accounts
            ADD CONSTRAINT chk_accounts_account_type
            CHECK (account_type IN ('TENANT', 'PLATFORM'));
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'chk_accounts_account_origin') THEN
        ALTER TABLE accounts
            ADD CONSTRAINT chk_accounts_account_origin
            CHECK (account_origin IN ('BUILT_IN', 'ADMIN', 'API'));
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'chk_accounts_status') THEN
        ALTER TABLE accounts
            ADD CONSTRAINT chk_accounts_status
            CHECK (status IN ('PROVISIONING', 'FREE_TRIAL', 'ACTIVE', 'SUSPENDED', 'CANCELLED'));
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'chk_accounts_subscription_plan') THEN
        ALTER TABLE accounts
            ADD CONSTRAINT chk_accounts_subscription_plan
            CHECK (subscription_plan IN ('FREE', 'PRO', 'ENTERPRISE', 'BUILT_IN_PLAN'));
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'chk_accounts_legal_entity_type') THEN
        ALTER TABLE accounts
            ADD CONSTRAINT chk_accounts_legal_entity_type
            CHECK (legal_entity_type IN ('INDIVIDUAL', 'COMPANY'));
    END IF;
END $$;

-- =========================
-- Índices/Uniqueness (soft-delete aware)
-- =========================
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_schema_name_active
    ON accounts (schema_name)
    WHERE deleted = false;

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_slug_active
    ON accounts (slug)
    WHERE deleted = false;

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_login_email_active
    ON accounts (login_email)
    WHERE deleted = false;

-- tax_id pode ser nulo (permitir múltiplos nulos)
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_tax_id_active
    ON accounts (tax_id_type, tax_id_number, tax_country_code)
    WHERE deleted = false AND tax_id_number IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_accounts_status ON accounts (status);
CREATE INDEX IF NOT EXISTS idx_accounts_created_at ON accounts (created_at);


============================================================
### FILE: src/main/resources/db/migration/accounts/V3__create_table_account_entitlements.sql
============================================================
-- V3__create_table_account_entitlements.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS account_entitlements (
    account_id      BIGINT PRIMARY KEY,
    max_users       INTEGER NOT NULL,
    max_products    INTEGER NOT NULL,
    max_storage_mb  INTEGER NOT NULL DEFAULT 100,

    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint c
        JOIN pg_class t ON t.oid = c.conrelid
        JOIN pg_namespace n ON n.oid = t.relnamespace
        WHERE c.conname = 'fk_account_entitlements_account'
          AND n.nspname = 'public'
          AND t.relname = 'account_entitlements'
    ) THEN
        ALTER TABLE public.account_entitlements
            ADD CONSTRAINT fk_account_entitlements_account
            FOREIGN KEY (account_id) REFERENCES public.accounts(id)
            ON DELETE CASCADE;
    END IF;
END $$;


============================================================
### FILE: src/main/resources/db/migration/accounts/V4__create_table_controlplane_users.sql
============================================================
-- V4__create_table_controlplane_users.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_users (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL REFERENCES accounts(id),

    user_origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    name VARCHAR(100) NOT NULL,

    -- ✅ padronizado: email case-insensitive
    email CITEXT NOT NULL,

    password VARCHAR(255) NOT NULL,

    role VARCHAR(50),

    -- AUTH / SECURITY (Instant <-> TIMESTAMPTZ)
    must_change_password BOOLEAN NOT NULL DEFAULT FALSE,
    last_login TIMESTAMPTZ NULL,
    locked_until TIMESTAMPTZ NULL,
    password_changed_at TIMESTAMPTZ NULL,
    password_reset_token VARCHAR(200) NULL,
    password_reset_expires TIMESTAMPTZ NULL,

    -- STATUS
    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin BOOLEAN NOT NULL DEFAULT FALSE,
    deleted BOOLEAN NOT NULL DEFAULT FALSE,

    -- AUDIT (fonte única)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by VARCHAR(120),
    updated_at TIMESTAMPTZ,
    updated_by VARCHAR(120),
    deleted_at TIMESTAMPTZ,
    deleted_by VARCHAR(120)
);

CREATE INDEX IF NOT EXISTS idx_cp_users_account_id ON controlplane_users(account_id);
CREATE INDEX IF NOT EXISTS idx_cp_users_email ON controlplane_users(email);

============================================================
### FILE: src/main/resources/db/migration/accounts/V5__insert_controlplane_account.sql
============================================================
-- V5__insert_controlplane_account.sql
SET search_path TO public;

INSERT INTO accounts (
    account_type,
    account_origin,
    display_name,
    legal_name,
    legal_entity_type,
    schema_name,
    slug,
    status,
    subscription_plan,
    tax_id_type,
    tax_id_number,
    tax_country_code,
    login_email,
    billing_email,
    country,
    timezone,
    locale,
    currency,
    deleted
)
SELECT
    'PLATFORM',
    'BUILT_IN',
    'Control Plane',
    NULL,
    'COMPANY',
    'public',
    'controlplane',
    'ACTIVE',
    'BUILT_IN_PLAN',
    'CNPJ',
    '00000000000000',
    'BR',
    'admin@controlplane.com',
    NULL,
    'Brasil',
    'America/Sao_Paulo',
    'pt_BR',
    'BRL',
    false
WHERE NOT EXISTS (
    SELECT 1 FROM accounts WHERE slug = 'controlplane'
);


============================================================
### FILE: src/main/resources/db/migration/accounts/V6__insert_controlplane_users.sql
============================================================
-- V6__insert_controlplane_users.sql
SET search_path TO public;

WITH cp_account AS (
    SELECT id
    FROM accounts
    WHERE slug = 'controlplane'
    LIMIT 1
)
INSERT INTO controlplane_users (
    name,
    email,
    password,
    role,
    account_id,
    user_origin,
    suspended_by_account,
    suspended_by_admin,
    must_change_password
)
SELECT
    u.name,
    u.email,
    u.password,
    u.role,
    a.id,
    'BUILT_IN',
    false,
    false,
    u.must_change_password
FROM cp_account a
JOIN (
    VALUES
      ('ControlPlane Super Admin', 'superadmin@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OWNER', false),

      ('ControlPlane Billing Manager', 'billing@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_BILLING_MANAGER', true),

      ('ControlPlane Support', 'support@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_SUPPORT', true),

      ('ControlPlane Operator', 'operator@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OPERATOR', true)

) AS u(name, email, password, role, must_change_password)
ON TRUE
WHERE NOT EXISTS (
    SELECT 1
    FROM controlplane_users existing
    WHERE existing.account_id = a.id
      AND existing.deleted = false
      AND existing.email = u.email
);


============================================================
### FILE: src/main/resources/db/migration/accounts/V7__create_table_controlplane_user_permissions.sql
============================================================
-- V7__create_table_controlplane_user_permissions.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_user_permissions (
    user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (user_id, permission),

    CONSTRAINT fk_cp_user_permissions_user
        FOREIGN KEY (user_id)
        REFERENCES controlplane_users(id)
        ON DELETE CASCADE
);


============================================================
### FILE: src/main/resources/db/migration/accounts/V8__create_table_payments.sql
============================================================
-- V8__create_table_payments.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS payments (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL REFERENCES accounts(id),

    -- alinhado com Payment.java
    amount NUMERIC(14,2) NOT NULL,

    -- enums como STRING
    payment_method  VARCHAR(50) NOT NULL,
    payment_gateway VARCHAR(50) NOT NULL,
    status          VARCHAR(20) NOT NULL DEFAULT 'PENDING',

    currency VARCHAR(3) NOT NULL DEFAULT 'BRL',

    transaction_id VARCHAR(100) UNIQUE,
    description VARCHAR(500),

    metadata_json TEXT,
    invoice_url   TEXT,
    receipt_url   TEXT,

    -- instantes reais (Instant <-> TIMESTAMPTZ)
    payment_date TIMESTAMPTZ NOT NULL,
    valid_until  TIMESTAMPTZ,
    refunded_at  TIMESTAMPTZ,

    refund_amount NUMERIC(14,2),
    refund_reason VARCHAR(500),

    -- auditoria (seu padrão AuditInfo)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    created_by BIGINT,
    updated_by BIGINT,
    deleted_by BIGINT,

    created_by_email CITEXT,
    updated_by_email CITEXT,
    deleted_by_email CITEXT,

    deleted    BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_payments_account_id ON payments (account_id);
CREATE INDEX IF NOT EXISTS idx_payments_status     ON payments (status);
CREATE INDEX IF NOT EXISTS idx_payments_payment_date ON payments (payment_date);

============================================================
### FILE: src/main/resources/db/migration/accounts/V9__create_table_login_identities.sql
============================================================
-- V9__create_table_login_identities.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS login_identities (
    id BIGSERIAL PRIMARY KEY,

    email CITEXT NOT NULL,

    user_type VARCHAR(20) NOT NULL, -- 'TENANT' | 'CONTROLPLANE'
    account_id BIGINT,              -- TENANT: obrigatório / CONTROLPLANE: deve ser NULL

    -- instante real: TIMESTAMPTZ
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT chk_login_identities_user_type
        CHECK (user_type IN ('TENANT', 'CONTROLPLANE')),

    CONSTRAINT chk_login_identities_user_type_account
        CHECK (
            (user_type = 'TENANT' AND account_id IS NOT NULL)
            OR
            (user_type = 'CONTROLPLANE' AND account_id IS NULL)
        ),

    CONSTRAINT fk_login_identities_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_login_identity_cp_email
    ON login_identities (email)
    WHERE user_type = 'CONTROLPLANE';

CREATE UNIQUE INDEX IF NOT EXISTS ux_login_identity_tenant_email_account
    ON login_identities (email, account_id)
    WHERE user_type = 'TENANT';

CREATE INDEX IF NOT EXISTS idx_login_identities_email_tenant
    ON login_identities (email)
    WHERE user_type = 'TENANT';


============================================================
### FILE: src/main/resources/db/migration/tenants/V1__create_table_tenant_users.sql
============================================================
-- V1__create_table_tenant_users.sql

CREATE TABLE IF NOT EXISTS tenant_users (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,

    name VARCHAR(100) NOT NULL,
    email CITEXT NOT NULL,
    password VARCHAR(200) NOT NULL,

    role VARCHAR(50) NOT NULL,

    phone VARCHAR(20) NULL,
    avatar_url VARCHAR(500) NULL,
    timezone VARCHAR(50) NULL,
    locale VARCHAR(10) NULL,

    must_change_password BOOLEAN NOT NULL DEFAULT TRUE,
    origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    last_login TIMESTAMPTZ NULL,
    locked_until TIMESTAMPTZ NULL,
    password_changed_at TIMESTAMPTZ NULL,
    password_reset_token VARCHAR(200) NULL,
    password_reset_expires TIMESTAMPTZ NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin BOOLEAN NOT NULL DEFAULT FALSE,

    deleted BOOLEAN NOT NULL DEFAULT FALSE,

    -- AUDIT (fonte única)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by BIGINT NULL,
    created_by_email CITEXT  NULL,

    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by BIGINT NULL,
    updated_by_email CITEXT  NULL,

    deleted_at TIMESTAMPTZ NULL,
    deleted_by BIGINT NULL,
    deleted_by_email CITEXT  NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_tenant_users_email_not_deleted
    ON tenant_users(email)
    WHERE deleted = FALSE;

CREATE INDEX IF NOT EXISTS ix_tenant_users_account_id
    ON tenant_users(account_id);

CREATE INDEX IF NOT EXISTS ix_tenant_users_deleted
    ON tenant_users(deleted);


============================================================
### FILE: src/main/resources/db/migration/tenants/V2__create_table_tenant_user_permissions.sql
============================================================
-- V2__create_table_tenant_user_permissions.sql
CREATE TABLE IF NOT EXISTS tenant_user_permissions (
    tenant_user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (tenant_user_id, permission),

    CONSTRAINT fk_tenant_user_permissions_user
        FOREIGN KEY (tenant_user_id)
        REFERENCES tenant_users(id)
        ON DELETE CASCADE
);

============================================================
### FILE: src/main/resources/db/migration/tenants/V3__create_table_categories.sql
============================================================
-- V3__create_table_categories.sql
CREATE TABLE IF NOT EXISTS categories (
  id BIGSERIAL PRIMARY KEY,

  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT,

  CONSTRAINT uk_categories_name UNIQUE (name)
);

CREATE INDEX IF NOT EXISTS idx_categories_active  ON categories(active);
CREATE INDEX IF NOT EXISTS idx_categories_deleted ON categories(deleted) WHERE deleted = false;
CREATE INDEX IF NOT EXISTS idx_categories_created_at ON categories(created_at);


============================================================
### FILE: src/main/resources/db/migration/tenants/V4__create_table_subcategories.sql
============================================================
-- V4__create_table_subcategories.sql

CREATE TABLE IF NOT EXISTS subcategories (
  id BIGSERIAL PRIMARY KEY,

  category_id BIGINT NOT NULL,
  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT,

  CONSTRAINT fk_subcategories_category
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE,

  CONSTRAINT uk_subcategories_name_category UNIQUE (category_id, name)
);

CREATE INDEX IF NOT EXISTS idx_subcategories_active  ON subcategories(active);
CREATE INDEX IF NOT EXISTS idx_subcategories_deleted ON subcategories(deleted) WHERE deleted = false;
CREATE INDEX IF NOT EXISTS idx_subcategories_category_id ON subcategories(category_id);


============================================================
### FILE: src/main/resources/db/migration/tenants/V5__create_table_suppliers.sql
============================================================
-- V5__create_table_suppliers.sql

CREATE TABLE IF NOT EXISTS suppliers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  contact_person VARCHAR(100),

  email VARCHAR(150),
  phone VARCHAR(20),
  address TEXT,

  document VARCHAR(20),
  document_type VARCHAR(10),

  website VARCHAR(200),
  payment_terms VARCHAR(100),

  lead_time_days INTEGER,
  rating NUMERIC(3,2),

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,

  notes TEXT,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_suppliers_document_active
  ON suppliers(document)
  WHERE document IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_supplier_name    ON suppliers(name);
CREATE INDEX IF NOT EXISTS idx_supplier_email   ON suppliers(email);
CREATE INDEX IF NOT EXISTS idx_supplier_active  ON suppliers(active);
CREATE INDEX IF NOT EXISTS idx_supplier_deleted ON suppliers(deleted) WHERE deleted = false;


============================================================
### FILE: src/main/resources/db/migration/tenants/V6__create_table_products.sql
============================================================
-- V6__create_table_products.sql
CREATE TABLE IF NOT EXISTS products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  description TEXT,

  sku VARCHAR(100) NOT NULL,
  price NUMERIC(10,2) NOT NULL,

  stock_quantity INT NOT NULL DEFAULT 0,
  min_stock INT,
  max_stock INT,

  cost_price NUMERIC(10,2),
  profit_margin NUMERIC(5,2),

  category_id BIGINT NOT NULL,
  subcategory_id BIGINT NULL,

  brand VARCHAR(100),
  weight_kg NUMERIC(8,3),
  dimensions VARCHAR(50),
  barcode VARCHAR(50),

  active BOOLEAN NOT NULL DEFAULT true,

  images_json TEXT,
  attributes_json TEXT,

  supplier_id UUID NULL,

  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT,

  CONSTRAINT fk_products_category
    FOREIGN KEY (category_id) REFERENCES categories(id),

  CONSTRAINT fk_products_subcategory
    FOREIGN KEY (subcategory_id) REFERENCES subcategories(id),

  CONSTRAINT fk_product_supplier
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id),

  CONSTRAINT ck_products_sku_not_blank
    CHECK (length(trim(sku)) > 0)
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_products_sku_not_deleted
  ON products (sku)
  WHERE deleted = false;

CREATE INDEX IF NOT EXISTS idx_products_name_lower
  ON products (LOWER(name));

CREATE INDEX IF NOT EXISTS idx_products_brand_lower
  ON products (LOWER(brand));

CREATE INDEX IF NOT EXISTS idx_products_active_deleted
  ON products (active, deleted);

CREATE INDEX IF NOT EXISTS idx_products_supplier_id ON products (supplier_id);
CREATE INDEX IF NOT EXISTS idx_products_category_id ON products (category_id);
CREATE INDEX IF NOT EXISTS idx_products_subcategory_id ON products (subcategory_id);
CREATE INDEX IF NOT EXISTS idx_products_created_at ON products (created_at);


============================================================
### FILE: src/main/resources/db/migration/tenants/V7__create_table_sales.sql
============================================================
-- V7__create_table_sales.sql

CREATE TABLE IF NOT EXISTS sales (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_date TIMESTAMPTZ NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL,

  customer_name VARCHAR(200),
  customer_document VARCHAR(20),
  customer_email VARCHAR(150),
  customer_phone VARCHAR(20),

  status VARCHAR(20) NOT NULL,

  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT
);

CREATE INDEX IF NOT EXISTS idx_sales_sale_date ON sales(sale_date);
CREATE INDEX IF NOT EXISTS idx_sales_status ON sales(status);
CREATE INDEX IF NOT EXISTS idx_sales_deleted ON sales(deleted) WHERE deleted = false;


============================================================
### FILE: src/main/resources/db/migration/tenants/V8__create_table_sales_items.sql
============================================================
-- V8__create_table_sales_items.sql

CREATE TABLE IF NOT EXISTS sale_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_id UUID NOT NULL,
  product_id UUID,
  product_name VARCHAR(255) NOT NULL,

  quantity NUMERIC(12,3) NOT NULL,
  unit_price NUMERIC(12,2) NOT NULL,
  total_price NUMERIC(12,2) NOT NULL,

  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT,

  CONSTRAINT fk_sale_items_sale
    FOREIGN KEY (sale_id) REFERENCES sales(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_sale_items_sale_id ON sale_items(sale_id);
CREATE INDEX IF NOT EXISTS idx_sale_items_product_id ON sale_items(product_id);
CREATE INDEX IF NOT EXISTS idx_sale_items_deleted ON sale_items(deleted) WHERE deleted = false;


============================================================
### FILE: src/test/java/brito/com/multitenancy001/Multitenancy001ApplicationTests.java
============================================================
package brito.com.multitenancy001;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Multitenancy001ApplicationTests {

	@Test
	void contextLoads() {
	}

}


